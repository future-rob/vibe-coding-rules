{
  "stacks": [
    {
      "id": "arduino-platformio",
      "name": "Arduino + PlatformIO",
      "directory": "Arduino + PlatformIO",
      "icon": "icons/arduino.png",
      "summary": "Embedded systems & microcontrollers",
      "focus": "Hardware abstraction, memory management, interrupts, safety",
      "readme": "# Cursor Rules for Arduino & Microcontroller Projects with PlatformIO\n\nThis repository contains Cursor AI coding rules and guidelines for Arduino and microcontroller projects using PlatformIO. These rules help maintain consistency, code quality, and best practices across embedded systems development when working with AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and hardware constraints for embedded systems development.\n\n## Overview of Rules\n\n### üìã Core Framework & Language (`core-framework-&-language.mdc`)\nDefines the foundational technology stack:\n- **Framework:** Arduino Framework with PlatformIO\n- **Language:** C++ (Arduino variant)\n- **Build System:** PlatformIO Core\n- **Supported Platforms:** AVR, ESP32, ESP8266, STM32, RP2040, and more\n\n### üîß Hardware Abstraction Patterns (`hardware-abstraction-patterns.mdc`)\nHardware abstraction layer (HAL) patterns:\n- **Pin Management:** Compile-time pin assignments\n- **Peripheral Abstraction:** SPI, I2C, UART interfaces\n- **Board Configuration:** Platform-specific configurations\n- **Driver Architecture:** Modular sensor/actuator drivers\n- **Hardware Traits:** Template-based hardware capabilities\n\n### üèóÔ∏è Key Architectural Patterns (`key-architecture-patterns.mdc`)\nCore architectural patterns for embedded systems:\n- **State Machines:** Finite state machine implementations\n- **Event-Driven Architecture:** Non-blocking event handling\n- **Task Scheduling:** Cooperative multitasking patterns\n- **Module System:** Component-based architecture\n- **Registry Pattern:** Dynamic peripheral registration\n\n### üíæ Memory Management Patterns (`memory-management-patterns.mdc`)\nMemory optimization and management strategies:\n- **Static Allocation:** Prefer compile-time memory allocation\n- **Memory Pools:** Fixed-size memory block allocation\n- **String Handling:** PROGMEM and F() macro usage\n- **Buffer Management:** Ring buffers and DMA patterns\n- **Stack Analysis:** Stack usage monitoring\n- **Heap Avoidance:** Minimize dynamic allocation\n\n### ‚ö° Interrupt Handling & Real-Time Patterns (`interrupt-handling-patterns.mdc`)\nInterrupt service routines and real-time constraints:\n- **ISR Design:** Minimal ISR execution time\n- **Volatile Variables:** Proper volatile usage\n- **Atomic Operations:** Critical section management\n- **Timer Management:** Hardware timer abstraction\n- **Priority Handling:** Interrupt priority schemes\n- **Debouncing:** Hardware and software debouncing\n\n### üí¨ Commenting Guidelines (`commenting-guidelines.mdc`)\nComprehensive documentation standards:\n- **Format:** Doxygen-style comments for functions and classes\n- **Hardware Comments:** Document pin connections and hardware assumptions\n- **Timing Comments:** Document timing constraints and delays\n- **Memory Comments:** Document memory usage and constraints\n- **Safety Comments:** Highlight safety-critical sections\n\n### üìù Logging Guidelines (`logging-guidelines.mdc`)\n**‚ö†Ô∏è IMPORTANT: Only add logs when asked for. By default, do NOT add logs.**\n\nEmbedded logging standards:\n- **Serial Output:** Conditional compilation with DEBUG flags\n- **Log Levels:** ERROR, WARN, INFO, DEBUG with minimal overhead\n- **Memory Efficiency:** Use PROGMEM for log strings\n- **Production Logs:** Minimal or no logging in production\n- **Debug Modes:** Rich debugging with compile-time switches\n\n### üéØ Code Style Guidelines (`code-style-guidelines.mdc`)\nEmbedded C++ coding standards:\n- **Naming:** camelCase for variables, PascalCase for classes\n- **Constants:** Use constexpr and #define appropriately\n- **Indentation:** 2 spaces, no tabs\n- **Braces:** K&R style for space efficiency\n- **Line Length:** 100 characters maximum\n- **File Organization:** Header guards, include order\n\n### ‚úÖ No Hiding (`no-hiding.mdc`)\n**Critical Rule:** Never hide compiler warnings. All warnings must be treated as errors.\n\n### üß™ Testing & Debugging (`testing-debugging.mdc`)\nEmbedded testing strategies:\n- **Unit Testing:** PlatformIO native tests\n- **Hardware-in-Loop:** Serial-based test frameworks\n- **Mocking:** Hardware abstraction layer mocking\n- **Debugging Tools:** Serial debugging, logic analyzers\n- **Simulation:** QEMU and Wokwi integration\n- **Assertions:** Compile-time and runtime assertions\n\n### üö® Error Handling Patterns (`error-handling-patterns.mdc`)\nEmbedded error management:\n- **Error Codes:** Enum-based error reporting\n- **Watchdog Timer:** Automatic recovery mechanisms\n- **Safe States:** Fail-safe default behaviors\n- **Error Propagation:** Result types without exceptions\n- **Diagnostic LEDs:** Visual error indication\n- **Recovery Strategies:** Graceful degradation\n\n### ‚ö° Performance Guidelines (`performance-guidelines.mdc`)\nMicrocontroller optimization techniques:\n- **Clock Management:** Dynamic frequency scaling\n- **Code Size:** Optimization for flash usage\n- **Execution Speed:** Time-critical path optimization\n- **Compiler Flags:** Platform-specific optimizations\n- **Inline Functions:** Strategic inlining\n- **Loop Optimization:** Unrolling and optimization\n\n### üì° Communication Patterns (`communication-patterns.mdc`)\nProtocol implementation patterns:\n- **Serial Protocols:** UART command parsers\n- **I2C/SPI:** Master/slave implementations\n- **Network Protocols:** MQTT, HTTP clients for IoT\n- **Protocol Buffers:** Efficient data serialization\n- **Message Queuing:** Inter-module communication\n- **Error Detection:** CRC and checksum implementation\n\n### üîÄ Git Workflow (`git-workflow.mdc`)\nVersion control for embedded projects:\n- **Commit Format:** Conventional Commits\n- **Binary Files:** Handling compiled outputs\n- **Library Management:** PlatformIO lib dependencies\n- **Board Configurations:** Environment branching\n- **CI/CD:** Automated builds and tests\n\n### üëÄ Code Review (`code-review.mdc`)\nEmbedded code review checklist:\n- **Hardware Safety:** Pin conflicts, voltage levels\n- **Timing Correctness:** Interrupt safety, delays\n- **Memory Usage:** Stack/heap analysis\n- **Power Consumption:** Sleep modes, optimization\n- **Error Handling:** Watchdog, recovery paths\n\n### üîã Power Management (`power-management.mdc`)\nLow-power design patterns:\n- **Sleep Modes:** Deep sleep, light sleep strategies\n- **Clock Gating:** Peripheral power management\n- **Wake Sources:** Interrupt-based waking\n- **Power Profiling:** Current measurement techniques\n- **Battery Management:** Voltage monitoring, protection\n- **Energy Harvesting:** Solar, kinetic integration\n\n### üìè Sensor Integration Patterns (`sensor-integration-patterns.mdc`)\nSensor interfacing best practices:\n- **Calibration:** Runtime and compile-time calibration\n- **Filtering:** Digital signal processing\n- **Sampling Strategies:** Timer-based, interrupt-driven\n- **Data Fusion:** Multi-sensor integration\n- **Error Detection:** Sensor fault detection\n- **Power Management:** Sensor sleep modes\n\n### üõ°Ô∏è Safety & Reliability (`safety-reliability.mdc`)\nSafety-critical design patterns:\n- **Redundancy:** Dual-channel architectures\n- **Self-Testing:** Built-in self-test (BIST)\n- **Fail-Safe States:** Safe shutdown procedures\n- **Input Validation:** Bounds checking, sanity checks\n- **Critical Sections:** Proper protection mechanisms\n- **Certification:** IEC 61508, ISO 26262 considerations\n\n### ‚öñÔ∏è Conflict Resolution (`conflict-resolution.mdc`)\nGuidance for resolving rule conflicts:\n- **Hardware Constraints:** When hardware limits override guidelines\n- **Performance vs Safety:** Balancing trade-offs\n- **Memory vs Features:** Resource allocation decisions\n- **Real-Time Constraints:** Priority resolution\n\n### üè≠ Build Configuration (`build-configuration.mdc`)\nPlatformIO configuration best practices:\n- **platformio.ini:** Environment configuration\n- **Build Flags:** Optimization and feature flags\n- **Library Dependencies:** Version pinning\n- **Custom Scripts:** Pre/post build automation\n- **Multi-Environment:** Target board management\n\n### üîå Pin Mapping & Configuration (`pin-mapping-configuration.mdc`)\nHardware pin management:\n- **Pin Definitions:** Centralized pin configuration\n- **Compile-Time Validation:** Pin conflict detection\n- **Board Variants:** Multi-board support\n- **Pin Functions:** Alternate function mapping\n- **Documentation:** Wiring diagrams in code\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @memory-management-patterns.mdc How should I implement a ring buffer for serial data?\n   ```\n\n### File Structure\n\n```\nvibe-coding-rules/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ Arduino + PlatformIO/\n    ‚îú‚îÄ‚îÄ build-configuration.mdc\n    ‚îú‚îÄ‚îÄ code-review.mdc\n    ‚îú‚îÄ‚îÄ code-style-guidelines.mdc\n    ‚îú‚îÄ‚îÄ commenting-guidelines.mdc\n    ‚îú‚îÄ‚îÄ communication-patterns.mdc\n    ‚îú‚îÄ‚îÄ conflict-resolution.mdc\n    ‚îú‚îÄ‚îÄ core-framework-&-language.mdc\n    ‚îú‚îÄ‚îÄ error-handling-patterns.mdc\n    ‚îú‚îÄ‚îÄ git-workflow.mdc\n    ‚îú‚îÄ‚îÄ hardware-abstraction-patterns.mdc\n    ‚îú‚îÄ‚îÄ interrupt-handling-patterns.mdc\n    ‚îú‚îÄ‚îÄ key-architecture-patterns.mdc\n    ‚îú‚îÄ‚îÄ logging-guidelines.mdc\n    ‚îú‚îÄ‚îÄ memory-management-patterns.mdc\n    ‚îú‚îÄ‚îÄ no-hiding.mdc\n    ‚îú‚îÄ‚îÄ performance-guidelines.mdc\n    ‚îú‚îÄ‚îÄ pin-mapping-configuration.mdc\n    ‚îú‚îÄ‚îÄ power-management.mdc\n    ‚îú‚îÄ‚îÄ safety-reliability.mdc\n    ‚îú‚îÄ‚îÄ sensor-integration-patterns.mdc\n    ‚îî‚îÄ‚îÄ testing-debugging.mdc\n```\n\n## Quick Reference\n\n### When Writing Embedded Code\n- ‚úÖ Use static memory allocation whenever possible\n- ‚úÖ **NEVER use String class** - Use char arrays with bounds checking\n- ‚úÖ Keep ISRs minimal - just set flags and return\n- ‚úÖ Document all hardware assumptions and connections\n- ‚úÖ Never hide compiler warnings - treat as errors\n- ‚úÖ Use appropriate logging (only when requested)\n- ‚úÖ Follow architectural patterns (State Machines, Event-Driven)\n\n### When Configuring Hardware\n- ‚úÖ Define all pins in a central configuration file\n- ‚úÖ Use compile-time constants for pin assignments\n- ‚úÖ Document voltage levels and current requirements\n- ‚úÖ Implement proper pull-up/pull-down configurations\n- ‚úÖ Validate pin functions don't conflict\n- ‚úÖ Use hardware abstraction layers for portability\n\n### When Managing Memory\n- ‚úÖ Prefer stack allocation over heap\n- ‚úÖ Use PROGMEM for constant strings and data\n- ‚úÖ Implement bounds checking on all arrays\n- ‚úÖ Monitor stack usage in deep call chains\n- ‚úÖ Use memory pools for dynamic allocation\n- ‚úÖ Avoid memory fragmentation\n\n### When Handling Interrupts\n- ‚úÖ Keep ISRs under 10 microseconds when possible\n- ‚úÖ Use volatile for ISR-shared variables\n- ‚úÖ Implement proper critical sections\n- ‚úÖ Avoid function calls in ISRs\n- ‚úÖ Use atomic operations for flag setting\n- ‚úÖ Document interrupt priorities\n\n### When Optimizing Performance\n- ‚úÖ Profile before optimizing\n- ‚úÖ Use compiler optimization flags appropriately\n- ‚úÖ Minimize float operations on 8-bit MCUs\n- ‚úÖ Use bit manipulation for flags\n- ‚úÖ Unroll critical loops when needed\n- ‚úÖ Consider assembly for ultra-critical sections\n\n### When Implementing Communication\n- ‚úÖ Use DMA for high-speed transfers when available\n- ‚úÖ Implement timeout mechanisms\n- ‚úÖ Add CRC/checksum verification\n- ‚úÖ Use ring buffers for serial data\n- ‚úÖ Handle partial message reception\n- ‚úÖ Document protocol specifications\n\n### When Managing Power\n- ‚úÖ Use sleep modes aggressively\n- ‚úÖ Disable unused peripherals\n- ‚úÖ Implement wake-on-interrupt\n- ‚úÖ Monitor battery voltage\n- ‚úÖ Use power-efficient algorithms\n- ‚úÖ Document power consumption\n\n### When Testing\n- ‚úÖ Write unit tests for business logic\n- ‚úÖ Use hardware abstraction for testability\n- ‚úÖ Implement serial-based test commands\n- ‚úÖ Add diagnostic modes\n- ‚úÖ Use static analysis tools\n- ‚úÖ Test edge cases and error conditions\n\n### When Reviewing Code\n- ‚úÖ Check for blocking operations\n- ‚úÖ Verify interrupt safety\n- ‚úÖ Analyze memory usage\n- ‚úÖ Review power consumption\n- ‚úÖ Validate timing constraints\n- ‚úÖ Ensure error recovery paths\n\n### When Ensuring Safety\n- ‚úÖ Implement watchdog timers\n- ‚úÖ Add input validation\n- ‚úÖ Define safe default states\n- ‚úÖ Test failure scenarios\n- ‚úÖ Document safety assumptions\n- ‚úÖ Consider certification requirements\n\n## Contributing\n\nWhen updating these rules:\n1. Consider hardware constraints and limitations\n2. Include real-world examples from embedded systems\n3. Update this README if adding new rule files\n4. Ensure consistency with embedded best practices\n5. Test guidelines on multiple microcontroller platforms\n\n## Notes\n\n- These rules are specifically tailored for Arduino-compatible microcontrollers using PlatformIO\n- Rules marked with `alwaysApply: true` are enforced automatically\n- The logging guidelines emphasize minimal logging by default - embedded systems have limited resources\n- The \"no-hiding\" rule is critical - all compiler warnings must be resolved\n- When rules conflict, hardware constraints take precedence\n- Real-time constraints may override general programming practices\n- Safety-critical applications may require additional guidelines beyond these\n",
      "guides": [
        {
          "id": "code-review",
          "title": "Code Review",
          "fileName": "code-review.mdc",
          "frontmatter": {
            "description": "Code review checklist and best practices for embedded systems development",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h"
            ],
            "alwaysApply": true
          },
          "content": "# Code Review Guidelines\n\n## Review Philosophy\n\nCode review for embedded systems focuses on:\n1. **Reliability** - Ensuring code works correctly on hardware\n2. **Resource Efficiency** - Memory and CPU usage within constraints\n3. **Real-Time Safety** - Timing constraints and interrupt handling\n4. **Hardware Compatibility** - Correct hardware interface usage\n5. **Maintainability** - Code clarity and documentation\n\n## Review Checklist\n\n### Functionality\n\n- [ ] Does the code work as intended on hardware?\n- [ ] Are edge cases handled (buffer overflow, underflow)?\n- [ ] Are error cases handled properly?\n- [ ] Is the code complete (no TODOs or placeholders)?\n- [ ] Are there any obvious bugs or logic errors?\n- [ ] Has it been tested on actual hardware?\n\n### Hardware Safety\n\n- [ ] Are pin assignments correct and documented?\n- [ ] Are voltage levels appropriate (3.3V vs 5V)?\n- [ ] Are pull-up/pull-down resistors configured correctly?\n- [ ] Is there any risk of short circuits or damage?\n- [ ] Are timing constraints met (setup/hold times)?\n- [ ] Is power consumption acceptable?\n\n### Memory Management\n\n- [ ] Is memory usage within limits?\n- [ ] Are there any memory leaks (even in error paths)?\n- [ ] Is PROGMEM used for constant strings?\n- [ ] Are buffers sized appropriately (not too large/small)?\n- [ ] Is stack usage reasonable (no risk of overflow)?\n- [ ] Is dynamic allocation avoided where possible?\n\n### Real-Time Constraints\n\n- [ ] Are ISRs minimal (< 50us typically)?\n- [ ] Are blocking operations avoided in ISRs?\n- [ ] Are critical sections properly protected?\n- [ ] Is interrupt priority configured correctly?\n- [ ] Are timing-sensitive operations handled correctly?\n- [ ] Is watchdog timer fed appropriately?\n\n### Code Quality\n\n- [ ] Does the code follow style guidelines?\n- [ ] Are variable names descriptive (no abbreviations)?\n- [ ] Is the code readable and maintainable?\n- [ ] Are there any compiler warnings?\n- [ ] Is there code duplication that should be refactored?\n- [ ] Are magic numbers replaced with named constants?\n\n### Architecture\n\n- [ ] Does the code follow architectural patterns?\n- [ ] Is hardware abstraction used appropriately?\n- [ ] Is the code properly organized (correct file structure)?\n- [ ] Are dependencies clear and minimal?\n- [ ] Is platform-specific code isolated?\n\n### Error Handling\n\n- [ ] Are errors handled appropriately?\n- [ ] Are error codes used consistently?\n- [ ] Is error recovery implemented?\n- [ ] Are errors logged appropriately (if logging enabled)?\n- [ ] Does the system fail safely?\n\n### Performance\n\n- [ ] Is the code optimized appropriately?\n- [ ] Are expensive operations avoided in hot paths?\n- [ ] Is floating-point math minimized on 8-bit MCUs?\n- [ ] Are lookups used instead of calculations where possible?\n- [ ] Is DMA used for bulk transfers when available?\n\n### Security\n\n- [ ] Are inputs validated (bounds checking)?\n- [ ] Are secrets properly handled (not hardcoded)?\n- [ ] Is sensitive data not logged?\n- [ ] Are communication protocols secure?\n- [ ] Is firmware update mechanism secure?\n\n### Documentation\n\n- [ ] Are hardware assumptions documented?\n- [ ] Are pin connections documented?\n- [ ] Are timing constraints documented?\n- [ ] Are complex algorithms explained?\n- [ ] Is the code self-documenting?\n\n### Testing\n\n- [ ] Are unit tests present (if applicable)?\n- [ ] Has the code been tested on hardware?\n- [ ] Are edge cases tested?\n- [ ] Are error conditions tested?\n- [ ] Is test coverage adequate?\n\n## Review Process\n\n### For Authors\n\n1. **Self-Review First**\n   - Review your own code before requesting review\n   - Run `pio check` to verify no warnings\n   - Test on hardware\n   - Check memory usage\n   - Verify timing constraints\n\n2. **Prepare PR**\n   - Write clear PR description\n   - Document hardware requirements\n   - Note pin configuration changes\n   - Include test results\n   - Reference related issues\n   - Add scope labels (hal, drivers, sensors, etc.)\n\n3. **Respond to Feedback**\n   - Be open to feedback\n   - Ask questions if unclear\n   - Make requested changes promptly\n   - Re-test on hardware after changes\n   - Update PR description if needed\n\n### For Reviewers\n\n1. **Understand Context**\n   - Read PR description carefully\n   - Understand hardware requirements\n   - Check related issues\n   - Review code in context\n\n2. **Review Thoroughly**\n   - Check all checklist items\n   - Test on hardware if possible\n   - Verify memory and timing constraints\n   - Look for edge cases\n\n3. **Provide Constructive Feedback**\n   - Be specific about issues\n   - Suggest solutions, not just problems\n   - Explain why changes are needed\n   - Be respectful and professional\n\n4. **Approve When Ready**\n   - Only approve when all concerns addressed\n   - Verify hardware testing completed\n   - Ensure no warnings remain\n   - Confirm documentation is adequate\n\n## Common Issues to Look For\n\n### Memory Issues\n\n```cpp\n// ‚ùå BAD - Potential buffer overflow\nvoid processData(uint8_t* data, size_t length) {\n  uint8_t buffer[64];\n  memcpy(buffer, data, length);  // No bounds check\n}\n\n// ‚úÖ GOOD - Bounds checking\nvoid processData(uint8_t* data, size_t length) {\n  uint8_t buffer[64];\n  size_t copyLen = min(length, sizeof(buffer));\n  memcpy(buffer, data, copyLen);\n}\n```\n\n### Interrupt Safety\n\n```cpp\n// ‚ùå BAD - Non-atomic operation in ISR\nvolatile uint32_t counter = 0;\nISR(TIMER1_COMPA_vect) {\n  counter++;  // Not atomic on 8-bit MCU\n}\n\n// ‚úÖ GOOD - Atomic operation\nvolatile uint32_t counter = 0;\nISR(TIMER1_COMPA_vect) {\n  // Use atomic increment or disable interrupts\n  noInterrupts();\n  counter++;\n  interrupts();\n}\n```\n\n### Timing Issues\n\n```cpp\n// ‚ùå BAD - Blocking delay in main loop\nvoid loop() {\n  readSensor();\n  delay(1000);  // Blocks for 1 second\n  updateDisplay();\n}\n\n// ‚úÖ GOOD - Non-blocking timing\nvoid loop() {\n  static uint32_t lastRead = 0;\n  if (millis() - lastRead >= 1000) {\n    readSensor();\n    lastRead = millis();\n  }\n  updateDisplay();\n}\n```\n\n### Hardware Assumptions\n\n```cpp\n// ‚ùå BAD - Platform-specific code without guards\nvoid initGPIO() {\n  pinMode(21, OUTPUT);  // ESP32 pin, won't work on AVR\n}\n\n// ‚úÖ GOOD - Platform abstraction\nvoid initGPIO() {\n  #ifdef ESP32\n    pinMode(21, OUTPUT);\n  #elif defined(ARDUINO_AVR_UNO)\n    pinMode(13, OUTPUT);\n  #endif\n}\n```\n\n## Review Comments\n\n### Good Review Comments\n\n```cpp\n// ‚úÖ GOOD - Specific and actionable\n// Consider adding bounds checking here. If length > 256, \n// this will overflow the buffer. Suggest:\n// size_t copyLen = min(length, sizeof(buffer));\n\n// ‚úÖ GOOD - Explains why\n// This delay blocks the main loop. Consider using \n// non-blocking timing pattern to keep system responsive.\n\n// ‚úÖ GOOD - Suggests solution\n// This ISR is too long (~150us measured). Consider \n// moving heavy processing to main loop and using flags.\n```\n\n### Bad Review Comments\n\n```cpp\n// ‚ùå BAD - Vague\n// This doesn't look right.\n\n// ‚ùå BAD - Not constructive\n// This is wrong.\n\n// ‚ùå BAD - No explanation\n// Use PROGMEM here.\n```\n\n## Hardware Testing Checklist\n\nWhen reviewing hardware-related code:\n\n- [ ] Code tested on actual hardware (not just simulator)\n- [ ] Tested on all target platforms\n- [ ] Pin connections verified\n- [ ] Timing verified with oscilloscope/logic analyzer\n- [ ] Power consumption measured\n- [ ] Memory usage verified\n- [ ] Error conditions tested (disconnect sensor, etc.)\n- [ ] Long-term stability tested (24+ hours)\n\n## Approval Criteria\n\nCode should be approved when:\n\n- ‚úÖ All review comments addressed\n- ‚úÖ No compiler warnings\n- ‚úÖ Tested on hardware\n- ‚úÖ Memory usage acceptable\n- ‚úÖ Timing constraints met\n- ‚úÖ Error handling complete\n- ‚úÖ Documentation adequate\n- ‚úÖ Follows all guidelines\n- ‚úÖ No security issues\n- ‚úÖ Code is maintainable\n\n## Best Practices Summary\n\n1. **Hardware First**: Always verify hardware compatibility\n2. **Memory Awareness**: Check memory usage and constraints\n3. **Timing Safety**: Verify real-time constraints are met\n4. **Error Handling**: Ensure robust error handling\n5. **Documentation**: Verify hardware assumptions documented\n6. **Testing**: Require hardware testing before approval\n7. **Constructive Feedback**: Provide specific, actionable comments\n8. **No Warnings**: Never approve code with warnings\n9. **Security**: Check for security vulnerabilities\n10. **Maintainability**: Ensure code is readable and maintainable",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h"
          ]
        },
        {
          "id": "code-style-guidelines",
          "title": "Code Style Guidelines",
          "fileName": "code-style-guidelines.mdc",
          "frontmatter": {
            "description": "Code style guidelines and conventions for embedded C++ development",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/*.hpp",
              "**/*.ino"
            ],
            "alwaysApply": true
          },
          "content": "# Code Style Guidelines\n\n## Overview\n\nConsistent code style improves readability, reduces errors, and makes collaboration easier. These guidelines are optimized for embedded C++ development, balancing clarity with the constraints of resource-limited systems.\n\n## Naming Conventions\n\n### General Rules\n\n```cpp\n// ‚úÖ GOOD - Descriptive names\nuint16_t sensorReadingCount;\nfloat temperatureCelsius;\nbool isMotorRunning;\n\n// ‚ùå BAD - Abbreviated or unclear names\nuint16_t src;  // What is src?\nfloat temp;    // Temperature? Temporary?\nbool flag;     // What flag?\n\n// ‚ùå BAD - Hungarian notation (avoid in modern C++)\nuint16_t u16Count;\nfloat fTemperature;\nbool bRunning;\n```\n\n### Specific Conventions\n\n```cpp\n// Constants - SCREAMING_SNAKE_CASE\nconstexpr uint16_t MAX_BUFFER_SIZE = 256;\nconstexpr uint32_t DEFAULT_BAUD_RATE = 115200;\nconst char DEVICE_NAME[] PROGMEM = \"Sensor Node\";\n\n// Macros - SCREAMING_SNAKE_CASE (but prefer constexpr)\n#define DEBUG_LEVEL 2\n#define PIN_LED 13\n\n// Classes - PascalCase\nclass TemperatureSensor {\n    // ...\n};\n\nclass SerialProtocol {\n    // ...\n};\n\n// Functions - camelCase\nvoid initializeSensors();\nfloat readTemperature();\nbool validateChecksum(uint8_t* data, size_t length);\n\n// Variables - camelCase\nuint32_t lastUpdateTime;\nfloat currentTemperature;\nbool systemReady;\n\n// Member variables - camelCase with underscore suffix (optional but recommended)\nclass Sensor {\nprivate:\n    uint8_t address_;\n    float calibrationOffset_;\n    bool initialized_;\n};\n\n// Enums - PascalCase for type, SCREAMING_SNAKE_CASE for values\nenum class SystemState : uint8_t {\n    IDLE = 0,\n    INITIALIZING = 1,\n    RUNNING = 2,\n    ERROR = 3,\n    SHUTDOWN = 4\n};\n\n// Namespaces - lowercase\nnamespace sensors {\nnamespace temperature {\n    class DS18B20 {};\n} // namespace temperature\n} // namespace sensors\n\n// Template parameters - PascalCase for types, lowercase for values\ntemplate<typename DataType, size_t bufferSize>\nclass CircularBuffer {\n    // ...\n};\n\n// Pin names - Descriptive with common prefixes\nconstexpr uint8_t PIN_BUTTON_START = 2;\nconstexpr uint8_t PIN_LED_STATUS = 13;\nconstexpr uint8_t PIN_SENSOR_DATA = A0;\nconstexpr uint8_t PIN_I2C_SDA = 21;\nconstexpr uint8_t PIN_I2C_SCL = 22;\n\n// File names - snake_case\n// temperature_sensor.h\n// serial_protocol.cpp\n// main.cpp\n```\n\n## Formatting\n\n### Indentation and Spacing\n\n```cpp\n// Use 2 spaces for indentation (no tabs)\nvoid processData() {\n  if (dataReady) {\n    for (uint8_t i = 0; i < bufferSize; i++) {\n      processedData[i] = rawData[i] * scaleFactor;\n    }\n  }\n}\n\n// Spaces around operators\nint sum = a + b;\nbool isValid = (value >= MIN_VALUE) && (value <= MAX_VALUE);\nuint8_t masked = data & 0x0F;\n\n// No space after function names\ncalculateChecksum();  // ‚úÖ\ncalculateChecksum (); // ‚ùå\n\n// Space after keywords\nif (condition) {    // ‚úÖ\nif(condition) {     // ‚ùå\n\nfor (int i = 0; i < 10; i++) {  // ‚úÖ\nfor(int i=0;i<10;i++) {         // ‚ùå\n\n// Pointer and reference alignment\nuint8_t* ptr;   // ‚úÖ Aligned with type\nuint8_t *ptr;   // ‚ùå\nuint8_t& ref;   // ‚úÖ\nuint8_t &ref;   // ‚ùå\n```\n\n### Braces\n\n```cpp\n// K&R style for functions (opening brace on same line)\nvoid setup() {\n  // Initialize\n}\n\n// Same line for control structures\nif (condition) {\n  // True branch\n} else {\n  // False branch\n}\n\n// Always use braces, even for single statements\nif (error) {\n  return;  // ‚úÖ\n}\n\nif (error)\n  return;  // ‚ùå Avoid\n\n// Exception: Guard clauses can be one line\nif (!initialized) return ErrorCode::NOT_INITIALIZED;\nif (index >= size) return ErrorCode::OUT_OF_BOUNDS;\n```\n\n### Line Length\n\n```cpp\n// Maximum 100 characters per line\n// Break long lines at logical points\n\n// ‚úÖ GOOD - Readable line breaks\nResult<float> temperature = sensor.readTemperature()\n    .andThen([](float t) { return convertToFahrenheit(t); })\n    .map([](float f) { return roundToDecimal(f, 1); });\n\n// ‚ùå BAD - Too long\nResult<float> temperature = sensor.readTemperature().andThen([](float t) { return convertToFahrenheit(t); }).map([](float f) { return roundToDecimal(f, 1); });\n\n// Function declarations\nErrorCode initializeSensor(\n    uint8_t address,\n    uint32_t baudRate,\n    const SensorConfig& config);\n\n// Long string literals\nconst char message[] PROGMEM = \n    \"This is a very long message that would exceed the line limit \"\n    \"so we break it into multiple string literals that the compiler \"\n    \"will automatically concatenate.\";\n```\n\n## Comments\n\n### Documentation Comments\n\n```cpp\n/**\n * @brief Reads temperature from the sensor\n * \n * @param sensor The sensor instance to read from\n * @param retries Number of retry attempts (default: 3)\n * @return Temperature in Celsius, or NaN on error\n * \n * @note This function blocks for up to 100ms\n * @warning Ensure sensor is initialized before calling\n */\nfloat readTemperature(TemperatureSensor& sensor, uint8_t retries = 3);\n\n/**\n * @brief Manages communication with I2C devices\n * \n * This class provides a high-level interface for I2C communication\n * with automatic error handling and retry logic.\n * \n * @tparam ClockSpeed I2C clock frequency in Hz\n */\ntemplate<uint32_t ClockSpeed = 100000>\nclass I2CManager {\n  // ...\n};\n```\n\n### Inline Comments\n\n```cpp\n// Use comments to explain WHY, not WHAT\n// ‚úÖ GOOD\ndelay(10);  // DHT sensor requires 10ms setup time after power-on\n\n// ‚ùå BAD\ndelay(10);  // Delay for 10 milliseconds\n\n// Complex algorithms need step-by-step explanation\nuint8_t calculateCRC8(const uint8_t* data, size_t length) {\n  uint8_t crc = 0xFF;  // Initialize with all bits set\n  \n  for (size_t i = 0; i < length; i++) {\n    crc ^= data[i];  // XOR with data byte\n    \n    // Process each bit\n    for (uint8_t bit = 0; bit < 8; bit++) {\n      if (crc & 0x80) {\n        crc = (crc << 1) ^ 0x31;  // Polynomial: x^8 + x^5 + x^4 + 1\n      } else {\n        crc <<= 1;\n      }\n    }\n  }\n  \n  return crc;\n}\n\n// TODO/FIXME/HACK comments should include context\n// TODO(john): Add timeout handling - currently blocks indefinitely\n// FIXME: Buffer overflow possible if length > 255\n// HACK: Delay needed due to hardware bug in v1.0 boards\n```\n\n## Type Usage\n\n### Integer Types\n\n```cpp\n// Always use fixed-width types for portability\n#include <stdint.h>\n\n// ‚úÖ GOOD\nuint8_t  byteValue;    // Always 8 bits\nuint16_t wordValue;    // Always 16 bits\nuint32_t dwordValue;   // Always 32 bits\nint16_t  signedValue;  // Always 16 bits, signed\n\n// ‚ùå AVOID\nunsigned char byteValue;    // Size varies by platform\nunsigned int wordValue;     // Size varies by platform\nlong value;                 // Size varies by platform\n\n// Size types\nsize_t arraySize;           // For sizes and counts\nptrdiff_t offset;          // For pointer arithmetic\n\n// Boolean - use bool, not int\nbool isReady = false;       // ‚úÖ\nint isReady = 0;           // ‚ùå\n\n// Bit fields for hardware registers\nunion StatusRegister {\n  struct {\n    uint8_t ready : 1;\n    uint8_t error : 1;\n    uint8_t busy : 1;\n    uint8_t reserved : 5;\n  } bits;\n  uint8_t raw;\n};\n```\n\n### Constants\n\n```cpp\n// Prefer constexpr over #define\nconstexpr uint16_t BUFFER_SIZE = 256;         // ‚úÖ\n#define BUFFER_SIZE 256                        // ‚ùå (except for conditional compilation)\n\n// Compile-time constants\nconstexpr float PI = 3.14159265359f;\nconstexpr uint32_t CLOCK_FREQUENCY = 16000000UL;\n\n// Runtime constants\nconst uint8_t deviceAddress = readAddressFromEEPROM();\n\n// String constants in PROGMEM\nconst char VERSION[] PROGMEM = \"1.0.0\";\nconst char ERROR_MSG[] PROGMEM = \"Communication error\";\n\n// Enums for related constants\nenum class BaudRate : uint32_t {\n  SLOW = 9600,\n  NORMAL = 115200,\n  FAST = 921600\n};\n```\n\n### Auto Keyword\n\n```cpp\n// Use auto for complex types where the type is obvious\nauto result = sensor.read();  // When return type is clear\nauto it = container.begin();  // Iterator types\n\n// Be explicit for fundamental types\nint count = getCount();       // ‚úÖ\nauto count = getCount();      // ‚ùå Less clear\n\n// Use auto with lambdas\nauto processData = [](uint8_t* data, size_t len) {\n  // Process data\n};\n```\n\n## Functions\n\n### Function Design\n\n```cpp\n// Single responsibility - do one thing well\n// ‚úÖ GOOD\nfloat readTemperature();\nvoid displayTemperature(float temp);\n\n// ‚ùå BAD\nfloat readAndDisplayTemperature();  // Does two things\n\n// Short functions preferred (< 50 lines)\n// Use meaningful names\nvoid initializeSerialPort();      // ‚úÖ\nvoid init();                      // ‚ùå Too vague\n\n// Parameter order: outputs, then inputs\nvoid convertData(uint8_t* output, const uint8_t* input, size_t length);\n\n// Use const for input parameters\nvoid processData(const SensorData& data);    // ‚úÖ\nvoid processData(SensorData& data);          // ‚ùå If not modified\n\n// Return early for error conditions\nErrorCode readSensor(float& value) {\n  if (!initialized_) return ErrorCode::NOT_INITIALIZED;\n  if (!sensorPresent_) return ErrorCode::DEVICE_NOT_FOUND;\n  \n  // Main logic here\n  value = performReading();\n  return ErrorCode::OK;\n}\n```\n\n### Function Parameters\n\n```cpp\n// Pass by const reference for structures\nvoid processSensorData(const SensorData& data);     // ‚úÖ\nvoid processSensorData(SensorData data);            // ‚ùå Unnecessary copy\n\n// Pass primitives by value\nvoid setThreshold(float threshold);                 // ‚úÖ\nvoid setThreshold(const float& threshold);          // ‚ùå Overkill\n\n// Use default parameters sparingly\nvoid delay(uint32_t ms, bool interruptible = false);\n\n// Output parameters via pointer or reference\nbool readValue(float& value);          // Return success, output via reference\nErrorCode getValue(float* value);      // Return error code, output via pointer\n\n// Avoid too many parameters (max 4-5)\n// ‚ùå BAD\nvoid configureSensor(uint8_t addr, uint32_t baud, uint8_t mode, \n                    float gain, uint16_t avg, bool pullup);\n\n// ‚úÖ GOOD - Use a configuration structure\nstruct SensorConfig {\n  uint8_t address;\n  uint32_t baudRate;\n  uint8_t mode;\n  float gain;\n  uint16_t averaging;\n  bool enablePullup;\n};\n\nvoid configureSensor(const SensorConfig& config);\n```\n\n## Classes\n\n### Class Design\n\n```cpp\nclass TemperatureSensor {\npublic:\n  // Constructors first\n  TemperatureSensor(uint8_t pin);\n  \n  // Destructor (if needed)\n  ~TemperatureSensor() = default;\n  \n  // Deleted copy operations if not copyable\n  TemperatureSensor(const TemperatureSensor&) = delete;\n  TemperatureSensor& operator=(const TemperatureSensor&) = delete;\n  \n  // Public interface\n  bool begin();\n  float readCelsius();\n  float readFahrenheit();\n  \n  // Getters/setters last\n  void setOffset(float offset) { offset_ = offset; }\n  float getOffset() const { return offset_; }\n\nprivate:\n  // Private members\n  uint8_t pin_;\n  float offset_;\n  uint32_t lastReadTime_;\n  \n  // Private methods\n  float applyCalibration(float raw);\n};\n\n// Initialization lists\nTemperatureSensor::TemperatureSensor(uint8_t pin)\n    : pin_(pin), offset_(0.0f), lastReadTime_(0) {\n  // Constructor body only for complex initialization\n}\n```\n\n### Inheritance\n\n```cpp\n// Interface base class\nclass ISensor {\npublic:\n  virtual ~ISensor() = default;\n  virtual bool begin() = 0;\n  virtual float read() = 0;\n  virtual const char* getName() const = 0;\n};\n\n// Concrete implementation\nclass DHT22 : public ISensor {\npublic:\n  explicit DHT22(uint8_t pin) : pin_(pin) {}\n  \n  bool begin() override;\n  float read() override;\n  const char* getName() const override { return \"DHT22\"; }\n  \nprivate:\n  uint8_t pin_;\n};\n\n// Prefer composition over inheritance\nclass SensorManager {\nprivate:\n  ISensor* sensor_;  // Composition\npublic:\n  explicit SensorManager(ISensor* sensor) : sensor_(sensor) {}\n};\n```\n\n## Memory Management\n\n### PROGMEM Usage\n\n```cpp\n// String constants\nconst char MENU_TITLE[] PROGMEM = \"Main Menu\";\nconst char MENU_ITEM_1[] PROGMEM = \"Settings\";\n\n// Arrays of strings\nconst char* const menuItems[] PROGMEM = {\n  MENU_TITLE,\n  MENU_ITEM_1\n};\n\n// Data tables\nconst uint16_t sineLookup[] PROGMEM = {\n  0, 1144, 2287, 3430, 4571, 5712, 6850, 7987\n};\n\n// F() macro for immediate use\nSerial.println(F(\"System initialized\"));\n```\n\n### Dynamic Allocation\n\n```cpp\n// AVOID dynamic allocation when possible\n// ‚ùå BAD\nfloat* buffer = new float[100];\n// ... use buffer\ndelete[] buffer;\n\n// ‚úÖ GOOD - Static allocation\nfloat buffer[100];\n\n// If dynamic allocation is necessary, use RAII\ntemplate<typename T>\nclass DynamicBuffer {\nprivate:\n  T* data_;\n  size_t size_;\n  \npublic:\n  explicit DynamicBuffer(size_t size) \n      : data_(new T[size]), size_(size) {}\n      \n  ~DynamicBuffer() { delete[] data_; }\n  \n  // Delete copy operations\n  DynamicBuffer(const DynamicBuffer&) = delete;\n  DynamicBuffer& operator=(const DynamicBuffer&) = delete;\n  \n  T& operator[](size_t index) { return data_[index]; }\n  size_t size() const { return size_; }\n};\n```\n\n## Error Handling\n\n```cpp\n// Use error codes, not exceptions\nenum class ErrorCode : int8_t {\n  OK = 0,\n  INVALID_PARAMETER = -1,\n  TIMEOUT = -2,\n  HARDWARE_FAULT = -3\n};\n\n// Return error codes\nErrorCode readSensor(float& value) {\n  if (!initialized_) {\n    return ErrorCode::NOT_INITIALIZED;\n  }\n  \n  // Read sensor\n  value = analogRead(pin_) * scale_;\n  return ErrorCode::OK;\n}\n\n// Check errors explicitly\nfloat temperature;\nErrorCode result = readSensor(temperature);\nif (result != ErrorCode::OK) {\n  handleError(result);\n}\n```\n\n## Platform-Specific Code\n\n```cpp\n// Use conditional compilation for platform differences\n#ifdef ARDUINO_ARCH_AVR\n  // AVR-specific code\n  #include <avr/pgmspace.h>\n  #define READ_PROGMEM(addr) pgm_read_byte(addr)\n#elif defined(ESP32)\n  // ESP32-specific code\n  #include <esp_system.h>\n  #define READ_PROGMEM(addr) (*addr)\n#else\n  #error \"Unsupported platform\"\n#endif\n\n// Platform abstraction\nclass SystemInfo {\npublic:\n  static uint32_t getFreeMemory() {\n    #ifdef ARDUINO_ARCH_AVR\n      extern int __heap_start, *__brkval;\n      int v;\n      return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);\n    #elif defined(ESP32)\n      return ESP.getFreeHeap();\n    #else\n      return 0;\n    #endif\n  }\n};\n```\n\n## File Organization\n\n### Header Files\n\n```cpp\n// header_example.h\n#pragma once  // Or use header guards\n\n// System includes first\n#include <stdint.h>\n#include <Arduino.h>\n\n// Library includes\n#include <Wire.h>\n#include <SPI.h>\n\n// Project includes\n#include \"config.h\"\n#include \"types.h\"\n\n// Forward declarations\nclass Sensor;\nstruct Configuration;\n\n// Class definition\nclass Example {\n  // ...\n};\n\n// Inline functions (only if truly needed in header)\ninline uint16_t swap16(uint16_t value) {\n  return (value >> 8) | (value << 8);\n}\n```\n\n### Source Files\n\n```cpp\n// example.cpp\n\n// Corresponding header first\n#include \"example.h\"\n\n// System includes\n#include <string.h>\n\n// Other project headers\n#include \"debug.h\"\n#include \"utilities.h\"\n\n// Anonymous namespace for file-local items\nnamespace {\n  constexpr uint32_t MAGIC_NUMBER = 0xDEADBEEF;\n  \n  void helperFunction() {\n    // Local to this file\n  }\n} // anonymous namespace\n\n// Implementation\nExample::Example() {\n  // Constructor implementation\n}\n```\n\n## Best Practices Summary\n\n1. **Descriptive Names**: Use full, meaningful names\n2. **Consistent Style**: Follow naming conventions consistently\n3. **Fixed-Width Types**: Use stdint.h types for portability\n4. **PROGMEM**: Store constants in program memory\n5. **Error Codes**: Use enums for error handling\n6. **Short Functions**: Keep functions focused and concise\n7. **Const Correctness**: Mark unmodified parameters const\n8. **Static Allocation**: Prefer compile-time memory allocation\n9. **Platform Abstraction**: Isolate platform-specific code\n10. **Clear Comments**: Document why, not what",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/*.hpp",
            "**/*.ino"
          ]
        },
        {
          "id": "commenting-guidelines",
          "title": "Commenting Guidelines",
          "fileName": "commenting-guidelines.mdc",
          "frontmatter": {
            "description": "Commenting and documentation standards for embedded C++ code",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/*.hpp"
            ],
            "alwaysApply": true
          },
          "content": "# Commenting Guidelines\n\n## Philosophy\n\nComments should explain **why** and **intent**, not **what**. The code itself should be self-documenting through clear naming and structure. In embedded systems, comments are especially important for documenting hardware assumptions, timing constraints, and non-obvious optimizations.\n\n## Documentation Comments\n\n### Function Documentation\n\n```cpp\n/**\n * @brief Reads temperature from the DHT22 sensor\n * \n * Performs a complete sensor reading cycle including:\n * - Initiating communication\n * - Reading 40 bits of data\n * - Validating checksum\n * - Converting to temperature value\n * \n * @param sensorPin GPIO pin connected to DHT22 data line\n * @param retries Number of retry attempts if read fails (default: 3)\n * @return Temperature in Celsius, or NaN if reading failed\n * \n * @note This function blocks for approximately 100ms during reading\n * @warning Pin must have pull-up resistor (4.7kŒ© recommended)\n * @warning Do not call more than once every 2 seconds\n * \n * @example\n * float temp = readDHT22Temperature(2);\n * if (!isnan(temp)) {\n *   Serial.print(\"Temperature: \");\n *   Serial.println(temp);\n * }\n */\nfloat readDHT22Temperature(uint8_t sensorPin, uint8_t retries = 3);\n\n/**\n * @brief Initializes the SPI bus for sensor communication\n * \n * Configures SPI peripheral with device-specific settings:\n * - Mode: CPOL=1, CPHA=1 (SPI mode 3)\n * - Clock: 1MHz (sensor maximum)\n * - MSB first\n * - Chip select managed manually\n * \n * @param clockSpeed SPI clock frequency in Hz (max 1MHz)\n * @return ErrorCode::OK on success, error code on failure\n * \n * @note Must be called before any SPI operations\n * @note Reinitializes SPI if already initialized\n */\nErrorCode initializeSPI(uint32_t clockSpeed = 1000000);\n```\n\n### Class Documentation\n\n```cpp\n/**\n * @brief Hardware abstraction for I2C temperature sensor\n * \n * Provides a high-level interface for reading temperature from\n * I2C-based sensors (e.g., TMP102, LM75). Handles device initialization,\n * register access, and error recovery automatically.\n * \n * @note Thread-safe for single-threaded embedded systems\n * @note Not thread-safe for multi-threaded environments\n * \n * @example\n * I2CTemperatureSensor sensor(0x48);  // TMP102 at default address\n * if (sensor.begin()) {\n *   float temp = sensor.readCelsius();\n * }\n */\nclass I2CTemperatureSensor {\npublic:\n  /**\n   * @brief Constructs sensor interface\n   * @param address I2C device address (7-bit, right-aligned)\n   */\n  explicit I2CTemperatureSensor(uint8_t address);\n  \n  /**\n   * @brief Initializes sensor and verifies communication\n   * @return true if sensor responds, false otherwise\n   */\n  bool begin();\n  \n  /**\n   * @brief Reads current temperature\n   * @return Temperature in Celsius, or NaN on error\n   * @note Reading takes approximately 30ms\n   */\n  float readCelsius();\n};\n```\n\n### Hardware-Specific Comments\n\n```cpp\n// Pin configuration and hardware assumptions\n// Pin 2: Button (active LOW, internal pull-up enabled)\n// Pin 13: Status LED (active HIGH)\n// Pin A0: Analog sensor input (0-5V range)\n// I2C: SDA=21, SCL=22 (ESP32 default)\n\n// Timing constraints\ndelay(10);  // DHT22 requires 10ms minimum between readings\ndelayMicroseconds(100);  // SPI CS setup time per datasheet\n\n// Hardware register access\n// Direct port manipulation for speed-critical operations\nPORTB |= (1 << PB5);  // Set pin 13 HIGH (faster than digitalWrite)\n\n// Memory layout\n// Buffer layout: [header:4][data:248][checksum:4]\n// Total: 256 bytes, aligned to 32-byte boundary for DMA\n\n// Interrupt timing\n// ISR must complete in < 50us to avoid missing next timer tick\n// Current worst case: ~35us (measured with oscilloscope)\n```\n\n## Inline Comments\n\n### Explaining Intent\n\n```cpp\n// ‚úÖ GOOD - Explains why\ndelay(10);  // Wait for sensor to stabilize after power-on reset\n\n// ‚ùå BAD - States the obvious\ndelay(10);  // Delay for 10 milliseconds\n\n// ‚úÖ GOOD - Documents non-obvious behavior\n// Shift right by 3 instead of divide by 8 for performance\nuint8_t average = (sum >> 3);\n\n// ‚ùå BAD - Redundant\nuint8_t average = (sum >> 3);  // Divide by 8\n\n// ‚úÖ GOOD - Explains hardware workaround\n// Workaround: Sensor v1.0 has timing bug requiring extra delay\ndelayMicroseconds(50);  // Normal timing would be 20us\n\n// ‚úÖ GOOD - Documents optimization\n// Use bit manipulation instead of modulo for power-of-2 sizes\nuint8_t index = (head + 1) & (BUFFER_SIZE - 1);\n```\n\n### Complex Algorithms\n\n```cpp\n/**\n * Calculates CRC-8 checksum using polynomial 0x31\n * \n * Algorithm: Standard CRC-8 with polynomial x^8 + x^5 + x^4 + 1\n * Initial value: 0xFF\n * Final XOR: None\n * \n * @param data Input data buffer\n * @param length Number of bytes to process\n * @return 8-bit CRC value\n */\nuint8_t calculateCRC8(const uint8_t* data, size_t length) {\n  uint8_t crc = 0xFF;  // Initialize with all bits set\n  \n  for (size_t i = 0; i < length; i++) {\n    crc ^= data[i];  // XOR with data byte\n    \n    // Process each bit using polynomial\n    for (uint8_t bit = 0; bit < 8; bit++) {\n      if (crc & 0x80) {\n        // MSB is set, apply polynomial\n        crc = (crc << 1) ^ 0x31;  // Polynomial: 0x31\n      } else {\n        // MSB is clear, just shift\n        crc <<= 1;\n      }\n    }\n  }\n  \n  return crc;\n}\n```\n\n### Performance-Critical Sections\n\n```cpp\n// Critical section: Must complete in < 100us\n// Disable interrupts to prevent race condition with ISR\nnoInterrupts();\n{\n  // Copy shared data atomically\n  memcpy(localBuffer, isrBuffer, sizeof(localBuffer));\n  isrBufferIndex = 0;\n}\ninterrupts();\n\n// Hot path optimization: Unroll loop for known small sizes\n// Measured: 15% faster than generic loop (profiled on AVR)\nif constexpr (SIZE == 4) {\n  buffer[0] = 0;\n  buffer[1] = 0;\n  buffer[2] = 0;\n  buffer[3] = 0;\n} else {\n  // Fallback for other sizes\n  memset(buffer, 0, SIZE);\n}\n```\n\n## TODO and FIXME Comments\n\n### Format\n\n```cpp\n// TODO: Include context and owner\n// TODO(john): Add timeout handling for I2C operations\n// TODO: Implement exponential backoff for retry logic\n// TODO(issue#42): Support multiple sensor types\n\n// FIXME: Document the problem and workaround\n// FIXME: Buffer overflow possible if length > 255\n//         Current workaround: Clamp to 255\n//         Proper fix: Use size_t and check bounds\n\n// HACK: Document why the hack is necessary\n// HACK: Delay needed due to hardware bug in sensor v1.0\n//       Remove when upgrading to v1.1 hardware\n\n// XXX: Critical issue requiring attention\n// XXX: This violates real-time constraints but works for now\n//      Need to refactor to use DMA instead\n\n// NOTE: Important information\n// NOTE: This function modifies global state\n// NOTE: Not safe to call from ISR\n```\n\n### Tracking\n\n```cpp\n// Use consistent format for tracking\n// TODO(2024-01-15): Add sensor calibration\n// FIXME(2024-01-20): Memory leak in error path\n// HACK(2024-01-25): Temporary workaround for ESP32 bug\n\n// Link to issues/tickets\n// TODO: See issue #123 for full requirements\n// FIXME: Related to bug report #456\n```\n\n## Code Sections\n\n### Section Headers\n\n```cpp\n// ============================================================================\n// Public Interface\n// ============================================================================\n\nbool begin();\nfloat read();\n\n// ============================================================================\n// Private Members\n// ============================================================================\n\nuint8_t address_;\nbool initialized_;\n\n// ============================================================================\n// Private Methods\n// ============================================================================\n\nbool verifyConnection();\nfloat readRegister(uint8_t reg);\n```\n\n### Logical Grouping\n\n```cpp\nclass SensorManager {\n  // ========================================================================\n  // Construction and Initialization\n  // ========================================================================\npublic:\n  SensorManager();\n  bool begin();\n  \n  // ========================================================================\n  // Sensor Operations\n  // ========================================================================\npublic:\n  float readTemperature();\n  float readHumidity();\n  \n  // ========================================================================\n  // Configuration\n  // ========================================================================\npublic:\n  void setCalibration(float offset);\n  void setSampleRate(uint32_t rateMs);\n  \n  // ========================================================================\n  // Internal State\n  // ========================================================================\nprivate:\n  float calibrationOffset_;\n  uint32_t sampleInterval_;\n  uint32_t lastSampleTime_;\n};\n```\n\n## Platform-Specific Comments\n\n```cpp\n// Platform-specific implementations\n#ifdef ARDUINO_ARCH_AVR\n  // AVR: Use direct port manipulation for speed\n  PORTB |= (1 << PB5);\n#elif defined(ESP32)\n  // ESP32: Use GPIO functions (port manipulation not recommended)\n  gpio_set_level(GPIO_NUM_13, 1);\n#elif defined(STM32)\n  // STM32: Use HAL functions\n  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET);\n#endif\n\n// Memory constraints\n#ifdef ARDUINO_ARCH_AVR\n  // AVR: Limited RAM, use PROGMEM for strings\n  const char msg[] PROGMEM = \"Hello\";\n#elif defined(ESP32)\n  // ESP32: More RAM available, can use regular strings\n  const char* msg = \"Hello\";\n#endif\n```\n\n## Protocol Documentation\n\n```cpp\n/**\n * @brief Implements custom serial protocol\n * \n * Protocol Format:\n *   [START:1][LENGTH:1][DATA:N][CHECKSUM:1][END:1]\n * \n *   START:    0xAA (sync byte)\n *   LENGTH:   Data length (0-255)\n *   DATA:     Variable length payload\n *   CHECKSUM: XOR of all bytes including START and LENGTH\n *   END:      0x55 (end marker)\n * \n * Example packet:\n *   0xAA 0x03 0x01 0x02 0x03 0xA7 0x55\n *   |    |    |         |    |    |\n *   |    |    |         |    |    +-- END\n *   |    |    |         |    +------- CHECKSUM\n *   |    |    |         +------------ DATA (3 bytes)\n *   |    |    +---------------------- LENGTH\n *   |    +---------------------------- START\n *   +---------------------------------- START\n * \n * Timing:\n *   - Baud rate: 115200\n *   - Inter-byte timeout: 10ms\n *   - Packet timeout: 100ms\n * \n * Error Handling:\n *   - Invalid checksum: Request retransmission\n *   - Timeout: Abort and reset state machine\n */\nclass SerialProtocol {\n  // Implementation...\n};\n```\n\n## Memory and Performance Notes\n\n```cpp\n// Memory usage documentation\n// Stack usage: ~200 bytes (measured with stack painting)\n// Heap usage: 0 bytes (all static allocation)\n// Flash usage: ~2KB (measured with avr-size)\n\n// Performance characteristics\n// Execution time: ~50us average, ~100us worst case\n// CPU usage: < 1% at 1Hz sampling rate\n// Power consumption: +2mA when active\n\n// Optimization notes\n// This function is inlined for performance (hot path)\n// Loop unrolled for known compile-time size\n// Uses bit manipulation instead of division\n```\n\n## Safety and Reliability Comments\n\n```cpp\n// Safety-critical sections\n// CRITICAL: This function controls safety-critical hardware\n// Must never fail - implement watchdog timeout\nvoid controlSafetyShutdown(bool enable) {\n  // Implementation with redundant checks\n}\n\n// Watchdog integration\n// Feed watchdog every 100ms to prevent reset\n// If this loop hangs, watchdog will reset system\nvoid mainLoop() {\n  while (true) {\n    processTasks();\n    feedWatchdog();  // Must be called regularly\n    delay(100);\n  }\n}\n\n// Error recovery\n// If sensor fails 3 times, enter degraded mode\n// Continue operating with last known good value\nif (failureCount >= 3) {\n  enterDegradedMode();\n  useCachedValue();\n}\n```\n\n## What NOT to Comment\n\n```cpp\n// ‚ùå DON'T comment obvious code\nint count = 0;  // Initialize count to zero\ncount++;        // Increment count\n\n// ‚ùå DON'T duplicate type information\nfloat temperature;  // Temperature value in float format\n\n// ‚ùå DON'T comment what the code does\nif (value > 100) {  // Check if value is greater than 100\n  return ERROR;     // Return error\n}\n\n// ‚ùå DON'T leave commented-out code\n// float oldValue = calculateOld();\n// processOldValue(oldValue);\n\n// ‚ùå DON'T use comments for version control\n// Changed by John on 2024-01-15\n// Updated to fix bug #123\n\n// ‚úÖ DO comment why, not what\nif (value > 100) {\n  // Sensor reading exceeds maximum valid range\n  // Return error to prevent invalid data propagation\n  return ERROR;\n}\n```\n\n## Best Practices Summary\n\n1. **Explain Why**: Focus on intent and reasoning, not implementation\n2. **Hardware Documentation**: Document pin connections, timing, and constraints\n3. **Performance Notes**: Comment optimizations and their rationale\n4. **Safety Critical**: Clearly mark safety-critical sections\n5. **Platform Specific**: Document platform differences and workarounds\n6. **Protocols**: Document communication protocols thoroughly\n7. **Memory Usage**: Document memory and performance characteristics\n8. **TODO Format**: Use consistent TODO/FIXME format with context\n9. **Code Sections**: Use section headers for large files\n10. **Avoid Redundancy**: Don't comment what the code already makes clear",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/*.hpp"
          ]
        },
        {
          "id": "conflict-resolution",
          "title": "Conflict Resolution",
          "fileName": "conflict-resolution.mdc",
          "frontmatter": {
            "description": "Guidance for resolving rule conflicts and handling exceptions in embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h"
            ],
            "alwaysApply": true
          },
          "content": "# Conflict Resolution\n\n## Overview\n\nWhen coding guidelines conflict or when exceptions are needed for embedded systems, this document provides guidance on how to resolve conflicts and document exceptions. Hardware constraints often override general programming practices.\n\n## Priority Hierarchy\n\nWhen rules conflict, follow this priority order:\n\n1. **Hardware Constraints** - Hardware limitations take precedence\n2. **Safety & Reliability** - Safety-critical requirements override other rules\n3. **No Hiding Rule** - Never suppress errors or warnings\n4. **Real-Time Constraints** - Timing requirements override code style\n5. **Memory Constraints** - Memory limitations override code organization\n6. **Core Framework & Language** - Framework requirements\n7. **Error Handling Patterns** - Consistent error handling\n8. **Code Style Guidelines** - Formatting and style\n9. **Performance Guidelines** - Optimization considerations\n10. **Commenting Guidelines** - Documentation standards\n\n## Common Conflict Scenarios\n\n### Scenario 1: Memory Constraints vs Code Organization\n\n**Conflict:** Code organization suggests splitting into multiple files, but memory constraints require single file\n\n**Resolution:**\n- Prefer single file if memory is critical\n- Document why code is combined\n- Use clear section comments to organize\n\n**Example:**\n\n```cpp\n// Memory constraint: Must fit in 8KB flash\n// Resolution: Combine related functionality in single file\n\n// ‚úÖ GOOD - Combined with clear organization\n// ============================================================================\n// Sensor Management (combined for memory efficiency)\n// ============================================================================\n\nclass TemperatureSensor { /* ... */ };\nclass HumiditySensor { /* ... */ };\nclass PressureSensor { /* ... */ };\n\n// Document why combined\n// NOTE: Combined into single file to reduce flash usage\n//       Separate files would add ~500 bytes overhead\n```\n\n### Scenario 2: Performance vs Code Style\n\n**Conflict:** Performance requires direct port manipulation, but style prefers abstraction\n\n**Resolution:**\n- Optimize for performance when there's measurable impact\n- Use abstraction with compile-time optimization\n- Document performance requirement\n\n**Example:**\n\n```cpp\n// Performance requirement: Pin toggle must be < 1us\n// Style prefers hardware abstraction\n// Resolution: Use direct port manipulation, document why\n\n// ‚úÖ GOOD - Direct port manipulation with explanation\n// CRITICAL: Direct port manipulation required for < 1us timing\n// Hardware abstraction adds ~2us overhead (measured)\nPORTB ^= (1 << PB5);  // Toggle pin 13 (PB5)\n\n// Alternative: Template-based abstraction that compiles to same code\ntemplate<uint8_t PIN>\nvoid fastToggle() {\n  if constexpr (PIN == 13) {\n    PORTB ^= (1 << PB5);\n  }\n}\n```\n\n### Scenario 3: Real-Time Constraints vs Error Handling\n\n**Conflict:** ISR must complete quickly, but error handling adds overhead\n\n**Resolution:**\n- Minimal error handling in ISR\n- Defer detailed error handling to main loop\n- Set flags for main loop to process\n\n**Example:**\n\n```cpp\n// Real-time constraint: ISR must complete in < 50us\n// Error handling adds overhead\n// Resolution: Minimal ISR, defer to main loop\n\n// ‚úÖ GOOD - Minimal ISR, defer error handling\nvolatile bool dataReady = false;\nvolatile uint8_t errorFlag = 0;\n\nISR(ADC_vect) {\n  if (ADCSRA & (1 << ADIF)) {\n    adcValue = ADC;\n    dataReady = true;\n  } else {\n    errorFlag = 1;  // Set flag, handle in main loop\n  }\n}\n\nvoid loop() {\n  if (errorFlag) {\n    // Detailed error handling in main loop\n    handleADCError();\n    errorFlag = 0;\n  }\n}\n```\n\n### Scenario 4: Platform Compatibility vs Code Style\n\n**Conflict:** Platform-specific code needed, but style prefers consistency\n\n**Resolution:**\n- Use conditional compilation\n- Abstract platform differences\n- Document platform requirements\n\n**Example:**\n\n```cpp\n// Platform compatibility: Different APIs per platform\n// Code style: Prefer consistent interface\n// Resolution: Abstract with conditional compilation\n\n// ‚úÖ GOOD - Platform abstraction\nclass Timer {\npublic:\n  void init(uint32_t frequencyHz) {\n    #ifdef ESP32\n      timer_ = timerBegin(0, 80, true);\n      timerAlarmWrite(timer_, 1000000 / frequencyHz, true);\n    #elif defined(__AVR__)\n      // AVR timer configuration\n      TCCR1B = (1 << WGM12);\n      OCR1A = (F_CPU / frequencyHz) - 1;\n    #endif\n  }\n  \nprivate:\n  #ifdef ESP32\n    hw_timer_t* timer_;\n  #endif\n};\n```\n\n### Scenario 5: Memory vs Feature Completeness\n\n**Conflict:** Full feature set desired, but memory is limited\n\n**Resolution:**\n- Implement core features first\n- Use compile-time feature flags\n- Document memory usage per feature\n\n**Example:**\n\n```cpp\n// Memory constraint: 2KB RAM available\n// Feature: Full logging system desired\n// Resolution: Conditional compilation, minimal default\n\n// ‚úÖ GOOD - Feature flags\n#ifdef ENABLE_LOGGING\n  class FullLogger { /* ... */ };\n  FullLogger logger;\n#else\n  // Minimal logging for production\n  #define LOG(msg) ((void)0)\n#endif\n\n// Document memory impact\n// FullLogger: +512 bytes RAM\n// Minimal: +0 bytes RAM\n```\n\n### Scenario 6: Code Readability vs Performance\n\n**Conflict:** Readable code uses function calls, but performance needs inline\n\n**Resolution:**\n- Use inline functions or templates\n- Compiler will optimize appropriately\n- Profile to verify optimization\n\n**Example:**\n\n```cpp\n// Performance: Hot path needs optimization\n// Readability: Prefer function calls\n// Resolution: Use inline, compiler optimizes\n\n// ‚úÖ GOOD - Inline function\ninline uint8_t fastReadPin(uint8_t pin) {\n  return (PINB >> pin) & 1;\n}\n\n// Compiler will inline, maintains readability\nvoid processInputs() {\n  if (fastReadPin(2)) {\n    // Handle input\n  }\n}\n```\n\n## Exception Documentation\n\n### When to Document Exceptions\n\nDocument exceptions when:\n- Hardware constraints require deviation\n- Performance requirements override style\n- Platform limitations necessitate workarounds\n- Safety requirements override other rules\n\n### Exception Format\n\n```cpp\n// EXCEPTION: [Rule violated] - [Reason]\n// Hardware constraint: [Specific constraint]\n// Impact: [What this affects]\n// TODO: [Future improvement if applicable]\n\n// Example:\n// EXCEPTION: Code Style - Direct port manipulation\n// Hardware constraint: Pin toggle must be < 1us\n// Impact: Platform-specific code, less portable\n// TODO: Consider template-based abstraction if timing allows\nPORTB ^= (1 << PB5);\n```\n\n## Decision Process\n\n### Step 1: Identify Conflict\n\n- What rules are conflicting?\n- What are the constraints?\n- What are the requirements?\n\n### Step 2: Evaluate Priorities\n\n- Check priority hierarchy\n- Determine which constraint is more critical\n- Consider hardware limitations\n\n### Step 3: Find Solution\n\n- Look for compromise solution\n- Consider alternative approaches\n- Evaluate trade-offs\n\n### Step 4: Document Decision\n\n- Document why exception is needed\n- Explain the trade-off\n- Note any future improvements\n\n### Step 5: Review\n\n- Get code review approval\n- Verify solution works\n- Ensure exception is justified\n\n## Common Trade-offs\n\n### Memory vs Features\n\n- **Choose Memory**: When memory is critically limited\n- **Choose Features**: When memory is available\n- **Compromise**: Conditional compilation\n\n### Performance vs Readability\n\n- **Choose Performance**: In hot paths, ISRs\n- **Choose Readability**: In non-critical paths\n- **Compromise**: Inline functions, templates\n\n### Portability vs Optimization\n\n- **Choose Portability**: For multi-platform code\n- **Choose Optimization**: For platform-specific code\n- **Compromise**: Platform abstraction layer\n\n### Safety vs Performance\n\n- **Choose Safety**: Always in safety-critical systems\n- **Choose Performance**: Only when safety not affected\n- **Compromise**: Verify safety, optimize carefully\n\n## Best Practices Summary\n\n1. **Hardware First**: Hardware constraints override other rules\n2. **Safety Critical**: Safety requirements take highest priority\n3. **Document Exceptions**: Always document why exception is needed\n4. **Justify Trade-offs**: Explain the decision process\n5. **Review Required**: Get approval for exceptions\n6. **Future Improvements**: Note potential improvements\n7. **Measure Impact**: Verify exception is necessary\n8. **Consider Alternatives**: Explore other solutions first\n9. **Minimize Exceptions**: Keep exceptions to minimum\n10. **Update Guidelines**: Consider updating guidelines if exception is common",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h"
          ]
        },
        {
          "id": "core-framework-language",
          "title": "Core Framework & Language",
          "fileName": "core-framework-&-language.mdc",
          "frontmatter": {
            "description": "Core framework, language, and platform specifications for Arduino/microcontroller projects using PlatformIO",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/*.hpp",
              "**/*.ino",
              "**/platformio.ini",
              "**/src/**",
              "**/lib/**"
            ],
            "alwaysApply": true
          },
          "content": "# Core Framework & Language\n\n## Overview\n\nThis document defines the foundational technology stack and development environment for Arduino and microcontroller projects. All code must align with these specifications to ensure reliability, portability, and maintainability in embedded systems.\n\n## Framework\n\n- **Framework:** [Arduino Framework](https://www.arduino.cc/reference/en/)\n  - Provides a simplified C++ API for microcontroller programming\n  - Abstracts hardware-specific details while allowing low-level access\n  - Compatible with thousands of libraries and hardware platforms\n  - Supports both 8-bit (AVR) and 32-bit (ARM, ESP32) architectures\n\n## Language\n\n- **Language:** C++ (Arduino variant)\n  - Based on C++11/14 with some restrictions for embedded use\n  - No exceptions (disabled for memory efficiency)\n  - No RTTI (Run-Time Type Information)\n  - Limited STL support (platform-dependent)\n  - Static memory allocation preferred over dynamic\n\n## Build System\n\n- **Build System:** [PlatformIO Core](https://platformio.org/)\n  - Modern, professional IDE with powerful debugging\n  - Multi-platform/multi-board support in single project\n  - Dependency management with semantic versioning\n  - Unit testing framework built-in\n  - Continuous Integration friendly\n\n## Supported Platforms\n\n### Primary Platforms\n- **AVR:** Arduino Uno, Mega, Nano (ATmega328P, ATmega2560)\n- **ESP32:** Espressif ESP32, ESP32-S2, ESP32-S3, ESP32-C3\n- **ESP8266:** NodeMCU, Wemos D1, Generic ESP8266\n- **STM32:** STM32F103 (Blue Pill), STM32F4, STM32H7 series\n- **RP2040:** Raspberry Pi Pico, Arduino Nano RP2040 Connect\n\n### Platform-Specific Considerations\n\n```cpp\n// Platform detection macros\n#ifdef ARDUINO_ARCH_AVR\n  // AVR-specific code (Arduino Uno, Mega, etc.)\n  #define CPU_FREQ F_CPU\n  #define HAS_EEPROM 1\n#elif defined(ESP32)\n  // ESP32-specific code\n  #define CPU_FREQ CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ * 1000000\n  #define HAS_WIFI 1\n  #define HAS_BLUETOOTH 1\n#elif defined(ESP8266)\n  // ESP8266-specific code\n  #define CPU_FREQ F_CPU\n  #define HAS_WIFI 1\n#elif defined(STM32)\n  // STM32-specific code\n  #define CPU_FREQ SystemCoreClock\n  #define HAS_DMA 1\n#elif defined(ARDUINO_ARCH_RP2040)\n  // RP2040-specific code\n  #define CPU_FREQ 125000000\n  #define HAS_PIO 1\n#endif\n```\n\n## Project Structure\n\nStandard PlatformIO project structure:\n\n```\nproject-root/\n‚îú‚îÄ‚îÄ platformio.ini          # Project configuration\n‚îú‚îÄ‚îÄ src/                    # Source files\n‚îÇ   ‚îú‚îÄ‚îÄ main.cpp           # Entry point\n‚îÇ   ‚îú‚îÄ‚îÄ config.h           # Configuration header\n‚îÇ   ‚îî‚îÄ‚îÄ modules/           # Feature modules\n‚îÇ       ‚îú‚îÄ‚îÄ sensors/\n‚îÇ       ‚îú‚îÄ‚îÄ actuators/\n‚îÇ       ‚îî‚îÄ‚îÄ communication/\n‚îú‚îÄ‚îÄ lib/                    # Private libraries\n‚îÇ   ‚îî‚îÄ‚îÄ MyCustomLib/\n‚îÇ       ‚îú‚îÄ‚îÄ library.json   # Library manifest\n‚îÇ       ‚îú‚îÄ‚îÄ src/\n‚îÇ       ‚îî‚îÄ‚îÄ include/\n‚îú‚îÄ‚îÄ include/               # Public headers\n‚îÇ   ‚îî‚îÄ‚îÄ project_config.h\n‚îú‚îÄ‚îÄ test/                  # Unit tests\n‚îÇ   ‚îú‚îÄ‚îÄ test_native/      # Native (desktop) tests\n‚îÇ   ‚îî‚îÄ‚îÄ test_embedded/    # On-device tests\n‚îú‚îÄ‚îÄ data/                  # SPIFFS/LittleFS data\n‚îî‚îÄ‚îÄ docs/                  # Documentation\n```\n\n## Core Language Features\n\n### Memory Model\n\n```cpp\n// Memory sections in embedded systems\n// .text    - Program code (Flash/ROM)\n// .data    - Initialized variables (RAM)\n// .bss     - Uninitialized variables (RAM)\n// .rodata  - Read-only data (Flash/ROM)\n\n// Store constants in program memory (Flash)\nconst char message[] PROGMEM = \"Hello from Flash memory\";\n\n// F() macro for string literals (AVR-specific)\nSerial.println(F(\"This string stays in Flash\"));\n\n// Static allocation preferred\nconstexpr size_t BUFFER_SIZE = 256;\nuint8_t buffer[BUFFER_SIZE];  // Stack allocation\n\n// Avoid dynamic allocation\n// ‚ùå BAD\nString dynamicString = \"This uses heap\";\nstd::vector<int> dynamicVector;\n\n// ‚úÖ GOOD\nchar staticString[32] = \"This uses stack\";\nint staticArray[10];\n```\n\n### Type System\n\n```cpp\n// Use fixed-width integers for portability\n#include <stdint.h>\n\nuint8_t  byteValue;    // 0 to 255\nint8_t   signedByte;   // -128 to 127\nuint16_t wordValue;    // 0 to 65535\nint16_t  signedWord;   // -32768 to 32767\nuint32_t dwordValue;   // 0 to 4294967295\nint32_t  signedDword;  // -2147483648 to 2147483647\n\n// Boolean type\nbool flagValue;  // true or false\n\n// Floating point (use sparingly on 8-bit MCUs)\nfloat temperature;    // 32-bit, ~7 decimal digits\ndouble precision;     // Often same as float on embedded\n\n// Pointer types\nuint8_t* dataPtr;\nconst uint8_t* constDataPtr;\nvolatile uint8_t* volatilePtr;  // For hardware registers\n\n// Function pointers\ntypedef void (*EventHandler)(void);\nEventHandler onButtonPress;\n```\n\n### Compile-Time Features\n\n```cpp\n// Use constexpr for compile-time constants\nconstexpr uint8_t LED_PIN = 13;\nconstexpr uint32_t BAUD_RATE = 115200;\nconstexpr float PI = 3.14159265359f;\n\n// Template metaprogramming for zero-cost abstractions\ntemplate<uint8_t PIN>\nclass DigitalOutput {\n    static_assert(PIN < NUM_DIGITAL_PINS, \"Invalid pin number\");\npublic:\n    static void init() {\n        pinMode(PIN, OUTPUT);\n    }\n    \n    static void set(bool value) {\n        digitalWrite(PIN, value);\n    }\n};\n\n// Using alias templates\nusing StatusLED = DigitalOutput<LED_BUILTIN>;\n\n// Compile-time calculations\nconstexpr uint32_t calculateBaudDivider(uint32_t baud) {\n    return (F_CPU / 16 / baud) - 1;\n}\n```\n\n## Platform Configuration\n\n### PlatformIO.ini Example\n\n```ini\n; PlatformIO Project Configuration File\n[platformio]\ndefault_envs = esp32dev, arduino_uno, stm32\n\n; Shared settings for all environments\n[env]\nframework = arduino\nmonitor_speed = 115200\nlib_deps = \n    ; Common libraries with version constraints\n    adafruit/Adafruit Unified Sensor@^1.1.6\n    paulstoffregen/OneWire@^2.3.7\nbuild_flags = \n    -Wall                    ; All warnings\n    -Wextra                  ; Extra warnings\n    -D VERSION=1.0.0         ; Version definition\n    -D DEBUG_LEVEL=2         ; Debug verbosity\n\n; ESP32 Development Board\n[env:esp32dev]\nplatform = espressif32\nboard = esp32dev\nbuild_flags = \n    ${env.build_flags}\n    -D ESP32\n    -D CORE_DEBUG_LEVEL=2\n    -mtext-section-literals  ; Optimization\nlib_deps = \n    ${env.lib_deps}\n    bblanchon/ArduinoJson@^6.19.4\n    knolleary/PubSubClient@^2.8\n\n; Arduino Uno (AVR)\n[env:arduino_uno]\nplatform = atmelavr\nboard = uno\nbuild_flags = \n    ${env.build_flags}\n    -D AVR\n    -Os                      ; Optimize for size\n    -flto                    ; Link-time optimization\nbuild_unflags = \n    -std=gnu++11            ; Remove C++11 for size\n\n; STM32 Blue Pill\n[env:stm32]\nplatform = ststm32\nboard = bluepill_f103c8\nbuild_flags = \n    ${env.build_flags}\n    -D STM32\n    -D ENABLE_HWSERIAL2\nupload_protocol = stlink\ndebug_tool = stlink\n```\n\n## Compiler Settings\n\n### Optimization Flags\n\n```cpp\n// Optimization pragmas for critical sections\n#pragma GCC push_options\n#pragma GCC optimize (\"O3\")\nvoid timeCriticalFunction() {\n    // Optimized for speed\n}\n#pragma GCC pop_options\n\n// Function attributes\nvoid __attribute__((always_inline)) inlineHelper() {\n    // Force inline\n}\n\nvoid __attribute__((noinline)) debugFunction() {\n    // Prevent inlining for debugging\n}\n\nvoid __attribute__((weak)) defaultImplementation() {\n    // Can be overridden\n}\n\n// Section placement\nvoid __attribute__((section(\".fastcode\"))) fastISR() {\n    // Place in RAM for faster execution\n}\n```\n\n## Arduino API Compatibility\n\n### Core Functions\n\n```cpp\n// Required Arduino functions\nvoid setup() {\n    // One-time initialization\n    // Called once at startup\n}\n\nvoid loop() {\n    // Main program loop\n    // Called repeatedly\n    // Should not block for long periods\n}\n\n// Optional main() override (advanced)\nint main() {\n    init();        // Arduino core initialization\n    setup();       // User setup\n    \n    for (;;) {\n        loop();    // User loop\n        if (serialEventRun) serialEventRun();\n    }\n    return 0;\n}\n```\n\n### Time Functions\n\n```cpp\n// Millisecond timer (overflows after ~49 days)\nunsigned long currentMillis = millis();\n\n// Microsecond timer (overflows after ~70 minutes)\nunsigned long currentMicros = micros();\n\n// Delays (blocking - use sparingly)\ndelay(1000);        // Delay 1 second\ndelayMicroseconds(100);  // Delay 100 microseconds\n\n// Non-blocking timing pattern\nunsigned long previousMillis = 0;\nconst unsigned long interval = 1000;\n\nif (millis() - previousMillis >= interval) {\n    previousMillis = millis();\n    // Do something every second\n}\n```\n\n## Development Environment\n\n### Required Tools\n\n1. **PlatformIO Core CLI** or **PlatformIO IDE**:\n   ```bash\n   # Install PlatformIO Core\n   pip install platformio\n   \n   # Or install VS Code extension\n   code --install-extension platformio.platformio-ide\n   ```\n\n2. **Version Control Integration**:\n   ```bash\n   # Initialize project\n   pio init --board esp32dev --board uno\n   \n   # Add to git\n   git init\n   git add .\n   git commit -m \"Initial PlatformIO project\"\n   ```\n\n3. **Debugging Tools**:\n   - Serial Monitor\n   - Logic Analyzer (Saleae, Sigrok)\n   - Oscilloscope for timing analysis\n   - JTAG/SWD debugger (platform-specific)\n\n### Build Commands\n\n```bash\n# Build project\npio run\n\n# Build specific environment\npio run -e esp32dev\n\n# Upload to board\npio run -t upload\n\n# Monitor serial output\npio device monitor\n\n# Run tests\npio test\n\n# Clean build files\npio run -t clean\n\n# Update libraries\npio lib update\n\n# Static code analysis\npio check\n```\n\n## Best Practices Summary\n\n1. **Memory Management**: Prefer static allocation, use PROGMEM for constants\n2. **Platform Abstraction**: Use conditional compilation for platform differences\n3. **Type Safety**: Use fixed-width types, avoid implicit conversions\n4. **Compile-Time**: Leverage constexpr and templates for zero-cost abstractions\n5. **Arduino Compatibility**: Maintain Arduino API while adding advanced features\n6. **Build Configuration**: Use PlatformIO environments for multi-platform support\n7. **Testing**: Write unit tests for business logic, integration tests for hardware\n8. **Documentation**: Document hardware assumptions and platform-specific code",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/*.hpp",
            "**/*.ino",
            "**/platformio.ini",
            "**/src/**",
            "**/lib/**"
          ]
        },
        {
          "id": "error-handling-patterns",
          "title": "Error Handling Patterns",
          "fileName": "error-handling-patterns.mdc",
          "frontmatter": {
            "description": "Error handling patterns and recovery strategies for embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/src/**"
            ],
            "alwaysApply": true
          },
          "content": "# Error Handling Patterns\n\n## Overview\n\nError handling in embedded systems differs significantly from desktop applications. Without exceptions, limited memory, and real-time constraints, embedded systems require robust error handling strategies that ensure system stability and predictable behavior.\n\n## Error Representation\n\n### Error Codes\n\n```cpp\n// Comprehensive error code system\nenum class ErrorCode : int8_t {\n    // Success\n    OK = 0,\n    \n    // Generic errors (-1 to -19)\n    ERROR = -1,\n    INVALID_ARGUMENT = -2,\n    OUT_OF_MEMORY = -3,\n    BUFFER_FULL = -4,\n    BUFFER_EMPTY = -5,\n    TIMEOUT = -6,\n    NOT_INITIALIZED = -7,\n    ALREADY_INITIALIZED = -8,\n    NOT_SUPPORTED = -9,\n    PERMISSION_DENIED = -10,\n    \n    // Hardware errors (-20 to -39)\n    HARDWARE_ERROR = -20,\n    I2C_ERROR = -21,\n    SPI_ERROR = -22,\n    UART_ERROR = -23,\n    GPIO_ERROR = -24,\n    ADC_ERROR = -25,\n    PWM_ERROR = -26,\n    \n    // Communication errors (-40 to -59)\n    COMM_ERROR = -40,\n    CHECKSUM_ERROR = -41,\n    PROTOCOL_ERROR = -42,\n    PACKET_TOO_LARGE = -43,\n    NO_RESPONSE = -44,\n    \n    // Sensor errors (-60 to -79)\n    SENSOR_ERROR = -60,\n    SENSOR_NOT_FOUND = -61,\n    SENSOR_CALIBRATION = -62,\n    SENSOR_RANGE = -63,\n    \n    // File system errors (-80 to -99)\n    FS_ERROR = -80,\n    FILE_NOT_FOUND = -81,\n    FILE_EXISTS = -82,\n    FS_FULL = -83,\n    \n    // Application specific (-100 to -127)\n    APP_ERROR = -100\n};\n\n// Convert error code to string (stored in PROGMEM)\nconst char* getErrorString(ErrorCode error) {\n    switch (error) {\n        case ErrorCode::OK: return F(\"OK\");\n        case ErrorCode::INVALID_ARGUMENT: return F(\"Invalid argument\");\n        case ErrorCode::OUT_OF_MEMORY: return F(\"Out of memory\");\n        case ErrorCode::TIMEOUT: return F(\"Timeout\");\n        case ErrorCode::HARDWARE_ERROR: return F(\"Hardware error\");\n        case ErrorCode::I2C_ERROR: return F(\"I2C error\");\n        case ErrorCode::CHECKSUM_ERROR: return F(\"Checksum error\");\n        // ... etc\n        default: return F(\"Unknown error\");\n    }\n}\n```\n\n### Result Type Pattern\n\n```cpp\n// Result type for error handling without exceptions\ntemplate<typename T, typename E = ErrorCode>\nclass Result {\nprivate:\n    union {\n        T value;\n        E error;\n    };\n    bool hasValue;\n    \npublic:\n    // Success constructor\n    Result(const T& val) : value(val), hasValue(true) {}\n    Result(T&& val) : value(std::move(val)), hasValue(true) {}\n    \n    // Error constructor\n    Result(E err) : error(err), hasValue(false) {}\n    \n    // Check if successful\n    bool isOk() const { return hasValue; }\n    bool isError() const { return !hasValue; }\n    explicit operator bool() const { return hasValue; }\n    \n    // Get value (unsafe - check isOk() first)\n    T& getValue() { return value; }\n    const T& getValue() const { return value; }\n    \n    // Get error (unsafe - check isError() first)\n    E getError() const { return error; }\n    \n    // Safe access with default\n    T getValueOr(const T& defaultValue) const {\n        return hasValue ? value : defaultValue;\n    }\n    \n    // Monadic operations\n    template<typename F>\n    auto map(F func) -> Result<decltype(func(value)), E> {\n        if (hasValue) {\n            return Result<decltype(func(value)), E>(func(value));\n        }\n        return Result<decltype(func(value)), E>(error);\n    }\n    \n    template<typename F>\n    auto andThen(F func) -> decltype(func(value)) {\n        if (hasValue) {\n            return func(value);\n        }\n        return decltype(func(value))(error);\n    }\n    \n    // Destructor\n    ~Result() {\n        if (hasValue) {\n            value.~T();\n        }\n    }\n};\n\n// Specialization for void\ntemplate<typename E>\nclass Result<void, E> {\nprivate:\n    E error;\n    bool success;\n    \npublic:\n    Result() : success(true) {}\n    Result(E err) : error(err), success(false) {}\n    \n    bool isOk() const { return success; }\n    bool isError() const { return !success; }\n    E getError() const { return error; }\n};\n\n// Helper function for creating results\ntemplate<typename T>\nResult<T> Ok(T&& value) {\n    return Result<T>(std::forward<T>(value));\n}\n\ntemplate<typename T, typename E>\nResult<T, E> Err(E error) {\n    return Result<T, E>(error);\n}\n\n// Usage example\nResult<int> readSensor() {\n    int value = analogRead(A0);\n    if (value < 0 || value > 1023) {\n        return Err<int>(ErrorCode::SENSOR_RANGE);\n    }\n    return Ok(value);\n}\n\nvoid processSensorData() {\n    auto result = readSensor();\n    if (result.isOk()) {\n        int value = result.getValue();\n        // Process value\n    } else {\n        handleError(result.getError());\n    }\n}\n```\n\n## Error Propagation\n\n### Early Return Pattern\n\n```cpp\n// Macro for early return on error\n#define RETURN_IF_ERROR(expr) \\\n    do { \\\n        auto _result = (expr); \\\n        if (_result != ErrorCode::OK) { \\\n            return _result; \\\n        } \\\n    } while(0)\n\n#define RETURN_ON_ERROR(expr) \\\n    do { \\\n        auto _result = (expr); \\\n        if (!_result.isOk()) { \\\n            return _result; \\\n        } \\\n    } while(0)\n\n// Usage\nErrorCode initializeSystem() {\n    RETURN_IF_ERROR(initHardware());\n    RETURN_IF_ERROR(initSensors());\n    RETURN_IF_ERROR(initCommunication());\n    RETURN_IF_ERROR(loadConfiguration());\n    \n    return ErrorCode::OK;\n}\n\nResult<float> calculateAverage(uint8_t pin, uint8_t samples) {\n    if (samples == 0) {\n        return Err<float>(ErrorCode::INVALID_ARGUMENT);\n    }\n    \n    uint32_t sum = 0;\n    for (uint8_t i = 0; i < samples; i++) {\n        auto reading = readAnalogSafe(pin);\n        RETURN_ON_ERROR(reading);\n        sum += reading.getValue();\n    }\n    \n    return Ok(static_cast<float>(sum) / samples);\n}\n```\n\n### Error Context\n\n```cpp\n// Error with context information\nstruct ErrorContext {\n    ErrorCode code;\n    const char* file;\n    uint16_t line;\n    const char* function;\n    uint32_t timestamp;\n    \n    void print() const {\n        Serial.print(F(\"Error \"));\n        Serial.print(static_cast<int>(code));\n        Serial.print(F(\" at \"));\n        Serial.print(file);\n        Serial.print(F(\":\"));\n        Serial.print(line);\n        Serial.print(F(\" in \"));\n        Serial.print(function);\n        Serial.print(F(\" @ \"));\n        Serial.println(timestamp);\n    }\n};\n\n// Macro to capture context\n#define ERROR_CONTEXT(code) \\\n    ErrorContext{code, __FILE__, __LINE__, __func__, millis()}\n\n// Enhanced result type with context\ntemplate<typename T>\nclass ResultWithContext {\nprivate:\n    union {\n        T value;\n        ErrorContext error;\n    };\n    bool hasValue;\n    \npublic:\n    ResultWithContext(const T& val) : value(val), hasValue(true) {}\n    ResultWithContext(const ErrorContext& err) : error(err), hasValue(false) {}\n    \n    bool isOk() const { return hasValue; }\n    const T& getValue() const { return value; }\n    const ErrorContext& getError() const { return error; }\n};\n```\n\n## Error Recovery Strategies\n\n### Retry Mechanism\n\n```cpp\n// Configurable retry policy\nstruct RetryPolicy {\n    uint8_t maxAttempts;\n    uint32_t initialDelay;\n    float backoffMultiplier;\n    uint32_t maxDelay;\n    \n    static constexpr RetryPolicy exponentialBackoff() {\n        return {3, 100, 2.0f, 5000};\n    }\n    \n    static constexpr RetryPolicy fixed() {\n        return {3, 1000, 1.0f, 1000};\n    }\n    \n    static constexpr RetryPolicy noRetry() {\n        return {1, 0, 1.0f, 0};\n    }\n};\n\n// Retry wrapper\ntemplate<typename F>\nauto retryOperation(F operation, const RetryPolicy& policy) \n    -> decltype(operation()) {\n    \n    uint32_t delay = policy.initialDelay;\n    \n    for (uint8_t attempt = 0; attempt < policy.maxAttempts; attempt++) {\n        auto result = operation();\n        \n        if (result.isOk()) {\n            return result;\n        }\n        \n        // Last attempt, don't delay\n        if (attempt == policy.maxAttempts - 1) {\n            return result;\n        }\n        \n        // Apply backoff\n        delay = min(static_cast<uint32_t>(delay * policy.backoffMultiplier), \n                    policy.maxDelay);\n        delay(delay);\n    }\n    \n    return operation();  // Final attempt\n}\n\n// Usage\nResult<uint8_t> readI2CRegister(uint8_t address, uint8_t reg) {\n    return retryOperation([=]() {\n        Wire.beginTransmission(address);\n        Wire.write(reg);\n        if (Wire.endTransmission() != 0) {\n            return Err<uint8_t>(ErrorCode::I2C_ERROR);\n        }\n        \n        Wire.requestFrom(address, 1);\n        if (Wire.available()) {\n            return Ok(static_cast<uint8_t>(Wire.read()));\n        }\n        \n        return Err<uint8_t>(ErrorCode::NO_RESPONSE);\n    }, RetryPolicy::exponentialBackoff());\n}\n```\n\n### Circuit Breaker Pattern\n\n```cpp\n// Circuit breaker for protecting against repeated failures\ntemplate<typename T>\nclass CircuitBreaker {\nprivate:\n    enum State { CLOSED, OPEN, HALF_OPEN };\n    \n    State state = CLOSED;\n    uint8_t failureCount = 0;\n    uint8_t successCount = 0;\n    uint32_t lastFailureTime = 0;\n    \n    const uint8_t failureThreshold;\n    const uint32_t timeout;\n    const uint8_t successThreshold;\n    \npublic:\n    CircuitBreaker(uint8_t failures = 5, uint32_t timeoutMs = 30000, \n                   uint8_t successes = 2)\n        : failureThreshold(failures), timeout(timeoutMs), \n          successThreshold(successes) {}\n    \n    template<typename F>\n    Result<T> call(F operation) {\n        if (state == OPEN) {\n            if (millis() - lastFailureTime >= timeout) {\n                state = HALF_OPEN;\n                successCount = 0;\n            } else {\n                return Err<T>(ErrorCode::SERVICE_UNAVAILABLE);\n            }\n        }\n        \n        auto result = operation();\n        \n        if (result.isOk()) {\n            onSuccess();\n        } else {\n            onFailure();\n        }\n        \n        return result;\n    }\n    \nprivate:\n    void onSuccess() {\n        failureCount = 0;\n        \n        if (state == HALF_OPEN) {\n            successCount++;\n            if (successCount >= successThreshold) {\n                state = CLOSED;\n            }\n        }\n    }\n    \n    void onFailure() {\n        lastFailureTime = millis();\n        \n        if (state == HALF_OPEN) {\n            state = OPEN;\n            return;\n        }\n        \n        failureCount++;\n        if (failureCount >= failureThreshold) {\n            state = OPEN;\n        }\n    }\n    \n    const char* getStateName() const {\n        switch (state) {\n            case CLOSED: return \"CLOSED\";\n            case OPEN: return \"OPEN\";\n            case HALF_OPEN: return \"HALF_OPEN\";\n            default: return \"UNKNOWN\";\n        }\n    }\n};\n```\n\n### Fallback Strategies\n\n```cpp\n// Sensor with fallback\nclass RedundantSensor {\nprivate:\n    struct SensorInterface {\n        virtual Result<float> read() = 0;\n        virtual const char* getName() = 0;\n    };\n    \n    SensorInterface* primary;\n    SensorInterface* secondary;\n    float lastGoodValue = 0;\n    uint32_t lastGoodTime = 0;\n    \npublic:\n    RedundantSensor(SensorInterface* p, SensorInterface* s) \n        : primary(p), secondary(s) {}\n    \n    Result<float> read() {\n        // Try primary sensor\n        auto result = primary->read();\n        if (result.isOk()) {\n            lastGoodValue = result.getValue();\n            lastGoodTime = millis();\n            return result;\n        }\n        \n        // Log primary failure\n        Serial.print(F(\"Primary sensor failed: \"));\n        Serial.println(primary->getName());\n        \n        // Try secondary sensor\n        if (secondary) {\n            result = secondary->read();\n            if (result.isOk()) {\n                return result;\n            }\n        }\n        \n        // Both failed - use last known good value if recent\n        if (millis() - lastGoodTime < 5000) {\n            Serial.println(F(\"Using cached value\"));\n            return Ok(lastGoodValue);\n        }\n        \n        // Complete failure\n        return Err<float>(ErrorCode::SENSOR_ERROR);\n    }\n};\n\n// Graceful degradation\nclass SystemController {\nprivate:\n    enum Mode { NORMAL, DEGRADED, EMERGENCY, SHUTDOWN };\n    Mode currentMode = NORMAL;\n    \npublic:\n    void updateMode(const SystemStatus& status) {\n        if (status.criticalErrors > 0) {\n            enterMode(SHUTDOWN);\n        } else if (status.errors > 5) {\n            enterMode(EMERGENCY);\n        } else if (status.errors > 0) {\n            enterMode(DEGRADED);\n        } else {\n            enterMode(NORMAL);\n        }\n    }\n    \nprivate:\n    void enterMode(Mode newMode) {\n        if (newMode == currentMode) return;\n        \n        Serial.print(F(\"Mode change: \"));\n        Serial.print(getModeString(currentMode));\n        Serial.print(F(\" -> \"));\n        Serial.println(getModeString(newMode));\n        \n        currentMode = newMode;\n        \n        switch (currentMode) {\n            case NORMAL:\n                // Full functionality\n                enableAllFeatures();\n                break;\n                \n            case DEGRADED:\n                // Reduced functionality\n                disableNonEssentialFeatures();\n                reduceSampleRate();\n                break;\n                \n            case EMERGENCY:\n                // Minimum functionality\n                disableAllButCritical();\n                enableEmergencyBeacon();\n                break;\n                \n            case SHUTDOWN:\n                // Safe shutdown\n                saveState();\n                enterSafeMode();\n                break;\n        }\n    }\n    \n    const char* getModeString(Mode mode) {\n        switch (mode) {\n            case NORMAL: return F(\"NORMAL\");\n            case DEGRADED: return F(\"DEGRADED\");\n            case EMERGENCY: return F(\"EMERGENCY\");\n            case SHUTDOWN: return F(\"SHUTDOWN\");\n            default: return F(\"UNKNOWN\");\n        }\n    }\n};\n```\n\n## Error Logging\n\n### Minimal Error Logger\n\n```cpp\n// Circular buffer for error logging\ntemplate<size_t LOG_SIZE>\nclass ErrorLogger {\nprivate:\n    struct LogEntry {\n        ErrorCode code;\n        uint32_t timestamp;\n        uint16_t location;  // Packed file:line\n        uint8_t data[4];    // Additional context\n    };\n    \n    LogEntry log[LOG_SIZE];\n    uint8_t writeIndex = 0;\n    bool wrapped = false;\n    \npublic:\n    void logError(ErrorCode code, uint16_t location = 0, \n                  const uint8_t* data = nullptr) {\n        log[writeIndex] = {\n            code,\n            millis(),\n            location,\n            {0, 0, 0, 0}\n        };\n        \n        if (data) {\n            memcpy(log[writeIndex].data, data, 4);\n        }\n        \n        if (++writeIndex >= LOG_SIZE) {\n            writeIndex = 0;\n            wrapped = true;\n        }\n    }\n    \n    void dump() {\n        Serial.println(F(\"\\n=== Error Log ===\"));\n        Serial.println(F(\"Time(ms) | Error | Location | Data\"));\n        Serial.println(F(\"---------|-------|----------|-----\"));\n        \n        uint8_t start = wrapped ? writeIndex : 0;\n        uint8_t count = wrapped ? LOG_SIZE : writeIndex;\n        \n        for (uint8_t i = 0; i < count; i++) {\n            uint8_t idx = (start + i) % LOG_SIZE;\n            const auto& entry = log[idx];\n            \n            Serial.print(entry.timestamp);\n            Serial.print(F(\" | \"));\n            Serial.print(static_cast<int>(entry.code));\n            Serial.print(F(\" | \"));\n            Serial.print(entry.location);\n            Serial.print(F(\" | \"));\n            \n            for (uint8_t j = 0; j < 4; j++) {\n                if (entry.data[j] < 0x10) Serial.print('0');\n                Serial.print(entry.data[j], HEX);\n                Serial.print(' ');\n            }\n            Serial.println();\n        }\n    }\n    \n    void clear() {\n        writeIndex = 0;\n        wrapped = false;\n    }\n    \n    // Store in EEPROM for post-mortem analysis\n    void saveToEEPROM(uint16_t address) {\n        #ifdef __AVR__\n        EEPROM.put(address, *this);\n        #endif\n    }\n    \n    void loadFromEEPROM(uint16_t address) {\n        #ifdef __AVR__\n        EEPROM.get(address, *this);\n        #endif\n    }\n};\n\n// Global error logger\nErrorLogger<32> errorLog;\n\n// Convenience macro\n#define LOG_ERROR(code) errorLog.logError(code, (__LINE__ << 8) | (__COUNTER__ & 0xFF))\n```\n\n## Watchdog Integration\n\n```cpp\n// Error handler with watchdog\nclass SafeErrorHandler {\nprivate:\n    static constexpr uint32_t ERROR_TIMEOUT = 10000;  // 10 seconds\n    static uint32_t lastErrorTime;\n    static uint8_t errorCount;\n    \npublic:\n    static void handleError(ErrorCode error) {\n        errorCount++;\n        uint32_t now = millis();\n        \n        // Log error\n        errorLog.logError(error);\n        \n        // Check for error storm\n        if (now - lastErrorTime < 1000) {\n            if (errorCount > 10) {\n                // Too many errors too quickly\n                emergencyReset();\n            }\n        } else {\n            errorCount = 1;\n        }\n        \n        lastErrorTime = now;\n        \n        // Handle specific errors\n        switch (error) {\n            case ErrorCode::OUT_OF_MEMORY:\n                freeMemory();\n                break;\n                \n            case ErrorCode::HARDWARE_ERROR:\n                resetHardware();\n                break;\n                \n            case ErrorCode::WATCHDOG_TIMEOUT:\n                // System hung - will reset automatically\n                break;\n                \n            default:\n                // Generic error handling\n                if (isCriticalError(error)) {\n                    enterSafeMode();\n                }\n        }\n        \n        // Feed watchdog to prevent reset during recovery\n        #ifdef __AVR__\n        wdt_reset();\n        #endif\n    }\n    \nprivate:\n    static void emergencyReset() {\n        // Save critical state\n        saveErrorLog();\n        \n        // Trigger watchdog reset\n        #ifdef __AVR__\n        wdt_enable(WDTO_15MS);\n        while (true);  // Wait for reset\n        #elif defined(ESP32)\n        ESP.restart();\n        #endif\n    }\n    \n    static bool isCriticalError(ErrorCode error) {\n        return error <= ErrorCode::HARDWARE_ERROR && \n               error >= ErrorCode::SENSOR_ERROR;\n    }\n    \n    static void freeMemory() {\n        // Attempt to free memory\n        // Clear non-critical buffers\n    }\n    \n    static void resetHardware() {\n        // Reinitialize hardware\n    }\n    \n    static void saveErrorLog() {\n        errorLog.saveToEEPROM(0);\n    }\n    \n    static void enterSafeMode() {\n        // Minimal operation mode\n        Serial.println(F(\"Entering safe mode\"));\n        \n        // Disable all interrupts except critical ones\n        // Run minimal loop\n        while (true) {\n            wdt_reset();\n            \n            // Check for recovery command\n            if (Serial.available()) {\n                char cmd = Serial.read();\n                if (cmd == 'R') {\n                    emergencyReset();\n                }\n            }\n            \n            delay(100);\n        }\n    }\n};\n\nuint32_t SafeErrorHandler::lastErrorTime = 0;\nuint8_t SafeErrorHandler::errorCount = 0;\n```\n\n## Diagnostic LEDs\n\n```cpp\n// Visual error indication\nclass ErrorLED {\nprivate:\n    static constexpr uint8_t LED_PIN = LED_BUILTIN;\n    static constexpr uint8_t ERROR_LED = 13;  // Red LED\n    \n    struct Pattern {\n        uint8_t onTime;\n        uint8_t offTime;\n        uint8_t count;\n        uint16_t pauseTime;\n    };\n    \n    static constexpr Pattern patterns[] = {\n        {100, 100, 1, 1000},  // OK: Single short blink\n        {250, 250, 2, 1000},  // Warning: 2 medium blinks\n        {500, 500, 3, 2000},  // Error: 3 long blinks\n        {100, 100, 5, 2000},  // Critical: 5 fast blinks\n    };\n    \n    static Pattern currentPattern;\n    static uint32_t patternStartTime;\n    static uint8_t blinkCount;\n    static bool ledState;\n    \npublic:\n    enum Status { OK, WARNING, ERROR, CRITICAL };\n    \n    static void init() {\n        pinMode(LED_PIN, OUTPUT);\n        pinMode(ERROR_LED, OUTPUT);\n    }\n    \n    static void setStatus(Status status) {\n        currentPattern = patterns[status];\n        patternStartTime = millis();\n        blinkCount = 0;\n        ledState = false;\n    }\n    \n    static void update() {\n        uint32_t elapsed = millis() - patternStartTime;\n        \n        if (blinkCount < currentPattern.count) {\n            uint32_t blinkTime = elapsed % \n                (currentPattern.onTime + currentPattern.offTime);\n                \n            bool newState = blinkTime < currentPattern.onTime;\n            \n            if (newState != ledState) {\n                ledState = newState;\n                digitalWrite(ERROR_LED, ledState);\n                \n                if (!newState) {\n                    blinkCount++;\n                }\n            }\n        } else {\n            // In pause period\n            digitalWrite(ERROR_LED, LOW);\n            \n            if (elapsed >= (currentPattern.count * \n                (currentPattern.onTime + currentPattern.offTime) + \n                currentPattern.pauseTime)) {\n                // Restart pattern\n                patternStartTime = millis();\n                blinkCount = 0;\n            }\n        }\n    }\n    \n    static void showErrorCode(ErrorCode code) {\n        // Blink error code in morse-like pattern\n        int8_t value = static_cast<int8_t>(code);\n        bool negative = value < 0;\n        if (negative) value = -value;\n        \n        // Show sign (long blink for negative)\n        digitalWrite(ERROR_LED, HIGH);\n        delay(negative ? 1000 : 200);\n        digitalWrite(ERROR_LED, LOW);\n        delay(500);\n        \n        // Show digits\n        while (value > 0) {\n            uint8_t digit = value % 10;\n            value /= 10;\n            \n            // Blink digit times\n            for (uint8_t i = 0; i < digit; i++) {\n                digitalWrite(ERROR_LED, HIGH);\n                delay(200);\n                digitalWrite(ERROR_LED, LOW);\n                delay(200);\n            }\n            \n            delay(800);  // Pause between digits\n        }\n    }\n};\n```\n\n## Best Practices Summary\n\n1. **Use Error Codes**: Define comprehensive error codes for all failure modes\n2. **Result Types**: Use Result<T> pattern instead of exceptions\n3. **Early Return**: Propagate errors early with RETURN_IF_ERROR\n4. **Error Context**: Capture file, line, and timestamp with errors\n5. **Retry Logic**: Implement configurable retry policies\n6. **Circuit Breaker**: Protect against cascading failures\n7. **Graceful Degradation**: Implement fallback strategies\n8. **Error Logging**: Maintain circular error log\n9. **Visual Indicators**: Use LEDs for error status\n10. **Watchdog Safety**: Integrate error handling with watchdog",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/src/**"
          ]
        },
        {
          "id": "git-workflow",
          "title": "Git Workflow",
          "fileName": "git-workflow.mdc",
          "frontmatter": {
            "description": "Git workflow, commit message conventions, and version control best practices for embedded projects",
            "globs": [
              "**/.git/**",
              "**/.gitignore"
            ],
            "alwaysApply": true
          },
          "content": "# Git Workflow Guidelines\n\n## Commit Message Format\n\nFollow the [Conventional Commits](https://www.conventionalcommits.org/) specification for consistent commit messages.\n\n### Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- **`feat`**: A new feature\n- **`fix`**: A bug fix\n- **`docs`**: Documentation only changes\n- **`style`**: Code style changes (formatting, missing semicolons, etc.)\n- **`refactor`**: Code refactoring without bug fixes or features\n- **`perf`**: Performance improvements\n- **`test`**: Adding or updating tests\n- **`chore`**: Maintenance tasks, dependency updates\n- **`build`**: Build system or PlatformIO configuration changes\n- **`ci`**: CI/CD configuration changes\n- **`hw`**: Hardware-specific changes or pin configuration updates\n\n### Examples\n\n```bash\n# Feature\nfeat(sensors): add DHT22 temperature sensor support\n\n# Bug fix\nfix(i2c): resolve I2C bus lockup on ESP32\n\n# Hardware change\nhw(pins): update pin assignments for rev 2.0 board\n\n# Performance improvement\nperf(adc): optimize ADC reading with DMA transfer\n\n# Breaking change\nfeat(hal)!: refactor hardware abstraction layer\n\nBREAKING CHANGE: Hardware abstraction API changed. All drivers must be updated.\n\n# Multiple changes\nfeat(communication): add MQTT client support\n\n- Implement MQTT publish/subscribe\n- Add connection retry logic\n- Update network configuration\n```\n\n### Scope\n\nUse scope to indicate which part of the codebase is affected:\n\n- `hal`: Hardware abstraction layer\n- `drivers`: Device drivers\n- `sensors`: Sensor integration\n- `communication`: Serial, I2C, SPI, network protocols\n- `power`: Power management\n- `interrupts`: Interrupt handling\n- `memory`: Memory management\n- `config`: Configuration files\n- `hw`: Hardware/pin configuration\n- `build`: Build system (platformio.ini)\n- `tests`: Test files\n\n### Subject\n\n- Use imperative mood (\"add\" not \"added\" or \"adds\")\n- First line should be 50 characters or less\n- Don't end with a period\n- Be specific and descriptive\n- Include hardware/platform if relevant\n\n### Body (Optional)\n\n- Explain the \"what\" and \"why\" vs \"how\"\n- Wrap at 72 characters\n- Can include multiple paragraphs\n- Document hardware assumptions or pin changes\n- Note timing constraints or memory implications\n\n### Footer (Optional)\n\n- Reference issues: `Closes #123`, `Fixes #456`\n- Breaking changes: `BREAKING CHANGE: <description>`\n- Hardware notes: `Hardware: Requires board revision 2.0+`\n\n## Branch Naming\n\n### Format\n\n```\n<type>/<description>\n```\n\n### Types\n\n- `feature/`: New features\n- `fix/`: Bug fixes\n- `hotfix/`: Critical production fixes\n- `refactor/`: Code refactoring\n- `docs/`: Documentation updates\n- `test/`: Test additions/updates\n- `hw/`: Hardware-specific changes\n\n### Examples\n\n```bash\nfeature/dht22-sensor-support\nfix/i2c-bus-lockup\nhotfix/critical-memory-leak\nrefactor/hardware-abstraction\nhw/update-pin-assignments\n```\n\n## Commit Best Practices\n\n### ‚úÖ DO\n\n- Make atomic commits (one logical change per commit)\n- Write clear, descriptive commit messages\n- Commit frequently (small, incremental changes)\n- Test on hardware before committing\n- Run `pio check` before committing\n- Review your changes with `git diff` before committing\n- Document hardware requirements in commit message\n- Include pin configuration changes in commit message\n- Commit platformio.ini changes separately from code\n\n### ‚ùå DON'T\n\n- Commit commented-out code\n- Commit debugging code or Serial.print statements\n- Commit with compiler warnings (see `no-hiding.mdc`)\n- Mix unrelated changes in one commit\n- Commit secrets, API keys, or WiFi credentials\n- Force push to main/master branch\n- Commit without testing on hardware\n- Commit binary files (.bin, .hex, .elf)\n- Commit build artifacts\n\n## .gitignore for Embedded Projects\n\n```gitignore\n# PlatformIO\n.pio/\n.vscode/\n.idea/\n\n# Build artifacts\n*.bin\n*.hex\n*.elf\n*.map\n*.lst\n\n# Compiled Object files\n*.o\n*.obj\n*.a\n*.lib\n\n# Preprocessor output\n*.i\n*.ii\n\n# Assembly listings\n*.s\n*.S\n\n# Debug files\n*.dSYM/\n*.su\n*.idb\n*.pdb\n\n# IDE files\n*.swp\n*.swo\n*~\n.DS_Store\n\n# Environment files\n.env\n.env.local\nsecrets.h\n\n# Test coverage\n*.gcda\n*.gcno\n*.gcov\n\n# Documentation builds\ndocs/_build/\n```\n\n## Workflow\n\n### 1. Create Feature Branch\n\n```bash\ngit checkout -b feature/my-new-feature\n```\n\n### 2. Make Changes\n\n- Write code following all guidelines\n- Test on hardware\n- Run `pio check` to verify no warnings\n- Test on multiple platforms if applicable\n\n### 3. Stage Changes\n\n```bash\n# Review what will be committed\ngit status\ngit diff\n\n# Stage specific files\ngit add src/sensor.cpp src/sensor.h\n\n# Or stage all changes\ngit add .\n```\n\n### 4. Commit\n\n```bash\ngit commit -m \"feat(sensors): add DHT22 temperature sensor support\"\n```\n\n### 5. Push Branch\n\n```bash\ngit push origin feature/my-new-feature\n```\n\n### 6. Create Pull Request\n\n- Write clear PR description\n- Include hardware requirements\n- Note pin assignments if changed\n- Document testing performed\n- Reference related issues\n\n### 7. Code Review\n\n- Address review comments\n- Test changes on hardware\n- Update PR description if needed\n\n### 8. Merge\n\n- Squash commits if requested\n- Delete feature branch after merge\n\n## Multi-Platform Development\n\n### Handling Multiple Environments\n\n```bash\n# Test on multiple platforms\npio run -e esp32dev\npio run -e arduino_uno\npio run -e stm32\n\n# Commit platform-specific changes\ngit commit -m \"hw(esp32): add WiFi configuration for ESP32\"\ngit commit -m \"hw(avr): optimize for 8-bit AVR memory constraints\"\n```\n\n### Platform-Specific Branches\n\n```bash\n# For major platform differences\ngit checkout -b platform/esp32-specific-features\ngit checkout -b platform/avr-optimizations\n```\n\n## Hardware Configuration Management\n\n### Pin Configuration\n\n```bash\n# Pin changes should be clearly documented\ngit commit -m \"hw(pins): update I2C pins for rev 2.0 board\n\n- SDA: Pin 4 -> Pin 21 (ESP32 default)\n- SCL: Pin 5 -> Pin 22 (ESP32 default)\n- Requires hardware revision 2.0 or later\"\n```\n\n### Board Variants\n\n```bash\n# Document board-specific configurations\ngit commit -m \"hw(config): add support for Arduino Nano 33 IoT\n\n- Update pin definitions\n- Add board-specific initialization\n- Tested on hardware\"\n```\n\n## Version Tagging\n\n### Semantic Versioning\n\n```bash\n# Tag releases\ngit tag -a v1.0.0 -m \"Release version 1.0.0\n\n- Stable sensor reading implementation\n- Tested on ESP32 and Arduino Uno\n- Hardware requirements: Board rev 2.0+\"\n\n# Push tags\ngit push origin v1.0.0\n```\n\n### Release Notes\n\nInclude in release notes:\n- Hardware requirements\n- Pin configuration changes\n- Known limitations\n- Migration guide if breaking changes\n\n## Pre-Commit Hooks\n\n### Setup\n\n```bash\n# Install pre-commit hook\ncat > .git/hooks/pre-commit << 'EOF'\n#!/bin/bash\n# Run PlatformIO check\npio check || exit 1\n\n# Check for common issues\nif grep -r \"Serial.print\" src/ --include=\"*.cpp\" --include=\"*.h\"; then\n  echo \"Warning: Serial.print found. Ensure DEBUG_LEVEL is set appropriately.\"\nfi\n\nexit 0\nEOF\n\nchmod +x .git/hooks/pre-commit\n```\n\n## Best Practices Summary\n\n1. **Atomic Commits**: One logical change per commit\n2. **Clear Messages**: Descriptive commit messages with context\n3. **Hardware Testing**: Test on actual hardware before committing\n4. **No Warnings**: Fix all compiler warnings before committing\n5. **Document Hardware**: Include hardware requirements in commits\n6. **Pin Changes**: Clearly document pin configuration changes\n7. **Multi-Platform**: Test on all target platforms\n8. **Version Tags**: Tag releases with semantic versioning\n9. **Clean History**: Keep commit history clean and meaningful\n10. **Review Process**: Follow code review guidelines before merging",
          "alwaysApply": true,
          "globs": [
            "**/.git/**",
            "**/.gitignore"
          ]
        },
        {
          "id": "hardware-abstraction-patterns",
          "title": "Hardware Abstraction Patterns",
          "fileName": "hardware-abstraction-patterns.mdc",
          "frontmatter": {
            "description": "Hardware abstraction layer (HAL) patterns and best practices for embedded systems",
            "globs": [
              "**/src/hal/**",
              "**/lib/**/hal/**",
              "**/*_hal.*",
              "**/*_driver.*",
              "**/hardware/**"
            ],
            "alwaysApply": true
          },
          "content": "# Hardware Abstraction Patterns\n\n## Overview\n\nHardware abstraction is crucial for creating portable, testable, and maintainable embedded code. This document outlines patterns for abstracting hardware dependencies, allowing code to work across different microcontroller platforms and simplifying unit testing.\n\n## Core Principles\n\n1. **Separation of Concerns**: Hardware-specific code isolated from business logic\n2. **Compile-Time Polymorphism**: Use templates over virtual functions to avoid overhead\n3. **Zero-Cost Abstractions**: Abstractions should compile to the same code as direct hardware access\n4. **Testability**: Hardware interfaces should be mockable for unit testing\n5. **Type Safety**: Use strong types to prevent pin misconfigurations\n\n## Pin Management Pattern\n\n### Compile-Time Pin Configuration\n\n```cpp\n// include/hardware/pin_config.h\n#pragma once\n#include <stdint.h>\n\n// Pin configuration using templates for compile-time validation\ntemplate<uint8_t PIN>\nstruct Pin {\n    static_assert(PIN < NUM_DIGITAL_PINS, \"Invalid pin number\");\n    static constexpr uint8_t number = PIN;\n};\n\n// Named pin aliases for readability\nnamespace Pins {\n    using StatusLED = Pin<LED_BUILTIN>;\n    using Button1 = Pin<2>;\n    using MotorPWM = Pin<9>;\n    \n    // I2C pins (platform-specific)\n    #if defined(ESP32)\n        using SDA = Pin<21>;\n        using SCL = Pin<22>;\n    #elif defined(ARDUINO_AVR_UNO)\n        using SDA = Pin<A4>;\n        using SCL = Pin<A5>;\n    #endif\n    \n    // SPI pins\n    using MOSI = Pin<MOSI>;\n    using MISO = Pin<MISO>;\n    using SCK = Pin<SCK>;\n    using CS_SENSOR = Pin<10>;\n}\n\n// Pin mode traits\nenum class PinMode : uint8_t {\n    Input = INPUT,\n    Output = OUTPUT,\n    InputPullup = INPUT_PULLUP,\n    #ifdef ESP32\n    InputPulldown = INPUT_PULLDOWN,\n    #endif\n};\n\n// Pin capabilities checking\ntemplate<uint8_t PIN>\nstruct PinTraits {\n    static constexpr bool has_pwm = \n        #ifdef ESP32\n        true;  // All ESP32 pins support PWM\n        #else\n        (PIN == 3 || PIN == 5 || PIN == 6 || PIN == 9 || PIN == 10 || PIN == 11);\n        #endif\n    \n    static constexpr bool has_adc = \n        #ifdef ESP32\n        (PIN >= 32 && PIN <= 39);  // ESP32 ADC pins\n        #else\n        (PIN >= A0 && PIN <= A5);   // Arduino analog pins\n        #endif\n};\n```\n\n### GPIO Abstraction\n\n```cpp\n// include/hal/gpio.h\n#pragma once\n#include \"hardware/pin_config.h\"\n\ntemplate<typename PinType>\nclass DigitalPin {\nprivate:\n    static constexpr uint8_t pin = PinType::number;\n    \npublic:\n    static void init(PinMode mode) {\n        pinMode(pin, static_cast<uint8_t>(mode));\n    }\n    \n    static void write(bool value) {\n        digitalWrite(pin, value ? HIGH : LOW);\n    }\n    \n    static bool read() {\n        return digitalRead(pin) == HIGH;\n    }\n    \n    static void toggle() {\n        write(!read());\n    }\n    \n    // PWM support (compile-time check)\n    template<typename T = PinType>\n    static typename std::enable_if<PinTraits<T::number>::has_pwm, void>::type\n    writePWM(uint8_t value) {\n        analogWrite(pin, value);\n    }\n};\n\n// Usage example\nusing LED = DigitalPin<Pins::StatusLED>;\nusing Button = DigitalPin<Pins::Button1>;\n\nvoid setup() {\n    LED::init(PinMode::Output);\n    Button::init(PinMode::InputPullup);\n}\n\nvoid loop() {\n    if (!Button::read()) {  // Active low button\n        LED::toggle();\n        delay(200);  // Debounce\n    }\n}\n```\n\n## Peripheral Abstraction Pattern\n\n### SPI Hardware Abstraction\n\n```cpp\n// include/hal/spi_hal.h\n#pragma once\n#include <SPI.h>\n\n// SPI configuration\nstruct SPIConfig {\n    uint32_t frequency;\n    uint8_t mode;\n    uint8_t bitOrder;\n    \n    constexpr SPIConfig(\n        uint32_t freq = 1000000,\n        uint8_t m = SPI_MODE0,\n        uint8_t order = MSBFIRST\n    ) : frequency(freq), mode(m), bitOrder(order) {}\n};\n\n// Platform-independent SPI abstraction\ntemplate<typename ChipSelectPin>\nclass SPIDevice {\nprivate:\n    static SPISettings settings;\n    \npublic:\n    static void init(const SPIConfig& config) {\n        ChipSelectPin::init(PinMode::Output);\n        ChipSelectPin::write(true);  // Deselect\n        \n        settings = SPISettings(config.frequency, config.bitOrder, config.mode);\n        SPI.begin();\n    }\n    \n    static uint8_t transfer(uint8_t data) {\n        return SPI.transfer(data);\n    }\n    \n    static void transfer(uint8_t* buffer, size_t length) {\n        SPI.transfer(buffer, length);\n    }\n    \n    // RAII-style transaction\n    class Transaction {\n    public:\n        Transaction() {\n            SPI.beginTransaction(settings);\n            ChipSelectPin::write(false);  // Select\n        }\n        \n        ~Transaction() {\n            ChipSelectPin::write(true);   // Deselect\n            SPI.endTransaction();\n        }\n        \n        // Prevent copying\n        Transaction(const Transaction&) = delete;\n        Transaction& operator=(const Transaction&) = delete;\n    };\n    \n    template<typename Func>\n    static auto transaction(Func func) -> decltype(func()) {\n        Transaction t;\n        return func();\n    }\n};\n\n// Define static member\ntemplate<typename CS>\nSPISettings SPIDevice<CS>::settings;\n\n// Usage example\nusing SensorSPI = SPIDevice<DigitalPin<Pins::CS_SENSOR>>;\n\nvoid readSensor() {\n    SensorSPI::transaction([]() {\n        uint8_t cmd = 0x01;\n        SensorSPI::transfer(&cmd, 1);\n        \n        uint8_t data[4];\n        SensorSPI::transfer(data, 4);\n        // Process data...\n    });\n}\n```\n\n### I2C Hardware Abstraction\n\n```cpp\n// include/hal/i2c_hal.h\n#pragma once\n#include <Wire.h>\n\n// I2C abstraction with error handling\nclass I2CDevice {\nprivate:\n    uint8_t address;\n    TwoWire* wire;\n    \npublic:\n    enum class Error : uint8_t {\n        None = 0,\n        AddressNACK = 1,\n        DataNACK = 2,\n        Other = 3,\n        Timeout = 4\n    };\n    \n    I2CDevice(uint8_t addr, TwoWire* w = &Wire) \n        : address(addr), wire(w) {}\n    \n    void begin(uint32_t frequency = 100000) {\n        wire->begin();\n        wire->setClock(frequency);\n    }\n    \n    Error writeRegister(uint8_t reg, uint8_t value) {\n        wire->beginTransmission(address);\n        wire->write(reg);\n        wire->write(value);\n        return static_cast<Error>(wire->endTransmission());\n    }\n    \n    Error writeRegister(uint8_t reg, const uint8_t* data, size_t length) {\n        wire->beginTransmission(address);\n        wire->write(reg);\n        wire->write(data, length);\n        return static_cast<Error>(wire->endTransmission());\n    }\n    \n    Error readRegister(uint8_t reg, uint8_t* data, size_t length) {\n        // Write register address\n        wire->beginTransmission(address);\n        wire->write(reg);\n        Error err = static_cast<Error>(wire->endTransmission(false));\n        if (err != Error::None) return err;\n        \n        // Read data\n        size_t received = wire->requestFrom(address, static_cast<uint8_t>(length));\n        if (received != length) return Error::Timeout;\n        \n        for (size_t i = 0; i < length; i++) {\n            data[i] = wire->read();\n        }\n        \n        return Error::None;\n    }\n    \n    // Convenience method for single byte read\n    Error readRegister(uint8_t reg, uint8_t& value) {\n        return readRegister(reg, &value, 1);\n    }\n};\n\n// Usage example\nclass BME280Sensor {\nprivate:\n    I2CDevice device;\n    static constexpr uint8_t CHIP_ID_REG = 0xD0;\n    static constexpr uint8_t EXPECTED_CHIP_ID = 0x60;\n    \npublic:\n    BME280Sensor() : device(0x76) {}  // Default I2C address\n    \n    bool init() {\n        device.begin();\n        \n        uint8_t chipId;\n        if (device.readRegister(CHIP_ID_REG, chipId) != I2CDevice::Error::None) {\n            return false;\n        }\n        \n        return chipId == EXPECTED_CHIP_ID;\n    }\n    \n    float readTemperature() {\n        // Implementation...\n        return 0.0f;\n    }\n};\n```\n\n## UART Hardware Abstraction\n\n```cpp\n// include/hal/uart_hal.h\n#pragma once\n#include <HardwareSerial.h>\n\ntemplate<typename SerialType = HardwareSerial>\nclass UARTDevice {\nprivate:\n    SerialType* serial;\n    uint32_t baudRate;\n    uint32_t timeout;\n    \npublic:\n    UARTDevice(SerialType* s, uint32_t baud = 115200)\n        : serial(s), baudRate(baud), timeout(1000) {}\n    \n    void begin() {\n        serial->begin(baudRate);\n        serial->setTimeout(timeout);\n    }\n    \n    void end() {\n        serial->end();\n    }\n    \n    void setBaudRate(uint32_t baud) {\n        baudRate = baud;\n        serial->begin(baudRate);\n    }\n    \n    void setTimeout(uint32_t ms) {\n        timeout = ms;\n        serial->setTimeout(timeout);\n    }\n    \n    size_t write(uint8_t data) {\n        return serial->write(data);\n    }\n    \n    size_t write(const uint8_t* data, size_t length) {\n        return serial->write(data, length);\n    }\n    \n    size_t print(const char* str) {\n        return serial->print(str);\n    }\n    \n    size_t println(const char* str) {\n        return serial->println(str);\n    }\n    \n    int available() {\n        return serial->available();\n    }\n    \n    int read() {\n        return serial->read();\n    }\n    \n    size_t readBytes(uint8_t* buffer, size_t length) {\n        return serial->readBytes(buffer, length);\n    }\n    \n    void flush() {\n        serial->flush();\n    }\n    \n    // Template method for sending structured data\n    template<typename T>\n    bool sendPacket(const T& data) {\n        uint8_t header[] = {0xAA, 0x55, sizeof(T)};\n        size_t written = write(header, sizeof(header));\n        written += write(reinterpret_cast<const uint8_t*>(&data), sizeof(T));\n        \n        // Simple checksum\n        uint8_t checksum = 0;\n        const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&data);\n        for (size_t i = 0; i < sizeof(T); i++) {\n            checksum ^= bytes[i];\n        }\n        written += write(checksum);\n        \n        return written == (sizeof(header) + sizeof(T) + 1);\n    }\n};\n\n// Platform-specific serial port selection\n#ifdef ESP32\n    using DebugSerial = UARTDevice<HardwareSerial>;\n    using GPSSerial = UARTDevice<HardwareSerial>;\n#else\n    using DebugSerial = UARTDevice<HardwareSerial>;\n    #ifdef HAVE_HWSERIAL1\n        using GPSSerial = UARTDevice<HardwareSerial>;\n    #else\n        #include <SoftwareSerial.h>\n        using GPSSerial = UARTDevice<SoftwareSerial>;\n    #endif\n#endif\n```\n\n## Timer Hardware Abstraction\n\n```cpp\n// include/hal/timer_hal.h\n#pragma once\n#include <functional>\n\n// Timer abstraction for periodic tasks\nclass Timer {\npublic:\n    using Callback = std::function<void()>;\n    \nprivate:\n    uint32_t interval;\n    uint32_t lastTrigger;\n    Callback callback;\n    bool enabled;\n    bool oneShot;\n    \npublic:\n    Timer(uint32_t intervalMs, Callback cb, bool once = false)\n        : interval(intervalMs), lastTrigger(0), \n          callback(cb), enabled(false), oneShot(once) {}\n    \n    void start() {\n        lastTrigger = millis();\n        enabled = true;\n    }\n    \n    void stop() {\n        enabled = false;\n    }\n    \n    void reset() {\n        lastTrigger = millis();\n    }\n    \n    void setInterval(uint32_t ms) {\n        interval = ms;\n    }\n    \n    void update() {\n        if (!enabled) return;\n        \n        uint32_t now = millis();\n        if (now - lastTrigger >= interval) {\n            lastTrigger = now;\n            if (callback) callback();\n            \n            if (oneShot) {\n                enabled = false;\n            }\n        }\n    }\n    \n    bool isEnabled() const { return enabled; }\n};\n\n// Hardware timer abstraction (platform-specific)\n#ifdef ESP32\n    #include <esp_timer.h>\n    \n    class HardwareTimer {\n    private:\n        esp_timer_handle_t handle;\n        std::function<void()> callback;\n        \n        static void IRAM_ATTR timerCallback(void* arg) {\n            HardwareTimer* timer = static_cast<HardwareTimer*>(arg);\n            if (timer->callback) timer->callback();\n        }\n        \n    public:\n        HardwareTimer() : handle(nullptr) {}\n        \n        ~HardwareTimer() {\n            if (handle) {\n                esp_timer_delete(handle);\n            }\n        }\n        \n        bool init(uint32_t periodUs, std::function<void()> cb, bool periodic = true) {\n            callback = cb;\n            \n            esp_timer_create_args_t args = {\n                .callback = timerCallback,\n                .arg = this,\n                .dispatch_method = ESP_TIMER_TASK,\n                .name = \"hardware_timer\"\n            };\n            \n            if (esp_timer_create(&args, &handle) != ESP_OK) {\n                return false;\n            }\n            \n            if (periodic) {\n                return esp_timer_start_periodic(handle, periodUs) == ESP_OK;\n            } else {\n                return esp_timer_start_once(handle, periodUs) == ESP_OK;\n            }\n        }\n        \n        void stop() {\n            if (handle) {\n                esp_timer_stop(handle);\n            }\n        }\n    };\n#endif\n```\n\n## ADC Hardware Abstraction\n\n```cpp\n// include/hal/adc_hal.h\n#pragma once\n\ntemplate<uint8_t PIN>\nclass AnalogInput {\n    static_assert(PinTraits<PIN>::has_adc, \"Pin does not support ADC\");\n    \nprivate:\n    static constexpr uint8_t pin = PIN;\n    static constexpr float vRef = \n        #ifdef ESP32\n        3.3f;\n        #else\n        5.0f;\n        #endif\n    \n    static constexpr uint16_t maxValue = \n        #ifdef ESP32\n        4095;  // 12-bit ADC\n        #else\n        1023;  // 10-bit ADC\n        #endif\n    \npublic:\n    static void init() {\n        pinMode(pin, INPUT);\n        #ifdef ESP32\n        analogSetAttenuation(ADC_11db);  // 0-3.3V range\n        #endif\n    }\n    \n    static uint16_t read() {\n        return analogRead(pin);\n    }\n    \n    static float readVoltage() {\n        return (read() * vRef) / maxValue;\n    }\n    \n    static uint16_t readAverage(uint8_t samples = 10) {\n        uint32_t sum = 0;\n        for (uint8_t i = 0; i < samples; i++) {\n            sum += read();\n            delayMicroseconds(100);  // Settling time\n        }\n        return sum / samples;\n    }\n    \n    static float readVoltageAverage(uint8_t samples = 10) {\n        return (readAverage(samples) * vRef) / maxValue;\n    }\n};\n\n// Usage example\nusing BatteryVoltage = AnalogInput<A0>;\n\nvoid checkBattery() {\n    BatteryVoltage::init();\n    float voltage = BatteryVoltage::readVoltageAverage();\n    \n    // Assuming voltage divider (e.g., 2:1)\n    float batteryVoltage = voltage * 2.0f;\n    \n    if (batteryVoltage < 3.0f) {\n        // Low battery warning\n    }\n}\n```\n\n## Driver Architecture Pattern\n\n```cpp\n// include/drivers/driver_base.h\n#pragma once\n\n// Base driver traits\ntemplate<typename Derived>\nclass Driver {\nprotected:\n    bool initialized;\n    \npublic:\n    Driver() : initialized(false) {}\n    \n    bool begin() {\n        if (initialized) return true;\n        \n        if (static_cast<Derived*>(this)->onBegin()) {\n            initialized = true;\n            return true;\n        }\n        return false;\n    }\n    \n    void end() {\n        if (!initialized) return;\n        \n        static_cast<Derived*>(this)->onEnd();\n        initialized = false;\n    }\n    \n    bool isInitialized() const {\n        return initialized;\n    }\n};\n\n// Example sensor driver\nclass DHT22 : public Driver<DHT22> {\n    friend class Driver<DHT22>;\n    \nprivate:\n    uint8_t pin;\n    float temperature;\n    float humidity;\n    uint32_t lastRead;\n    \n    bool onBegin() {\n        pinMode(pin, INPUT_PULLUP);\n        return true;\n    }\n    \n    void onEnd() {\n        // Nothing special needed\n    }\n    \n    bool readData() {\n        // DHT22 protocol implementation...\n        return true;\n    }\n    \npublic:\n    explicit DHT22(uint8_t dataPin) \n        : pin(dataPin), temperature(0), humidity(0), lastRead(0) {}\n    \n    bool update() {\n        if (!initialized) return false;\n        \n        // Rate limit reads (DHT22 needs 2s between reads)\n        if (millis() - lastRead < 2000) {\n            return true;  // Return cached values\n        }\n        \n        if (readData()) {\n            lastRead = millis();\n            return true;\n        }\n        return false;\n    }\n    \n    float getTemperature() const { return temperature; }\n    float getHumidity() const { return humidity; }\n};\n```\n\n## Testability Patterns\n\n```cpp\n// include/hal/hardware_traits.h\n#pragma once\n\n// Hardware traits for compile-time feature detection\ntemplate<typename Platform>\nstruct HardwareTraits {\n    static constexpr bool has_wifi = false;\n    static constexpr bool has_bluetooth = false;\n    static constexpr bool has_usb = false;\n    static constexpr bool has_dma = false;\n    static constexpr bool has_floating_point_unit = false;\n    static constexpr uint32_t flash_size = 0;\n    static constexpr uint32_t ram_size = 0;\n    static constexpr uint32_t eeprom_size = 0;\n};\n\n// Specializations for specific platforms\n#ifdef ESP32\ntemplate<>\nstruct HardwareTraits<class ESP32Platform> {\n    static constexpr bool has_wifi = true;\n    static constexpr bool has_bluetooth = true;\n    static constexpr bool has_usb = false;\n    static constexpr bool has_dma = true;\n    static constexpr bool has_floating_point_unit = true;\n    static constexpr uint32_t flash_size = 4 * 1024 * 1024;  // 4MB typical\n    static constexpr uint32_t ram_size = 520 * 1024;        // 520KB\n    static constexpr uint32_t eeprom_size = 0;              // Emulated in flash\n};\n#endif\n\n// Mock hardware for testing\n#ifdef UNIT_TEST\ntemplate<typename T>\nclass MockPin {\nprivate:\n    static bool state;\n    static uint8_t pwmValue;\n    static PinMode mode;\n    \npublic:\n    static void init(PinMode m) { mode = m; }\n    static void write(bool value) { state = value; }\n    static bool read() { return state; }\n    static void writePWM(uint8_t value) { pwmValue = value; }\n    \n    // Test helpers\n    static bool getState() { return state; }\n    static uint8_t getPWM() { return pwmValue; }\n    static PinMode getMode() { return mode; }\n    static void setState(bool s) { state = s; }\n};\n\n// Static member definitions\ntemplate<typename T> bool MockPin<T>::state = false;\ntemplate<typename T> uint8_t MockPin<T>::pwmValue = 0;\ntemplate<typename T> PinMode MockPin<T>::mode = PinMode::Input;\n\n// Use mocks in test builds\n    #define LED_PIN MockPin<struct LEDTag>\n    #define BUTTON_PIN MockPin<struct ButtonTag>\n#else\n    // Use real hardware\n    #define LED_PIN DigitalPin<Pins::StatusLED>\n    #define BUTTON_PIN DigitalPin<Pins::Button1>\n#endif\n```\n\n## Best Practices Summary\n\n1. **Use Templates**: Prefer compile-time polymorphism for zero overhead\n2. **Strong Types**: Use type system to prevent configuration errors\n3. **RAII Pattern**: Use constructors/destructors for resource management\n4. **Platform Abstractions**: Hide platform differences behind common interfaces\n5. **Error Handling**: Return error codes, not exceptions\n6. **Mockability**: Design interfaces that can be mocked for testing\n7. **Minimal Overhead**: Abstractions should compile to direct hardware access\n8. **Documentation**: Document hardware assumptions and constraints",
          "alwaysApply": true,
          "globs": [
            "**/src/hal/**",
            "**/lib/**/hal/**",
            "**/*_hal.*",
            "**/*_driver.*",
            "**/hardware/**"
          ]
        },
        {
          "id": "interrupt-handling-patterns",
          "title": "Interrupt Handling Patterns",
          "fileName": "interrupt-handling-patterns.mdc",
          "frontmatter": {
            "description": "Interrupt handling patterns and real-time programming guidelines for embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/src/**"
            ],
            "alwaysApply": true
          },
          "content": "# Interrupt Handling & Real-Time Patterns\n\n## Overview\n\nInterrupts are fundamental to responsive embedded systems but require careful handling to avoid race conditions, priority inversions, and timing violations. This document provides patterns and guidelines for safe, efficient interrupt handling and real-time programming.\n\n## Interrupt Safety Principles\n\n### Critical Sections\n\n```cpp\n// Basic critical section macros\n#define CRITICAL_SECTION_BEGIN() noInterrupts()\n#define CRITICAL_SECTION_END() interrupts()\n\n// RAII-style critical section\nclass CriticalSection {\nprivate:\n    uint8_t savedSREG;\n    \npublic:\n    CriticalSection() {\n        #ifdef __AVR__\n        savedSREG = SREG;\n        cli();  // Clear interrupt flag\n        #elif defined(ESP32)\n        savedSREG = 0;  // Not used\n        portDISABLE_INTERRUPTS();\n        #else\n        noInterrupts();\n        #endif\n    }\n    \n    ~CriticalSection() {\n        #ifdef __AVR__\n        SREG = savedSREG;  // Restore interrupt state\n        #elif defined(ESP32)\n        portENABLE_INTERRUPTS();\n        #else\n        interrupts();\n        #endif\n    }\n    \n    // Prevent copying\n    CriticalSection(const CriticalSection&) = delete;\n    CriticalSection& operator=(const CriticalSection&) = delete;\n};\n\n// Usage\nvoid updateSharedData() {\n    CriticalSection cs;  // Interrupts disabled\n    // ... modify shared data ...\n    // Interrupts automatically re-enabled when cs goes out of scope\n}\n\n// Nested critical sections\nclass NestedCriticalSection {\nprivate:\n    static uint8_t nestLevel;\n    bool wasEnabled;\n    \npublic:\n    NestedCriticalSection() {\n        wasEnabled = (nestLevel == 0) && interruptsEnabled();\n        if (nestLevel == 0) {\n            noInterrupts();\n        }\n        nestLevel++;\n    }\n    \n    ~NestedCriticalSection() {\n        nestLevel--;\n        if (nestLevel == 0 && wasEnabled) {\n            interrupts();\n        }\n    }\n    \nprivate:\n    static bool interruptsEnabled() {\n        #ifdef __AVR__\n        return SREG & (1 << SREG_I);\n        #else\n        return true;  // Platform-specific\n        #endif\n    }\n};\n\nuint8_t NestedCriticalSection::nestLevel = 0;\n```\n\n### Volatile Variables\n\n```cpp\n// Proper use of volatile for ISR communication\nclass InterruptSafeData {\nprivate:\n    volatile uint32_t counter;\n    volatile bool flag;\n    volatile uint8_t buffer[64];\n    volatile size_t bufferIndex;\n    \npublic:\n    // Read with interrupts disabled for multi-byte values\n    uint32_t readCounter() {\n        CriticalSection cs;\n        return counter;\n    }\n    \n    // Atomic operations for single-byte values\n    bool checkAndClearFlag() {\n        if (!flag) return false;\n        \n        CriticalSection cs;\n        bool result = flag;\n        flag = false;\n        return result;\n    }\n    \n    // ISR-safe ring buffer operations\n    bool pushFromISR(uint8_t data) {\n        size_t next = (bufferIndex + 1) & 63;  // Power of 2 size\n        if (next == readIndex) return false;   // Full\n        \n        buffer[bufferIndex] = data;\n        bufferIndex = next;\n        return true;\n    }\n    \nprivate:\n    volatile size_t readIndex = 0;\n};\n\n// Memory barriers for proper ordering\n#ifdef __arm__\n    #define MEMORY_BARRIER() __DMB()\n#else\n    #define MEMORY_BARRIER() __asm__ __volatile__(\"\" ::: \"memory\")\n#endif\n```\n\n## ISR Design Patterns\n\n### Minimal ISR Pattern\n\n```cpp\n// ISR should only capture data and set flags\nvolatile bool adcDataReady = false;\nvolatile uint16_t adcValue = 0;\n\n#ifdef __AVR__\nISR(ADC_vect) {\n    adcValue = ADC;  // Read ADC value\n    adcDataReady = true;\n}\n#endif\n\n// Deferred processing in main loop\nvoid processAdcData() {\n    if (!adcDataReady) return;\n    \n    uint16_t value;\n    {\n        CriticalSection cs;\n        value = adcValue;\n        adcDataReady = false;\n    }\n    \n    // Heavy processing outside ISR\n    float voltage = (value * 5.0) / 1023.0;\n    updateDisplay(voltage);\n}\n```\n\n### ISR Timing Constraints\n\n```cpp\n// ISR execution time monitoring\nclass ISRProfiler {\nprivate:\n    struct ISRStats {\n        const char* name;\n        uint32_t maxDuration;\n        uint32_t totalCalls;\n        uint32_t violations;  // Times exceeded limit\n    };\n    \n    static constexpr size_t MAX_ISRS = 8;\n    static ISRStats stats[MAX_ISRS];\n    static size_t isrCount;\n    \npublic:\n    class ScopedTimer {\n    private:\n        ISRStats* stat;\n        uint32_t startTime;\n        uint32_t limit;\n        \n    public:\n        ScopedTimer(const char* isrName, uint32_t limitMicros) {\n            stat = findOrCreate(isrName);\n            limit = limitMicros;\n            startTime = micros();\n        }\n        \n        ~ScopedTimer() {\n            uint32_t duration = micros() - startTime;\n            \n            stat->totalCalls++;\n            if (duration > stat->maxDuration) {\n                stat->maxDuration = duration;\n            }\n            if (duration > limit) {\n                stat->violations++;\n            }\n        }\n        \n    private:\n        static ISRStats* findOrCreate(const char* name) {\n            for (size_t i = 0; i < isrCount; i++) {\n                if (strcmp(stats[i].name, name) == 0) {\n                    return &stats[i];\n                }\n            }\n            \n            if (isrCount < MAX_ISRS) {\n                stats[isrCount] = {name, 0, 0, 0};\n                return &stats[isrCount++];\n            }\n            \n            return &stats[0];  // Fallback\n        }\n    };\n    \n    static void report() {\n        Serial.println(F(\"\\n=== ISR Profile ===\"));\n        for (size_t i = 0; i < isrCount; i++) {\n            Serial.print(stats[i].name);\n            Serial.print(F(\": Max=\"));\n            Serial.print(stats[i].maxDuration);\n            Serial.print(F(\"us, Calls=\"));\n            Serial.print(stats[i].totalCalls);\n            Serial.print(F(\", Violations=\"));\n            Serial.println(stats[i].violations);\n        }\n    }\n};\n\n// Usage in ISR\nvoid IRAM_ATTR timerISR() {\n    ISRProfiler::ScopedTimer timer(\"Timer1\", 50);  // 50us limit\n    // ISR code here...\n}\n```\n\n### State Machine in ISR\n\n```cpp\n// Fast state machine for protocol decoding\nclass ProtocolDecoder {\nprivate:\n    enum State : uint8_t {\n        IDLE, START_BIT, DATA_BITS, STOP_BIT\n    };\n    \n    volatile State state = IDLE;\n    volatile uint8_t bitCount = 0;\n    volatile uint8_t dataByte = 0;\n    volatile bool dataReady = false;\n    \npublic:\n    // Called from pin change ISR\n    void IRAM_ATTR handlePinChange(bool pinState) {\n        switch (state) {\n            case IDLE:\n                if (!pinState) {  // Start bit detected (low)\n                    state = START_BIT;\n                    bitCount = 0;\n                    dataByte = 0;\n                }\n                break;\n                \n            case START_BIT:\n                state = DATA_BITS;\n                break;\n                \n            case DATA_BITS:\n                dataByte |= (pinState ? 1 : 0) << bitCount;\n                if (++bitCount >= 8) {\n                    state = STOP_BIT;\n                }\n                break;\n                \n            case STOP_BIT:\n                if (pinState) {  // Valid stop bit (high)\n                    dataReady = true;\n                }\n                state = IDLE;\n                break;\n        }\n    }\n    \n    bool getData(uint8_t& byte) {\n        if (!dataReady) return false;\n        \n        CriticalSection cs;\n        byte = dataByte;\n        dataReady = false;\n        return true;\n    }\n};\n```\n\n## Timer Management\n\n### Hardware Timer Abstraction\n\n```cpp\n// Platform-agnostic timer interface\nclass HardwareTimer {\npublic:\n    using TimerCallback = void (*)();\n    \n    virtual bool init(uint32_t frequencyHz, TimerCallback callback) = 0;\n    virtual void start() = 0;\n    virtual void stop() = 0;\n    virtual void setPeriod(uint32_t microseconds) = 0;\n};\n\n#ifdef __AVR__\n// AVR Timer implementation\nclass AVRTimer1 : public HardwareTimer {\nprivate:\n    static TimerCallback callback;\n    \npublic:\n    bool init(uint32_t frequencyHz, TimerCallback cb) override {\n        callback = cb;\n        \n        // Configure Timer1 for CTC mode\n        TCCR1A = 0;\n        TCCR1B = (1 << WGM12);  // CTC mode\n        \n        // Calculate prescaler and compare value\n        uint32_t cycles = F_CPU / frequencyHz;\n        uint16_t prescaler = 1;\n        uint8_t prescalerBits = 1;\n        \n        if (cycles > 65535) {\n            prescaler = 64;\n            prescalerBits = 3;\n            cycles /= 64;\n        }\n        \n        OCR1A = cycles - 1;\n        TCCR1B |= prescalerBits;\n        \n        // Enable interrupt\n        TIMSK1 |= (1 << OCIE1A);\n        \n        return true;\n    }\n    \n    void start() override {\n        TCNT1 = 0;\n        TIMSK1 |= (1 << OCIE1A);\n    }\n    \n    void stop() override {\n        TIMSK1 &= ~(1 << OCIE1A);\n    }\n    \n    void setPeriod(uint32_t microseconds) override {\n        uint32_t cycles = (F_CPU / 1000000) * microseconds;\n        OCR1A = min(cycles - 1, 65535);\n    }\n    \n    static void handleInterrupt() {\n        if (callback) callback();\n    }\n};\n\nAVRTimer1::TimerCallback AVRTimer1::callback = nullptr;\n\nISR(TIMER1_COMPA_vect) {\n    AVRTimer1::handleInterrupt();\n}\n#endif\n\n#ifdef ESP32\n// ESP32 Timer implementation\nclass ESP32Timer : public HardwareTimer {\nprivate:\n    hw_timer_t* timer = nullptr;\n    static void IRAM_ATTR onTimer() {\n        // Timer callback implementation\n    }\n    \npublic:\n    bool init(uint32_t frequencyHz, TimerCallback cb) override {\n        timer = timerBegin(0, 80, true);  // Timer 0, prescaler 80, count up\n        timerAttachInterrupt(timer, &onTimer, true);\n        timerAlarmWrite(timer, 1000000 / frequencyHz, true);\n        return true;\n    }\n    \n    void start() override {\n        timerAlarmEnable(timer);\n    }\n    \n    void stop() override {\n        timerAlarmDisable(timer);\n    }\n    \n    void setPeriod(uint32_t microseconds) override {\n        timerAlarmWrite(timer, microseconds, true);\n    }\n};\n#endif\n```\n\n### Software Timer Management\n\n```cpp\n// Efficient software timer system\ntemplate<size_t MAX_TIMERS>\nclass SoftwareTimerManager {\nprivate:\n    struct Timer {\n        uint32_t interval;\n        uint32_t nextTrigger;\n        void (*callback)();\n        bool active;\n        bool periodic;\n    };\n    \n    Timer timers[MAX_TIMERS];\n    uint32_t nextWakeTime;\n    \npublic:\n    SoftwareTimerManager() : nextWakeTime(UINT32_MAX) {\n        for (auto& timer : timers) {\n            timer.active = false;\n        }\n    }\n    \n    int createTimer(uint32_t intervalMs, void (*callback)(), bool periodic = true) {\n        for (int i = 0; i < MAX_TIMERS; i++) {\n            if (!timers[i].active) {\n                timers[i] = {intervalMs, millis() + intervalMs, callback, true, periodic};\n                updateNextWakeTime();\n                return i;\n            }\n        }\n        return -1;  // No free timers\n    }\n    \n    void deleteTimer(int id) {\n        if (id >= 0 && id < MAX_TIMERS) {\n            timers[id].active = false;\n            updateNextWakeTime();\n        }\n    }\n    \n    void process() {\n        uint32_t now = millis();\n        if ((int32_t)(now - nextWakeTime) < 0) return;\n        \n        nextWakeTime = UINT32_MAX;\n        \n        for (auto& timer : timers) {\n            if (!timer.active) continue;\n            \n            if ((int32_t)(now - timer.nextTrigger) >= 0) {\n                timer.callback();\n                \n                if (timer.periodic) {\n                    timer.nextTrigger += timer.interval;\n                } else {\n                    timer.active = false;\n                }\n            }\n            \n            if (timer.active && (int32_t)(timer.nextTrigger - nextWakeTime) < 0) {\n                nextWakeTime = timer.nextTrigger;\n            }\n        }\n    }\n    \n    uint32_t getNextWakeTime() const {\n        return nextWakeTime;\n    }\n    \nprivate:\n    void updateNextWakeTime() {\n        nextWakeTime = UINT32_MAX;\n        for (const auto& timer : timers) {\n            if (timer.active && (int32_t)(timer.nextTrigger - nextWakeTime) < 0) {\n                nextWakeTime = timer.nextTrigger;\n            }\n        }\n    }\n};\n```\n\n## Atomic Operations\n\n```cpp\n// Atomic operations for different data sizes\nclass AtomicOps {\npublic:\n    // 8-bit atomic read/write (naturally atomic on most MCUs)\n    static uint8_t read8(volatile uint8_t* ptr) {\n        return *ptr;\n    }\n    \n    static void write8(volatile uint8_t* ptr, uint8_t value) {\n        *ptr = value;\n    }\n    \n    // 16-bit atomic operations\n    static uint16_t read16(volatile uint16_t* ptr) {\n        CriticalSection cs;\n        return *ptr;\n    }\n    \n    static void write16(volatile uint16_t* ptr, uint16_t value) {\n        CriticalSection cs;\n        *ptr = value;\n    }\n    \n    // 32-bit atomic operations\n    static uint32_t read32(volatile uint32_t* ptr) {\n        CriticalSection cs;\n        return *ptr;\n    }\n    \n    static void write32(volatile uint32_t* ptr, uint32_t value) {\n        CriticalSection cs;\n        *ptr = value;\n    }\n    \n    // Atomic increment/decrement\n    static uint32_t increment(volatile uint32_t* ptr) {\n        CriticalSection cs;\n        return ++(*ptr);\n    }\n    \n    static uint32_t decrement(volatile uint32_t* ptr) {\n        CriticalSection cs;\n        return --(*ptr);\n    }\n    \n    // Compare and swap\n    static bool compareAndSwap(volatile uint32_t* ptr, uint32_t expected, uint32_t desired) {\n        CriticalSection cs;\n        if (*ptr == expected) {\n            *ptr = desired;\n            return true;\n        }\n        return false;\n    }\n    \n    // Atomic bit operations\n    static void setBit(volatile uint8_t* ptr, uint8_t bit) {\n        CriticalSection cs;\n        *ptr |= (1 << bit);\n    }\n    \n    static void clearBit(volatile uint8_t* ptr, uint8_t bit) {\n        CriticalSection cs;\n        *ptr &= ~(1 << bit);\n    }\n    \n    static bool testAndSetBit(volatile uint8_t* ptr, uint8_t bit) {\n        CriticalSection cs;\n        bool wasSet = (*ptr & (1 << bit)) != 0;\n        *ptr |= (1 << bit);\n        return wasSet;\n    }\n};\n\n// Lock-free single producer, single consumer queue\ntemplate<typename T, size_t SIZE>\nclass SPSCQueue {\n    static_assert((SIZE & (SIZE - 1)) == 0, \"Size must be power of 2\");\n    \nprivate:\n    T buffer[SIZE];\n    volatile size_t head = 0;\n    volatile size_t tail = 0;\n    \npublic:\n    bool push(const T& item) {\n        size_t next = (head + 1) & (SIZE - 1);\n        if (next == tail) return false;  // Full\n        \n        buffer[head] = item;\n        MEMORY_BARRIER();\n        head = next;\n        return true;\n    }\n    \n    bool pop(T& item) {\n        if (tail == head) return false;  // Empty\n        \n        item = buffer[tail];\n        MEMORY_BARRIER();\n        tail = (tail + 1) & (SIZE - 1);\n        return true;\n    }\n};\n```\n\n## Interrupt Priority Management\n\n```cpp\n// Platform-specific interrupt priority\nclass InterruptPriority {\npublic:\n    enum Priority {\n        LOWEST = 0,\n        LOW = 1,\n        NORMAL = 2,\n        HIGH = 3,\n        HIGHEST = 4,\n        CRITICAL = 5\n    };\n    \n    static void setPriority(uint8_t interruptNum, Priority priority) {\n        #ifdef ESP32\n        // ESP32 has 7 priority levels (1-7, where 1 is lowest)\n        esp_intr_set_priority(interruptNum, priority + 1);\n        #elif defined(STM32)\n        // STM32 NVIC priority setting\n        NVIC_SetPriority(static_cast<IRQn_Type>(interruptNum), \n                        15 - priority * 3);  // Map to 0-15 range\n        #endif\n        // AVR doesn't support interrupt priorities\n    }\n    \n    static void enableNested() {\n        #ifdef __AVR__\n        // AVR: Re-enable interrupts in ISR (use with caution!)\n        sei();\n        #elif defined(ESP32)\n        // ESP32: Already supports nested interrupts\n        #endif\n    }\n};\n\n// Priority inheritance mutex for ISR communication\nclass PriorityMutex {\nprivate:\n    volatile bool locked = false;\n    volatile uint8_t ownerPriority = 0;\n    \npublic:\n    bool tryLock(uint8_t priority) {\n        CriticalSection cs;\n        \n        if (!locked || priority > ownerPriority) {\n            locked = true;\n            ownerPriority = priority;\n            return true;\n        }\n        return false;\n    }\n    \n    void unlock() {\n        CriticalSection cs;\n        locked = false;\n        ownerPriority = 0;\n    }\n};\n```\n\n## Debouncing Patterns\n\n```cpp\n// Interrupt-driven debouncing\nclass InterruptDebouncer {\nprivate:\n    static constexpr uint8_t MAX_PINS = 8;\n    \n    struct PinState {\n        uint8_t pin;\n        volatile uint32_t lastChange;\n        volatile bool stableState;\n        volatile bool pendingState;\n        uint32_t debounceTime;\n        void (*callback)(bool state);\n        bool active;\n    };\n    \n    static PinState pins[MAX_PINS];\n    static volatile bool checkPending;\n    \npublic:\n    static void attach(uint8_t pin, void (*callback)(bool), uint32_t debounceMs = 20) {\n        for (auto& p : pins) {\n            if (!p.active) {\n                p = {pin, 0, digitalRead(pin), false, debounceMs, callback, true};\n                attachInterrupt(digitalPinToInterrupt(pin), handleInterrupt, CHANGE);\n                return;\n            }\n        }\n    }\n    \n    static void IRAM_ATTR handleInterrupt() {\n        uint32_t now = millis();\n        \n        for (auto& p : pins) {\n            if (p.active) {\n                bool currentState = digitalRead(p.pin);\n                if (currentState != p.stableState) {\n                    p.pendingState = currentState;\n                    p.lastChange = now;\n                    checkPending = true;\n                }\n            }\n        }\n    }\n    \n    static void process() {\n        if (!checkPending) return;\n        \n        uint32_t now = millis();\n        bool stillPending = false;\n        \n        for (auto& p : pins) {\n            if (p.active && p.pendingState != p.stableState) {\n                if (now - p.lastChange >= p.debounceTime) {\n                    p.stableState = p.pendingState;\n                    if (p.callback) {\n                        p.callback(p.stableState);\n                    }\n                } else {\n                    stillPending = true;\n                }\n            }\n        }\n        \n        checkPending = stillPending;\n    }\n};\n\nInterruptDebouncer::PinState InterruptDebouncer::pins[MAX_PINS];\nvolatile bool InterruptDebouncer::checkPending = false;\n```\n\n## Real-Time Scheduling\n\n```cpp\n// Rate Monotonic Scheduler (RMS)\nclass RateMonotonicScheduler {\nprivate:\n    struct Task {\n        void (*function)();\n        uint32_t period;\n        uint32_t deadline;\n        uint32_t lastRun;\n        uint32_t wcet;  // Worst Case Execution Time\n        uint8_t priority;\n        bool active;\n    };\n    \n    static constexpr size_t MAX_TASKS = 10;\n    Task tasks[MAX_TASKS];\n    \npublic:\n    RateMonotonicScheduler() {\n        for (auto& task : tasks) {\n            task.active = false;\n        }\n    }\n    \n    bool addTask(void (*func)(), uint32_t periodMs, uint32_t wcetMs) {\n        for (size_t i = 0; i < MAX_TASKS; i++) {\n            if (!tasks[i].active) {\n                tasks[i] = {func, periodMs, periodMs, 0, wcetMs, \n                           calculatePriority(periodMs), true};\n                return verifySchedulability();\n            }\n        }\n        return false;\n    }\n    \n    void execute() {\n        uint32_t now = millis();\n        \n        // Find highest priority ready task\n        Task* selectedTask = nullptr;\n        uint8_t highestPriority = 0;\n        \n        for (auto& task : tasks) {\n            if (!task.active) continue;\n            \n            if (now - task.lastRun >= task.period) {\n                if (task.priority > highestPriority) {\n                    highestPriority = task.priority;\n                    selectedTask = &task;\n                }\n            }\n        }\n        \n        if (selectedTask) {\n            uint32_t startTime = millis();\n            selectedTask->function();\n            uint32_t executionTime = millis() - startTime;\n            \n            selectedTask->lastRun = now;\n            \n            // Check deadline miss\n            if (executionTime > selectedTask->wcet) {\n                handleDeadlineMiss(selectedTask);\n            }\n        }\n    }\n    \nprivate:\n    uint8_t calculatePriority(uint32_t period) {\n        // Shorter period = higher priority (RMS)\n        if (period < 10) return 10;\n        if (period < 50) return 8;\n        if (period < 100) return 6;\n        if (period < 500) return 4;\n        if (period < 1000) return 2;\n        return 1;\n    }\n    \n    bool verifySchedulability() {\n        // Liu & Layland test for RMS\n        float utilization = 0;\n        size_t taskCount = 0;\n        \n        for (const auto& task : tasks) {\n            if (task.active) {\n                utilization += static_cast<float>(task.wcet) / task.period;\n                taskCount++;\n            }\n        }\n        \n        float bound = taskCount * (pow(2, 1.0/taskCount) - 1);\n        return utilization <= bound;\n    }\n    \n    void handleDeadlineMiss(Task* task) {\n        // Log or handle deadline miss\n        Serial.print(F(\"Deadline miss: \"));\n        Serial.println((uint32_t)task->function);\n    }\n};\n```\n\n## Watchdog Integration\n\n```cpp\n// Watchdog with ISR tracking\nclass WatchdogManager {\nprivate:\n    static volatile uint32_t lastFeed[8];\n    static const char* taskNames[8];\n    static uint8_t taskCount;\n    \npublic:\n    static void init(uint32_t timeoutMs) {\n        #ifdef __AVR__\n        // AVR watchdog setup\n        wdt_enable(WDTO_1S);  // Closest to timeoutMs\n        #elif defined(ESP32)\n        // ESP32 watchdog\n        esp_task_wdt_init(timeoutMs / 1000, true);\n        #endif\n    }\n    \n    static uint8_t registerTask(const char* name) {\n        if (taskCount < 8) {\n            taskNames[taskCount] = name;\n            lastFeed[taskCount] = millis();\n            return taskCount++;\n        }\n        return 255;  // Invalid ID\n    }\n    \n    static void feed(uint8_t taskId) {\n        if (taskId < taskCount) {\n            lastFeed[taskId] = millis();\n            \n            // Check if all tasks are alive\n            uint32_t now = millis();\n            bool allAlive = true;\n            \n            for (uint8_t i = 0; i < taskCount; i++) {\n                if (now - lastFeed[i] > 5000) {  // 5 second timeout\n                    allAlive = false;\n                    Serial.print(F(\"Task hung: \"));\n                    Serial.println(taskNames[i]);\n                }\n            }\n            \n            if (allAlive) {\n                #ifdef __AVR__\n                wdt_reset();\n                #elif defined(ESP32)\n                esp_task_wdt_reset();\n                #endif\n            }\n        }\n    }\n};\n\nvolatile uint32_t WatchdogManager::lastFeed[8];\nconst char* WatchdogManager::taskNames[8];\nuint8_t WatchdogManager::taskCount = 0;\n```\n\n## Best Practices Summary\n\n1. **Minimal ISRs**: Keep interrupt handlers as short as possible\n2. **Volatile Correctness**: Use volatile for all ISR-shared variables\n3. **Critical Sections**: Protect multi-byte operations and shared data\n4. **No Blocking**: Never use delays or wait loops in ISRs\n5. **Atomic Operations**: Use proper atomic operations for shared data\n6. **Priority Management**: Set appropriate interrupt priorities\n7. **Debouncing**: Implement proper debouncing for inputs\n8. **Timing Constraints**: Monitor and enforce ISR execution times\n9. **Watchdog Safety**: Integrate watchdog for system reliability\n10. **Real-Time Analysis**: Verify schedulability of time-critical tasks",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/src/**"
          ]
        },
        {
          "id": "key-architecture-patterns",
          "title": "Key Architecture Patterns",
          "fileName": "key-architecture-patterns.mdc",
          "frontmatter": {
            "description": "Key architectural patterns and design principles for embedded systems",
            "globs": [
              "**/src/**",
              "**/lib/**",
              "**/*.cpp",
              "**/*.h"
            ],
            "alwaysApply": true
          },
          "content": "# Key Architectural Patterns\n\n## Overview\n\nThis document outlines core architectural patterns for embedded systems development. These patterns ensure code maintainability, reliability, and efficiency while respecting the constraints of microcontroller environments.\n\n## State Machine Pattern\n\n### Finite State Machines (FSM)\n\nState machines are fundamental for organizing complex embedded system behavior into manageable, predictable states.\n\n```cpp\n// include/patterns/state_machine.h\n#pragma once\n#include <stdint.h>\n\n// Generic state machine framework\ntemplate<typename StateEnum, typename EventEnum>\nclass StateMachine {\npublic:\n    using StateHandler = void (StateMachine::*)();\n    using TransitionHandler = bool (StateMachine::*)(EventEnum);\n    \n    struct Transition {\n        StateEnum fromState;\n        EventEnum event;\n        StateEnum toState;\n        TransitionHandler guard;  // Optional guard condition\n    };\n    \nprotected:\n    StateEnum currentState;\n    StateEnum previousState;\n    StateHandler* stateHandlers;\n    const Transition* transitions;\n    size_t transitionCount;\n    \npublic:\n    StateMachine(StateEnum initial, StateHandler* handlers, \n                 const Transition* trans, size_t count)\n        : currentState(initial), previousState(initial),\n          stateHandlers(handlers), transitions(trans), \n          transitionCount(count) {}\n    \n    void update() {\n        // Execute current state handler\n        if (stateHandlers[static_cast<size_t>(currentState)]) {\n            (this->*stateHandlers[static_cast<size_t>(currentState)])();\n        }\n    }\n    \n    bool processEvent(EventEnum event) {\n        // Find matching transition\n        for (size_t i = 0; i < transitionCount; i++) {\n            const Transition& t = transitions[i];\n            if (t.fromState == currentState && t.event == event) {\n                // Check guard condition if present\n                if (t.guard && !(this->*t.guard)(event)) {\n                    continue;\n                }\n                \n                // Perform transition\n                previousState = currentState;\n                currentState = t.toState;\n                onTransition(previousState, currentState);\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    StateEnum getState() const { return currentState; }\n    StateEnum getPreviousState() const { return previousState; }\n    \nprotected:\n    virtual void onTransition(StateEnum from, StateEnum to) {}\n};\n\n// Example: LED Blinker State Machine\nclass LEDBlinker : public StateMachine<uint8_t, uint8_t> {\npublic:\n    // States\n    enum State : uint8_t {\n        OFF,\n        ON,\n        BLINKING\n    };\n    \n    // Events\n    enum Event : uint8_t {\n        TURN_ON,\n        TURN_OFF,\n        START_BLINK,\n        TIMER_EXPIRED\n    };\n    \nprivate:\n    static constexpr uint8_t LED_PIN = LED_BUILTIN;\n    uint32_t blinkInterval = 500;\n    uint32_t lastBlink = 0;\n    \n    // State handlers\n    void stateOff() {\n        digitalWrite(LED_PIN, LOW);\n    }\n    \n    void stateOn() {\n        digitalWrite(LED_PIN, HIGH);\n    }\n    \n    void stateBlinking() {\n        uint32_t now = millis();\n        if (now - lastBlink >= blinkInterval) {\n            lastBlink = now;\n            digitalWrite(LED_PIN, !digitalRead(LED_PIN));\n        }\n    }\n    \n    // State handler table\n    StateHandler handlers[3] = {\n        &LEDBlinker::stateOff,\n        &LEDBlinker::stateOn,\n        &LEDBlinker::stateBlinking\n    };\n    \n    // Transition table\n    static constexpr Transition transitionTable[] = {\n        {OFF, TURN_ON, ON, nullptr},\n        {OFF, START_BLINK, BLINKING, nullptr},\n        {ON, TURN_OFF, OFF, nullptr},\n        {ON, START_BLINK, BLINKING, nullptr},\n        {BLINKING, TURN_ON, ON, nullptr},\n        {BLINKING, TURN_OFF, OFF, nullptr}\n    };\n    \npublic:\n    LEDBlinker() : StateMachine(OFF, handlers, transitionTable, \n                                sizeof(transitionTable)/sizeof(Transition)) {\n        pinMode(LED_PIN, OUTPUT);\n    }\n    \n    void setBlinkInterval(uint32_t ms) { blinkInterval = ms; }\n};\n```\n\n### Hierarchical State Machines\n\nFor complex systems, hierarchical state machines provide better organization:\n\n```cpp\n// include/patterns/hsm.h\n#pragma once\n\n// Hierarchical State Machine base\ntemplate<typename StateEnum>\nclass HierarchicalStateMachine {\nprotected:\n    struct StateNode {\n        StateEnum state;\n        StateEnum parent;\n        void (HierarchicalStateMachine::*enter)();\n        void (HierarchicalStateMachine::*exit)();\n        void (HierarchicalStateMachine::*update)();\n    };\n    \n    const StateNode* states;\n    size_t stateCount;\n    StateEnum currentState;\n    \n    void transitionTo(StateEnum target) {\n        // Exit current state hierarchy\n        StateEnum state = currentState;\n        while (state != getCommonAncestor(currentState, target)) {\n            auto& node = findState(state);\n            if (node.exit) {\n                (this->*(node.exit))();\n            }\n            state = node.parent;\n        }\n        \n        // Enter target state hierarchy\n        enterState(target);\n        currentState = target;\n    }\n    \n    void enterState(StateEnum state) {\n        if (state == StateEnum(-1)) return;\n        \n        auto& node = findState(state);\n        enterState(node.parent);  // Recursive parent entry\n        \n        if (node.enter) {\n            (this->*(node.enter))();\n        }\n    }\n    \n    const StateNode& findState(StateEnum state) {\n        for (size_t i = 0; i < stateCount; i++) {\n            if (states[i].state == state) {\n                return states[i];\n            }\n        }\n        // Error handling in embedded: return safe default\n        return states[0];\n    }\n    \n    StateEnum getCommonAncestor(StateEnum a, StateEnum b) {\n        // Implementation to find common parent state\n        // Simplified for example\n        return StateEnum(-1);\n    }\n    \npublic:\n    HierarchicalStateMachine(const StateNode* stateArray, size_t count)\n        : states(stateArray), stateCount(count), currentState(StateEnum(0)) {}\n    \n    void update() {\n        auto& node = findState(currentState);\n        if (node.update) {\n            (this->*(node.update))();\n        }\n    }\n};\n```\n\n## Event-Driven Architecture\n\n### Event Queue Pattern\n\nNon-blocking event handling for responsive embedded systems:\n\n```cpp\n// include/patterns/event_system.h\n#pragma once\n#include <stdint.h>\n\n// Simple circular buffer for events\ntemplate<typename EventType, size_t QUEUE_SIZE>\nclass EventQueue {\nprivate:\n    EventType buffer[QUEUE_SIZE];\n    volatile size_t head;\n    volatile size_t tail;\n    \npublic:\n    EventQueue() : head(0), tail(0) {}\n    \n    bool push(const EventType& event) {\n        size_t next = (head + 1) % QUEUE_SIZE;\n        if (next == tail) {\n            return false;  // Queue full\n        }\n        \n        buffer[head] = event;\n        head = next;\n        return true;\n    }\n    \n    bool pop(EventType& event) {\n        if (tail == head) {\n            return false;  // Queue empty\n        }\n        \n        event = buffer[tail];\n        tail = (tail + 1) % QUEUE_SIZE;\n        return true;\n    }\n    \n    bool isEmpty() const {\n        return tail == head;\n    }\n    \n    size_t size() const {\n        if (head >= tail) {\n            return head - tail;\n        }\n        return QUEUE_SIZE - tail + head;\n    }\n};\n\n// Event dispatcher\ntemplate<typename EventEnum, size_t MAX_HANDLERS = 10>\nclass EventDispatcher {\npublic:\n    using EventHandler = void (*)(EventEnum event, void* data);\n    \nprivate:\n    struct HandlerEntry {\n        EventEnum event;\n        EventHandler handler;\n        bool active;\n    };\n    \n    HandlerEntry handlers[MAX_HANDLERS];\n    \npublic:\n    EventDispatcher() {\n        for (auto& h : handlers) {\n            h.active = false;\n        }\n    }\n    \n    bool subscribe(EventEnum event, EventHandler handler) {\n        for (auto& h : handlers) {\n            if (!h.active) {\n                h.event = event;\n                h.handler = handler;\n                h.active = true;\n                return true;\n            }\n        }\n        return false;  // No free slots\n    }\n    \n    bool unsubscribe(EventEnum event, EventHandler handler) {\n        for (auto& h : handlers) {\n            if (h.active && h.event == event && h.handler == handler) {\n                h.active = false;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    void dispatch(EventEnum event, void* data = nullptr) {\n        for (const auto& h : handlers) {\n            if (h.active && h.event == event) {\n                h.handler(event, data);\n            }\n        }\n    }\n};\n\n// Event-driven system example\nenum class SystemEvent : uint8_t {\n    BUTTON_PRESS,\n    BUTTON_RELEASE,\n    TIMER_TICK,\n    SENSOR_READING,\n    NETWORK_MESSAGE,\n    LOW_BATTERY\n};\n\nstruct Event {\n    SystemEvent type;\n    union {\n        uint32_t timestamp;\n        uint16_t sensorValue;\n        uint8_t buttonId;\n    } data;\n};\n\nclass EventDrivenSystem {\nprivate:\n    EventQueue<Event, 32> eventQueue;\n    EventDispatcher<SystemEvent> dispatcher;\n    \npublic:\n    void init() {\n        // Register event handlers\n        dispatcher.subscribe(SystemEvent::BUTTON_PRESS, \n            [](SystemEvent, void* data) {\n                // Handle button press\n            });\n            \n        dispatcher.subscribe(SystemEvent::LOW_BATTERY,\n            [](SystemEvent, void* data) {\n                // Enter low power mode\n            });\n    }\n    \n    void postEvent(const Event& event) {\n        // Thread-safe for ISR use\n        noInterrupts();\n        eventQueue.push(event);\n        interrupts();\n    }\n    \n    void processEvents() {\n        Event event;\n        while (eventQueue.pop(event)) {\n            dispatcher.dispatch(event.type, &event.data);\n        }\n    }\n};\n```\n\n## Task Scheduling Pattern\n\n### Cooperative Multitasking\n\nSimple task scheduler for non-preemptive multitasking:\n\n```cpp\n// include/patterns/task_scheduler.h\n#pragma once\n#include <functional>\n\nclass Task {\nprivate:\n    using TaskFunction = std::function<void()>;\n    \n    TaskFunction function;\n    uint32_t interval;\n    uint32_t lastRun;\n    bool enabled;\n    bool runOnce;\n    uint8_t priority;\n    \npublic:\n    Task(TaskFunction func, uint32_t intervalMs, uint8_t prio = 5)\n        : function(func), interval(intervalMs), lastRun(0),\n          enabled(false), runOnce(false), priority(prio) {}\n    \n    void enable() { \n        enabled = true; \n        lastRun = millis();\n    }\n    \n    void disable() { enabled = false; }\n    \n    void setInterval(uint32_t ms) { interval = ms; }\n    \n    void runOnceIn(uint32_t ms) {\n        interval = ms;\n        runOnce = true;\n        enable();\n    }\n    \n    bool isDue() const {\n        if (!enabled) return false;\n        return (millis() - lastRun) >= interval;\n    }\n    \n    void execute() {\n        if (!enabled) return;\n        \n        function();\n        lastRun = millis();\n        \n        if (runOnce) {\n            enabled = false;\n            runOnce = false;\n        }\n    }\n    \n    uint8_t getPriority() const { return priority; }\n};\n\ntemplate<size_t MAX_TASKS>\nclass TaskScheduler {\nprivate:\n    Task* tasks[MAX_TASKS];\n    size_t taskCount;\n    \npublic:\n    TaskScheduler() : taskCount(0) {}\n    \n    bool addTask(Task* task) {\n        if (taskCount >= MAX_TASKS) return false;\n        \n        tasks[taskCount++] = task;\n        \n        // Sort by priority\n        sortTasks();\n        return true;\n    }\n    \n    void execute() {\n        for (size_t i = 0; i < taskCount; i++) {\n            if (tasks[i]->isDue()) {\n                tasks[i]->execute();\n                \n                // Optional: yield to higher priority tasks\n                if (i < taskCount - 1 && tasks[i + 1]->getPriority() > tasks[i]->getPriority()) {\n                    break;\n                }\n            }\n        }\n    }\n    \nprivate:\n    void sortTasks() {\n        // Simple bubble sort (fine for small task counts)\n        for (size_t i = 0; i < taskCount - 1; i++) {\n            for (size_t j = 0; j < taskCount - i - 1; j++) {\n                if (tasks[j]->getPriority() < tasks[j + 1]->getPriority()) {\n                    Task* temp = tasks[j];\n                    tasks[j] = tasks[j + 1];\n                    tasks[j + 1] = temp;\n                }\n            }\n        }\n    }\n};\n\n// Usage example\nTaskScheduler<10> scheduler;\n\nTask sensorTask([]() {\n    // Read sensors\n}, 100, 8);  // High priority, 100ms interval\n\nTask displayTask([]() {\n    // Update display\n}, 500, 5);  // Medium priority, 500ms interval\n\nTask networkTask([]() {\n    // Check network\n}, 5000, 3);  // Low priority, 5s interval\n\nvoid setup() {\n    scheduler.addTask(&sensorTask);\n    scheduler.addTask(&displayTask);\n    scheduler.addTask(&networkTask);\n    \n    sensorTask.enable();\n    displayTask.enable();\n    networkTask.enable();\n}\n\nvoid loop() {\n    scheduler.execute();\n}\n```\n\n## Module System Pattern\n\n### Component-Based Architecture\n\nModular system design for maintainable embedded code:\n\n```cpp\n// include/patterns/module_system.h\n#pragma once\n\n// Base module interface\nclass Module {\nprotected:\n    const char* name;\n    bool initialized;\n    \npublic:\n    Module(const char* moduleName) \n        : name(moduleName), initialized(false) {}\n    \n    virtual bool init() = 0;\n    virtual void update() = 0;\n    virtual void shutdown() {\n        initialized = false;\n    }\n    \n    const char* getName() const { return name; }\n    bool isInitialized() const { return initialized; }\n};\n\n// Module manager\ntemplate<size_t MAX_MODULES>\nclass ModuleManager {\nprivate:\n    Module* modules[MAX_MODULES];\n    size_t moduleCount;\n    \npublic:\n    ModuleManager() : moduleCount(0) {}\n    \n    bool registerModule(Module* module) {\n        if (moduleCount >= MAX_MODULES) return false;\n        \n        modules[moduleCount++] = module;\n        return true;\n    }\n    \n    bool initializeAll() {\n        bool success = true;\n        \n        for (size_t i = 0; i < moduleCount; i++) {\n            Serial.print(F(\"Initializing \"));\n            Serial.print(modules[i]->getName());\n            Serial.print(F(\"... \"));\n            \n            if (modules[i]->init()) {\n                Serial.println(F(\"OK\"));\n            } else {\n                Serial.println(F(\"FAILED\"));\n                success = false;\n            }\n        }\n        \n        return success;\n    }\n    \n    void updateAll() {\n        for (size_t i = 0; i < moduleCount; i++) {\n            if (modules[i]->isInitialized()) {\n                modules[i]->update();\n            }\n        }\n    }\n    \n    void shutdownAll() {\n        for (size_t i = 0; i < moduleCount; i++) {\n            modules[i]->shutdown();\n        }\n    }\n    \n    Module* findModule(const char* name) {\n        for (size_t i = 0; i < moduleCount; i++) {\n            if (strcmp(modules[i]->getName(), name) == 0) {\n                return modules[i];\n            }\n        }\n        return nullptr;\n    }\n};\n\n// Example modules\nclass SensorModule : public Module {\nprivate:\n    float temperature;\n    float humidity;\n    uint32_t lastRead;\n    \npublic:\n    SensorModule() : Module(\"Sensors\"), temperature(0), humidity(0) {}\n    \n    bool init() override {\n        // Initialize sensors\n        initialized = true;\n        return true;\n    }\n    \n    void update() override {\n        if (millis() - lastRead > 2000) {\n            // Read sensors\n            lastRead = millis();\n        }\n    }\n    \n    float getTemperature() const { return temperature; }\n    float getHumidity() const { return humidity; }\n};\n\nclass NetworkModule : public Module {\nprivate:\n    bool connected;\n    \npublic:\n    NetworkModule() : Module(\"Network\"), connected(false) {}\n    \n    bool init() override {\n        // Initialize network\n        initialized = true;\n        return true;\n    }\n    \n    void update() override {\n        // Handle network tasks\n    }\n    \n    bool isConnected() const { return connected; }\n};\n```\n\n## Registry Pattern\n\n### Dynamic Component Registration\n\nFor systems that need runtime component discovery:\n\n```cpp\n// include/patterns/registry.h\n#pragma once\n#include <functional>\n\n// Generic registry for components\ntemplate<typename ComponentType, size_t MAX_COMPONENTS>\nclass Registry {\npublic:\n    using FactoryFunction = std::function<ComponentType*()>;\n    \nprivate:\n    struct Entry {\n        const char* name;\n        FactoryFunction factory;\n        bool active;\n    };\n    \n    Entry entries[MAX_COMPONENTS];\n    \npublic:\n    Registry() {\n        for (auto& entry : entries) {\n            entry.active = false;\n        }\n    }\n    \n    bool register(const char* name, FactoryFunction factory) {\n        for (auto& entry : entries) {\n            if (!entry.active) {\n                entry.name = name;\n                entry.factory = factory;\n                entry.active = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    ComponentType* create(const char* name) {\n        for (const auto& entry : entries) {\n            if (entry.active && strcmp(entry.name, name) == 0) {\n                return entry.factory();\n            }\n        }\n        return nullptr;\n    }\n    \n    void list(void (*callback)(const char*)) {\n        for (const auto& entry : entries) {\n            if (entry.active) {\n                callback(entry.name);\n            }\n        }\n    }\n};\n\n// Example: Sensor registry\nclass ISensor {\npublic:\n    virtual ~ISensor() = default;\n    virtual bool init() = 0;\n    virtual float read() = 0;\n    virtual const char* getType() = 0;\n};\n\nRegistry<ISensor, 10> sensorRegistry;\n\n// Self-registering sensor\nclass TemperatureSensor : public ISensor {\npublic:\n    bool init() override { return true; }\n    float read() override { return 25.0f; }\n    const char* getType() override { return \"Temperature\"; }\n    \n    // Static registration\n    static bool registered;\n    static bool registerSensor() {\n        return sensorRegistry.register(\"DS18B20\", []() -> ISensor* {\n            return new TemperatureSensor();\n        });\n    }\n};\n\nbool TemperatureSensor::registered = TemperatureSensor::registerSensor();\n```\n\n## Command Pattern\n\n### Command Processing System\n\nFor serial command interfaces and remote control:\n\n```cpp\n// include/patterns/command_system.h\n#pragma once\n\n// Command interface\nclass ICommand {\npublic:\n    virtual ~ICommand() = default;\n    virtual void execute(const char* args) = 0;\n    virtual const char* getName() = 0;\n    virtual const char* getHelp() = 0;\n};\n\n// Command processor\ntemplate<size_t MAX_COMMANDS>\nclass CommandProcessor {\nprivate:\n    ICommand* commands[MAX_COMMANDS];\n    size_t commandCount;\n    char buffer[128];\n    size_t bufferIndex;\n    \npublic:\n    CommandProcessor() : commandCount(0), bufferIndex(0) {}\n    \n    bool registerCommand(ICommand* cmd) {\n        if (commandCount >= MAX_COMMANDS) return false;\n        \n        commands[commandCount++] = cmd;\n        return true;\n    }\n    \n    void processChar(char c) {\n        if (c == '\\n' || c == '\\r') {\n            if (bufferIndex > 0) {\n                buffer[bufferIndex] = '\\0';\n                executeCommand(buffer);\n                bufferIndex = 0;\n            }\n        } else if (bufferIndex < sizeof(buffer) - 1) {\n            buffer[bufferIndex++] = c;\n        }\n    }\n    \n    void executeCommand(char* cmdLine) {\n        // Parse command and arguments\n        char* cmd = strtok(cmdLine, \" \");\n        if (!cmd) return;\n        \n        char* args = strtok(nullptr, \"\");\n        \n        // Find and execute command\n        for (size_t i = 0; i < commandCount; i++) {\n            if (strcmp(commands[i]->getName(), cmd) == 0) {\n                commands[i]->execute(args);\n                return;\n            }\n        }\n        \n        // Command not found\n        Serial.print(F(\"Unknown command: \"));\n        Serial.println(cmd);\n    }\n    \n    void printHelp() {\n        Serial.println(F(\"Available commands:\"));\n        for (size_t i = 0; i < commandCount; i++) {\n            Serial.print(F(\"  \"));\n            Serial.print(commands[i]->getName());\n            Serial.print(F(\" - \"));\n            Serial.println(commands[i]->getHelp());\n        }\n    }\n};\n\n// Example commands\nclass LEDCommand : public ICommand {\npublic:\n    void execute(const char* args) override {\n        if (strcmp(args, \"on\") == 0) {\n            digitalWrite(LED_BUILTIN, HIGH);\n            Serial.println(F(\"LED turned on\"));\n        } else if (strcmp(args, \"off\") == 0) {\n            digitalWrite(LED_BUILTIN, LOW);\n            Serial.println(F(\"LED turned off\"));\n        } else {\n            Serial.println(F(\"Usage: led [on|off]\"));\n        }\n    }\n    \n    const char* getName() override { return \"led\"; }\n    const char* getHelp() override { return \"Control the LED\"; }\n};\n\nclass StatusCommand : public ICommand {\npublic:\n    void execute(const char* args) override {\n        Serial.print(F(\"Uptime: \"));\n        Serial.print(millis() / 1000);\n        Serial.println(F(\" seconds\"));\n        \n        Serial.print(F(\"Free memory: \"));\n        Serial.print(freeMemory());\n        Serial.println(F(\" bytes\"));\n    }\n    \n    const char* getName() override { return \"status\"; }\n    const char* getHelp() override { return \"Show system status\"; }\n    \nprivate:\n    int freeMemory() {\n        extern int __heap_start, *__brkval;\n        int v;\n        return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);\n    }\n};\n```\n\n## Observer Pattern\n\n### Event Notification System\n\n```cpp\n// include/patterns/observer.h\n#pragma once\n\ntemplate<typename EventData, size_t MAX_OBSERVERS = 8>\nclass Subject {\npublic:\n    using Observer = void (*)(const EventData&);\n    \nprivate:\n    Observer observers[MAX_OBSERVERS];\n    size_t observerCount;\n    \npublic:\n    Subject() : observerCount(0) {}\n    \n    bool attach(Observer observer) {\n        if (observerCount >= MAX_OBSERVERS) return false;\n        \n        // Prevent duplicate registration\n        for (size_t i = 0; i < observerCount; i++) {\n            if (observers[i] == observer) return true;\n        }\n        \n        observers[observerCount++] = observer;\n        return true;\n    }\n    \n    bool detach(Observer observer) {\n        for (size_t i = 0; i < observerCount; i++) {\n            if (observers[i] == observer) {\n                // Shift remaining observers\n                for (size_t j = i; j < observerCount - 1; j++) {\n                    observers[j] = observers[j + 1];\n                }\n                observerCount--;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    void notify(const EventData& data) {\n        // Iterate backwards to allow safe detachment during notification\n        for (int i = observerCount - 1; i >= 0; i--) {\n            observers[i](data);\n        }\n    }\n};\n\n// Example usage\nstruct TemperatureData {\n    float celsius;\n    uint32_t timestamp;\n};\n\nSubject<TemperatureData> temperatureSubject;\n\nvoid onTemperatureChange(const TemperatureData& data) {\n    if (data.celsius > 30.0f) {\n        // Turn on cooling\n    }\n}\n\nvoid setup() {\n    temperatureSubject.attach(onTemperatureChange);\n    temperatureSubject.attach([](const TemperatureData& data) {\n        // Log temperature\n        Serial.print(F(\"Temperature: \"));\n        Serial.println(data.celsius);\n    });\n}\n```\n\n## Best Practices Summary\n\n1. **State Machines**: Use for complex behavior management\n2. **Event-Driven**: Prefer events over polling for responsiveness\n3. **Task Scheduling**: Implement cooperative multitasking for concurrent operations\n4. **Modular Design**: Create independent, reusable modules\n5. **Registry Pattern**: Enable runtime component discovery\n6. **Command Pattern**: Implement flexible control interfaces\n7. **Observer Pattern**: Decouple components with notifications\n8. **Memory Efficiency**: Use static allocation and templates\n9. **Type Safety**: Leverage compile-time checks\n10. **Documentation**: Document architectural decisions and patterns",
          "alwaysApply": true,
          "globs": [
            "**/src/**",
            "**/lib/**",
            "**/*.cpp",
            "**/*.h"
          ]
        },
        {
          "id": "logging-guidelines",
          "title": "Logging Guidelines",
          "fileName": "logging-guidelines.mdc",
          "frontmatter": {
            "description": "Logging guidelines and patterns for resource-constrained embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/src/**"
            ],
            "alwaysApply": true
          },
          "content": "# Logging Guidelines\n\n## Philosophy\n\n**‚ö†Ô∏è IMPORTANT: Only add logs when explicitly requested. By default, do NOT add logs.**\n\nLogging in embedded systems must balance debugging needs with severe resource constraints. Every byte of RAM and every CPU cycle matters. Production systems should have minimal or no logging to maximize performance and reliability.\n\n## Conditional Compilation\n\n### Debug Levels\n\n```cpp\n// Define debug levels in platformio.ini or build flags\n// -D DEBUG_LEVEL=0  // No debugging (production)\n// -D DEBUG_LEVEL=1  // Errors only\n// -D DEBUG_LEVEL=2  // Errors and warnings\n// -D DEBUG_LEVEL=3  // Errors, warnings, and info\n// -D DEBUG_LEVEL=4  // Everything including debug\n\n#ifndef DEBUG_LEVEL\n  #define DEBUG_LEVEL 0  // Default to no debugging\n#endif\n\n// Logging macros that compile out based on level\n#if DEBUG_LEVEL >= 1\n  #define LOG_ERROR(msg, ...) Serial.printf_P(PSTR(\"[ERROR] \" msg \"\\n\"), ##__VA_ARGS__)\n#else\n  #define LOG_ERROR(msg, ...) ((void)0)\n#endif\n\n#if DEBUG_LEVEL >= 2\n  #define LOG_WARN(msg, ...) Serial.printf_P(PSTR(\"[WARN] \" msg \"\\n\"), ##__VA_ARGS__)\n#else\n  #define LOG_WARN(msg, ...) ((void)0)\n#endif\n\n#if DEBUG_LEVEL >= 3\n  #define LOG_INFO(msg, ...) Serial.printf_P(PSTR(\"[INFO] \" msg \"\\n\"), ##__VA_ARGS__)\n#else\n  #define LOG_INFO(msg, ...) ((void)0)\n#endif\n\n#if DEBUG_LEVEL >= 4\n  #define LOG_DEBUG(msg, ...) Serial.printf_P(PSTR(\"[DEBUG] \" msg \"\\n\"), ##__VA_ARGS__)\n#else\n  #define LOG_DEBUG(msg, ...) ((void)0)\n#endif\n```\n\n### Feature-Specific Debug Flags\n\n```cpp\n// Fine-grained control over logging\n// Define in platformio.ini: -D DEBUG_SENSORS=1 -D DEBUG_NETWORK=0\n\n#ifdef DEBUG_SENSORS\n  #define LOG_SENSOR(msg, ...) LOG_DEBUG(\"[SENSOR] \" msg, ##__VA_ARGS__)\n#else\n  #define LOG_SENSOR(msg, ...) ((void)0)\n#endif\n\n#ifdef DEBUG_NETWORK\n  #define LOG_NET(msg, ...) LOG_DEBUG(\"[NET] \" msg, ##__VA_ARGS__)\n#else\n  #define LOG_NET(msg, ...) ((void)0)\n#endif\n\n#ifdef DEBUG_STATE\n  #define LOG_STATE(msg, ...) LOG_DEBUG(\"[STATE] \" msg, ##__VA_ARGS__)\n#else\n  #define LOG_STATE(msg, ...) ((void)0)\n#endif\n\n// Usage\nvoid readSensor() {\n  LOG_SENSOR(\"Reading temperature sensor\");\n  float temp = sensor.read();\n  LOG_SENSOR(\"Temperature: %.2f¬∞C\", temp);\n}\n```\n\n## Memory-Efficient Logging\n\n### PROGMEM String Storage\n\n```cpp\n// Store format strings in program memory\n#define LOG_P(level, msg, ...) \\\n  do { \\\n    if (DEBUG_LEVEL >= level) { \\\n      static const char fmt[] PROGMEM = msg; \\\n      char buf[64]; \\\n      snprintf_P(buf, sizeof(buf), fmt, ##__VA_ARGS__); \\\n      Serial.print(F(\"[\" #level \"] \")); \\\n      Serial.println(buf); \\\n    } \\\n  } while(0)\n\n// Centralized string storage\nnamespace LogStrings {\n  const char INIT_START[] PROGMEM = \"System initialization started\";\n  const char INIT_DONE[] PROGMEM = \"System initialization complete\";\n  const char SENSOR_ERROR[] PROGMEM = \"Sensor error: %s\";\n  const char MEMORY_LOW[] PROGMEM = \"Low memory: %u bytes free\";\n  const char NETWORK_CONNECTED[] PROGMEM = \"Network connected: %s\";\n}\n\n// Usage\nLOG_INFO(LogStrings::INIT_START);\nLOG_ERROR(LogStrings::SENSOR_ERROR, sensor.getErrorString());\n```\n\n### Minimal Logger Class\n\n```cpp\n// Lightweight logger with compile-time optimization\nclass Logger {\nprivate:\n  static constexpr size_t BUFFER_SIZE = 80;\n  char buffer_[BUFFER_SIZE];\n  Stream* output_;\n  bool enabled_;\n  \npublic:\n  enum Level {\n    ERROR = 1,\n    WARN = 2,\n    INFO = 3,\n    DEBUG = 4\n  };\n  \n  explicit Logger(Stream* output = &Serial) \n      : output_(output), enabled_(DEBUG_LEVEL > 0) {}\n  \n  template<typename... Args>\n  void log(Level level, const __FlashStringHelper* format, Args... args) {\n    if (!enabled_ || level > DEBUG_LEVEL) return;\n    \n    // Print timestamp\n    output_->print(F(\"[\"));\n    output_->print(millis());\n    output_->print(F(\"] \"));\n    \n    // Print level\n    output_->print(getLevelString(level));\n    output_->print(F(\" \"));\n    \n    // Print message\n    snprintf_P(buffer_, BUFFER_SIZE, \n               reinterpret_cast<const char*>(format), args...);\n    output_->println(buffer_);\n  }\n  \n  void setEnabled(bool enabled) { enabled_ = enabled && (DEBUG_LEVEL > 0); }\n  \nprivate:\n  const __FlashStringHelper* getLevelString(Level level) {\n    switch (level) {\n      case ERROR: return F(\"[ERROR]\");\n      case WARN:  return F(\"[WARN]\");\n      case INFO:  return F(\"[INFO]\");\n      case DEBUG: return F(\"[DEBUG]\");\n      default:    return F(\"[?]\");\n    }\n  }\n};\n\n// Global logger instance (only if debugging enabled)\n#if DEBUG_LEVEL > 0\n  Logger logger(&Serial);\n#endif\n\n// Convenience macros\n#if DEBUG_LEVEL > 0\n  #define LOG(level, format, ...) logger.log(Logger::level, F(format), ##__VA_ARGS__)\n#else\n  #define LOG(level, format, ...) ((void)0)\n#endif\n```\n\n## Performance-Aware Logging\n\n### Non-Blocking Serial Output\n\n```cpp\n// Asynchronous logger to prevent blocking\ntemplate<size_t QUEUE_SIZE = 256>\nclass AsyncLogger {\nprivate:\n  struct LogEntry {\n    uint32_t timestamp;\n    uint8_t level;\n    char message[48];  // Fixed size for simplicity\n  };\n  \n  LogEntry queue_[QUEUE_SIZE];\n  volatile uint8_t head_ = 0;\n  volatile uint8_t tail_ = 0;\n  Stream* output_;\n  \npublic:\n  explicit AsyncLogger(Stream* output) : output_(output) {}\n  \n  // Called from anywhere (including ISR)\n  void logAsync(uint8_t level, const char* msg) {\n    uint8_t next = (head_ + 1) % QUEUE_SIZE;\n    if (next == tail_) return;  // Queue full, drop message\n    \n    LogEntry& entry = queue_[head_];\n    entry.timestamp = millis();\n    entry.level = level;\n    strncpy(entry.message, msg, sizeof(entry.message) - 1);\n    entry.message[sizeof(entry.message) - 1] = '\\0';\n    \n    head_ = next;\n  }\n  \n  // Called from main loop\n  void process() {\n    while (tail_ != head_) {\n      const LogEntry& entry = queue_[tail_];\n      \n      output_->print('[');\n      output_->print(entry.timestamp);\n      output_->print(F(\"] \"));\n      output_->print(getLevelChar(entry.level));\n      output_->print(' ');\n      output_->println(entry.message);\n      \n      tail_ = (tail_ + 1) % QUEUE_SIZE;\n    }\n  }\n  \nprivate:\n  char getLevelChar(uint8_t level) {\n    switch (level) {\n      case 1: return 'E';\n      case 2: return 'W';\n      case 3: return 'I';\n      case 4: return 'D';\n      default: return '?';\n    }\n  }\n};\n\n#if DEBUG_LEVEL > 0\n  AsyncLogger<128> asyncLog(&Serial);\n#endif\n```\n\n### Rate-Limited Logging\n\n```cpp\n// Prevent log spam from high-frequency events\nclass RateLimitedLogger {\nprivate:\n  struct LogSlot {\n    uint32_t lastLog;\n    uint32_t count;\n    uint32_t hash;\n  };\n  \n  static constexpr size_t MAX_SLOTS = 8;\n  LogSlot slots_[MAX_SLOTS];\n  uint32_t minInterval_;\n  \npublic:\n  explicit RateLimitedLogger(uint32_t minIntervalMs = 1000)\n      : minInterval_(minIntervalMs) {\n    memset(slots_, 0, sizeof(slots_));\n  }\n  \n  bool shouldLog(const char* message) {\n    uint32_t hash = calculateHash(message);\n    uint32_t now = millis();\n    \n    // Find or create slot\n    LogSlot* slot = findSlot(hash);\n    if (!slot) {\n      // No free slots, use oldest\n      slot = &slots_[0];\n      for (size_t i = 1; i < MAX_SLOTS; i++) {\n        if (slots_[i].lastLog < slot->lastLog) {\n          slot = &slots_[i];\n        }\n      }\n      slot->hash = hash;\n      slot->count = 0;\n    }\n    \n    // Check rate limit\n    if (now - slot->lastLog >= minInterval_) {\n      if (slot->count > 0) {\n        // Log suppression count\n        Serial.print(F(\"[Suppressed \"));\n        Serial.print(slot->count);\n        Serial.println(F(\" similar messages]\"));\n      }\n      \n      slot->lastLog = now;\n      slot->count = 0;\n      return true;\n    }\n    \n    slot->count++;\n    return false;\n  }\n  \nprivate:\n  uint32_t calculateHash(const char* str) {\n    uint32_t hash = 5381;\n    while (*str) {\n      hash = ((hash << 5) + hash) + *str++;\n    }\n    return hash;\n  }\n  \n  LogSlot* findSlot(uint32_t hash) {\n    for (size_t i = 0; i < MAX_SLOTS; i++) {\n      if (slots_[i].hash == hash) {\n        return &slots_[i];\n      }\n    }\n    return nullptr;\n  }\n};\n\n// Usage\n#if DEBUG_LEVEL > 0\n  RateLimitedLogger rateLimiter(5000);  // Max once per 5 seconds\n  \n  #define LOG_RATE_LIMITED(msg) \\\n    do { \\\n      if (rateLimiter.shouldLog(msg)) { \\\n        Serial.println(F(msg)); \\\n      } \\\n    } while(0)\n#else\n  #define LOG_RATE_LIMITED(msg) ((void)0)\n#endif\n```\n\n## Structured Logging\n\n### Binary Logging\n\n```cpp\n// Compact binary logging for data analysis\nclass BinaryLogger {\npublic:\n  enum EventType : uint8_t {\n    SYSTEM_START = 0x01,\n    SENSOR_READ = 0x02,\n    ERROR_OCCURRED = 0x03,\n    STATE_CHANGE = 0x04,\n    // ... up to 255 event types\n  };\n  \n  struct LogPacket {\n    uint32_t timestamp;\n    uint8_t type;\n    uint8_t data[11];  // Total 16 bytes\n  } __attribute__((packed));\n  \n  static void logEvent(EventType type, const void* data = nullptr, size_t len = 0) {\n    #if DEBUG_LEVEL > 0\n    LogPacket packet;\n    packet.timestamp = millis();\n    packet.type = type;\n    \n    if (data && len > 0) {\n      memcpy(packet.data, data, min(len, sizeof(packet.data)));\n    } else {\n      memset(packet.data, 0, sizeof(packet.data));\n    }\n    \n    // Send as binary\n    Serial.write(reinterpret_cast<uint8_t*>(&packet), sizeof(packet));\n    #endif\n  }\n  \n  // Specific event loggers\n  static void logSensorReading(uint8_t sensorId, float value) {\n    struct {\n      uint8_t id;\n      float value;\n    } __attribute__((packed)) data = {sensorId, value};\n    \n    logEvent(SENSOR_READ, &data, sizeof(data));\n  }\n  \n  static void logError(ErrorCode code, uint16_t location) {\n    struct {\n      int8_t code;\n      uint16_t location;\n    } __attribute__((packed)) data = {static_cast<int8_t>(code), location};\n    \n    logEvent(ERROR_OCCURRED, &data, sizeof(data));\n  }\n};\n```\n\n### JSON Logging (for WiFi-enabled devices)\n\n```cpp\n#ifdef HAS_WIFI\n// Structured JSON logging for network transmission\nclass JsonLogger {\nprivate:\n  static constexpr size_t BUFFER_SIZE = 256;\n  char buffer_[BUFFER_SIZE];\n  \npublic:\n  void logJson(const char* event, const char* level = \"INFO\") {\n    // Build JSON manually to avoid ArduinoJson overhead\n    snprintf(buffer_, BUFFER_SIZE,\n             \"{\\\"t\\\":%lu,\\\"e\\\":\\\"%s\\\",\\\"l\\\":\\\"%s\\\",\\\"m\\\":%u}\",\n             millis(), event, level, ESP.getFreeHeap());\n    \n    // Send over network or serial\n    sendLog(buffer_);\n  }\n  \n  template<typename T>\n  void logMetric(const char* metric, T value) {\n    snprintf(buffer_, BUFFER_SIZE,\n             \"{\\\"t\\\":%lu,\\\"m\\\":\\\"%s\\\",\\\"v\\\":\",\n             millis(), metric);\n    \n    // Type-specific formatting\n    size_t len = strlen(buffer_);\n    if constexpr (std::is_floating_point_v<T>) {\n      dtostrf(value, 0, 2, buffer_ + len);\n    } else {\n      snprintf(buffer_ + len, BUFFER_SIZE - len, \"%d\", value);\n    }\n    \n    strcat(buffer_, \"}\");\n    sendLog(buffer_);\n  }\n  \nprivate:\n  void sendLog(const char* json) {\n    // Send via UDP, MQTT, or HTTP\n    #ifdef DEBUG_NETWORK\n    udpClient.beginPacket(logServerIP, logServerPort);\n    udpClient.print(json);\n    udpClient.endPacket();\n    #endif\n    \n    // Also log to serial in debug mode\n    #if DEBUG_LEVEL >= 3\n    Serial.println(json);\n    #endif\n  }\n};\n#endif\n```\n\n## Production Logging\n\n### Minimal Error Logging\n\n```cpp\n// Production systems should only log critical errors\n#ifdef PRODUCTION_BUILD\n  #undef DEBUG_LEVEL\n  #define DEBUG_LEVEL 1  // Errors only\n  \n  // Ultra-minimal error logger\n  class ProductionLogger {\n  private:\n    static constexpr size_t ERROR_HISTORY = 8;\n    struct ErrorRecord {\n      uint32_t timestamp;\n      int8_t code;\n    } errors_[ERROR_HISTORY];\n    uint8_t errorIndex_ = 0;\n    \n  public:\n    void logError(ErrorCode code) {\n      errors_[errorIndex_] = {millis(), static_cast<int8_t>(code)};\n      errorIndex_ = (errorIndex_ + 1) % ERROR_HISTORY;\n      \n      // Blink LED pattern for error\n      blinkErrorCode(code);\n    }\n    \n    // Dump errors on request (maintenance mode)\n    void dumpErrors(Stream& output) {\n      output.println(F(\"Error History:\"));\n      for (size_t i = 0; i < ERROR_HISTORY; i++) {\n        if (errors_[i].timestamp > 0) {\n          output.print(errors_[i].timestamp);\n          output.print(F(\": \"));\n          output.println(errors_[i].code);\n        }\n      }\n    }\n    \n  private:\n    void blinkErrorCode(ErrorCode code) {\n      // Visual indication without serial output\n      uint8_t blinks = abs(static_cast<int8_t>(code));\n      for (uint8_t i = 0; i < blinks; i++) {\n        digitalWrite(LED_BUILTIN, HIGH);\n        delay(200);\n        digitalWrite(LED_BUILTIN, LOW);\n        delay(200);\n      }\n    }\n  };\n#endif\n```\n\n### Telemetry Logging\n\n```cpp\n// Minimal telemetry for production monitoring\nclass TelemetryLogger {\nprivate:\n  struct Metrics {\n    uint32_t uptime;\n    uint16_t freeMemory;\n    uint8_t cpuUsage;\n    int8_t temperature;\n    uint16_t errorCount;\n    uint8_t resetReason;\n  } __attribute__((packed));\n  \n  Metrics metrics_;\n  uint32_t lastReport_ = 0;\n  \npublic:\n  void update() {\n    metrics_.uptime = millis() / 1000;  // Seconds\n    metrics_.freeMemory = getFreeMemory();\n    metrics_.cpuUsage = getCPUUsage();\n    metrics_.temperature = readInternalTemp();\n    // metrics_.errorCount incremented by error handler\n    \n    // Report periodically\n    if (millis() - lastReport_ > 300000) {  // Every 5 minutes\n      report();\n      lastReport_ = millis();\n    }\n  }\n  \n  void incrementErrorCount() {\n    if (metrics_.errorCount < UINT16_MAX) {\n      metrics_.errorCount++;\n    }\n  }\n  \nprivate:\n  void report() {\n    #ifdef HAS_NETWORK\n    // Send binary packet\n    sendTelemetry(&metrics_, sizeof(metrics_));\n    #else\n    // Store in EEPROM for later retrieval\n    EEPROM.put(TELEMETRY_ADDR, metrics_);\n    #endif\n  }\n  \n  uint16_t getFreeMemory() {\n    // Platform-specific implementation\n    return 0;\n  }\n  \n  uint8_t getCPUUsage() {\n    // Estimate based on idle time\n    return 0;\n  }\n  \n  int8_t readInternalTemp() {\n    // Read MCU temperature if available\n    return 25;  // Default\n  }\n};\n```\n\n## Debug Commands\n\n### Interactive Debug Shell\n\n```cpp\n#if DEBUG_LEVEL >= 3\n// Debug command interface\nclass DebugShell {\nprivate:\n  struct Command {\n    const char* name;\n    void (*handler)(const char* args);\n    const char* help;\n  };\n  \n  static constexpr Command commands[] = {\n    {\"help\", cmdHelp, \"Show this help\"},\n    {\"status\", cmdStatus, \"Show system status\"},\n    {\"mem\", cmdMemory, \"Show memory usage\"},\n    {\"log\", cmdSetLogLevel, \"Set log level (0-4)\"},\n    {\"reset\", cmdReset, \"Reset system\"},\n    {\"dump\", cmdDumpLog, \"Dump error log\"},\n  };\n  \npublic:\n  static void process() {\n    if (Serial.available()) {\n      static char cmdBuffer[32];\n      static uint8_t cmdIndex = 0;\n      \n      char c = Serial.read();\n      if (c == '\\n' || c == '\\r') {\n        cmdBuffer[cmdIndex] = '\\0';\n        executeCommand(cmdBuffer);\n        cmdIndex = 0;\n      } else if (cmdIndex < sizeof(cmdBuffer) - 1) {\n        cmdBuffer[cmdIndex++] = c;\n      }\n    }\n  }\n  \nprivate:\n  static void executeCommand(char* cmd) {\n    char* cmdName = strtok(cmd, \" \");\n    char* args = strtok(nullptr, \"\");\n    \n    for (const auto& command : commands) {\n      if (strcmp(cmdName, command.name) == 0) {\n        command.handler(args);\n        return;\n      }\n    }\n    \n    Serial.println(F(\"Unknown command. Type 'help' for help.\"));\n  }\n  \n  static void cmdHelp(const char* args) {\n    Serial.println(F(\"\\nDebug Commands:\"));\n    for (const auto& cmd : commands) {\n      Serial.print(F(\"  \"));\n      Serial.print(cmd.name);\n      Serial.print(F(\" - \"));\n      Serial.println(cmd.help);\n    }\n  }\n  \n  static void cmdStatus(const char* args) {\n    Serial.println(F(\"\\nSystem Status:\"));\n    Serial.print(F(\"Uptime: \"));\n    Serial.println(millis() / 1000);\n    Serial.print(F(\"Free RAM: \"));\n    Serial.println(getFreeMemory());\n    // Add more status info\n  }\n  \n  static void cmdSetLogLevel(const char* args) {\n    if (args) {\n      int level = atoi(args);\n      // Runtime log level adjustment if supported\n      Serial.print(F(\"Log level set to: \"));\n      Serial.println(level);\n    }\n  }\n};\n#endif\n```\n\n## Best Practices Summary\n\n1. **Production = No Logs**: Default to no logging in production builds\n2. **Compile-Time Control**: Use DEBUG_LEVEL to completely remove log code\n3. **PROGMEM Strings**: Store all log strings in program memory\n4. **Non-Blocking**: Never block on serial output\n5. **Rate Limiting**: Prevent log spam from high-frequency events\n6. **Binary Logging**: Use compact binary format for data logging\n7. **Error History**: Keep minimal error history for diagnostics\n8. **Visual Indicators**: Use LEDs for production error indication\n9. **Conditional Features**: Enable detailed logging only during development\n10. **Memory Awareness**: Monitor and limit memory usage from logging",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/src/**"
          ]
        },
        {
          "id": "memory-management-patterns",
          "title": "Memory Management Patterns",
          "fileName": "memory-management-patterns.mdc",
          "frontmatter": {
            "description": "Memory management patterns and best practices for resource-constrained embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/src/**"
            ],
            "alwaysApply": true
          },
          "content": "# Memory Management Patterns\n\n## Overview\n\nMemory is one of the most critical resources in embedded systems. This document provides patterns and guidelines for efficient memory usage, avoiding common pitfalls, and ensuring reliable operation within tight memory constraints.\n\n## Memory Architecture\n\n### Understanding Memory Regions\n\n```cpp\n/*\n * Typical Memory Layout (AVR Example):\n * \n * Flash (Program Memory):\n * ‚îú‚îÄ‚îÄ .text     - Code\n * ‚îú‚îÄ‚îÄ .rodata   - Constants\n * ‚îî‚îÄ‚îÄ .progmem  - PROGMEM data\n * \n * SRAM:\n * ‚îú‚îÄ‚îÄ .data     - Initialized variables\n * ‚îú‚îÄ‚îÄ .bss      - Uninitialized variables\n * ‚îú‚îÄ‚îÄ Heap ‚Üì    - Dynamic allocation (grows down)\n * ‚îú‚îÄ‚îÄ ‚Üê Free ‚Üí\n * ‚îî‚îÄ‚îÄ Stack ‚Üë   - Function calls (grows up)\n * \n * EEPROM:\n * ‚îî‚îÄ‚îÄ Persistent storage\n */\n\n// Memory size detection\n#ifdef ARDUINO_AVR_UNO\n    constexpr size_t FLASH_SIZE = 32768;   // 32KB\n    constexpr size_t SRAM_SIZE = 2048;     // 2KB\n    constexpr size_t EEPROM_SIZE = 1024;   // 1KB\n#elif defined(ESP32)\n    constexpr size_t FLASH_SIZE = 4194304;  // 4MB typical\n    constexpr size_t SRAM_SIZE = 520192;    // ~520KB\n    constexpr size_t PSRAM_SIZE = 0;        // Optional\n#elif defined(STM32F103xB)\n    constexpr size_t FLASH_SIZE = 131072;   // 128KB\n    constexpr size_t SRAM_SIZE = 20480;     // 20KB\n#endif\n```\n\n## Static Memory Allocation\n\n### Prefer Stack Over Heap\n\n```cpp\n// ‚ùå BAD - Dynamic allocation\nvoid processData() {\n    int* buffer = new int[100];  // Heap allocation\n    // ... use buffer ...\n    delete[] buffer;  // Must remember to free\n}\n\n// ‚ùå BAD - Using String class\nString message = \"Hello \";\nmessage += \"World\";  // Multiple allocations\n\n// ‚úÖ GOOD - Stack allocation\nvoid processData() {\n    int buffer[100];  // Stack allocation\n    // ... use buffer ...\n    // Automatically cleaned up\n}\n\n// ‚úÖ GOOD - Fixed-size character arrays\nchar message[32];\nstrcpy(message, \"Hello \");\nstrcat(message, \"World\");  // No allocation\n```\n\n### Compile-Time Memory Allocation\n\n```cpp\n// Template-based buffer sizing\ntemplate<size_t SIZE>\nclass StaticBuffer {\nprivate:\n    uint8_t data[SIZE];\n    size_t length;\n    \npublic:\n    StaticBuffer() : length(0) {}\n    \n    bool write(const uint8_t* src, size_t len) {\n        if (length + len > SIZE) return false;\n        \n        memcpy(&data[length], src, len);\n        length += len;\n        return true;\n    }\n    \n    void clear() { length = 0; }\n    size_t size() const { return length; }\n    size_t capacity() const { return SIZE; }\n    const uint8_t* getData() const { return data; }\n};\n\n// Usage with compile-time size\nStaticBuffer<256> txBuffer;\nStaticBuffer<64> cmdBuffer;\n```\n\n## PROGMEM Usage\n\n### Storing Constants in Flash\n\n```cpp\n// String constants in PROGMEM\nconst char welcomeMsg[] PROGMEM = \"Welcome to Embedded System v1.0\";\nconst char errorMsg[] PROGMEM = \"Error: Invalid command\";\n\n// String table in PROGMEM\nconst char* const stringTable[] PROGMEM = {\n    welcomeMsg,\n    errorMsg\n};\n\n// Accessing PROGMEM strings\nvoid printProgmemString(const char* str) {\n    char buffer[64];\n    strcpy_P(buffer, str);  // Copy from PROGMEM to RAM\n    Serial.println(buffer);\n}\n\n// F() macro for immediate use (AVR only)\nSerial.println(F(\"This string stays in flash\"));\n\n// Large data arrays in PROGMEM\nconst uint8_t lookupTable[256] PROGMEM = {\n    0x00, 0x01, 0x02, 0x03, // ... etc\n};\n\n// Accessing PROGMEM data\nuint8_t getValue(uint8_t index) {\n    return pgm_read_byte(&lookupTable[index]);\n}\n\n// Structures in PROGMEM\nstruct ConfigData {\n    uint16_t version;\n    uint32_t baudRate;\n    uint8_t deviceId;\n};\n\nconst ConfigData defaultConfig PROGMEM = {\n    .version = 0x0100,\n    .baudRate = 115200,\n    .deviceId = 0x01\n};\n\n// Reading structure from PROGMEM\nConfigData readConfig() {\n    ConfigData config;\n    memcpy_P(&config, &defaultConfig, sizeof(ConfigData));\n    return config;\n}\n```\n\n### PROGMEM Best Practices\n\n```cpp\n// Centralized string storage\nnamespace Strings {\n    const char STARTUP[] PROGMEM = \"System starting...\";\n    const char READY[] PROGMEM = \"Ready\";\n    const char ERROR_MEMORY[] PROGMEM = \"Out of memory\";\n    const char ERROR_TIMEOUT[] PROGMEM = \"Operation timeout\";\n}\n\n// Helper class for PROGMEM strings\nclass ProgmemString {\nprivate:\n    const char* ptr;\n    \npublic:\n    ProgmemString(const char* p) : ptr(p) {}\n    \n    void print() {\n        char c;\n        while ((c = pgm_read_byte(ptr++)) != 0) {\n            Serial.write(c);\n        }\n    }\n    \n    size_t length() {\n        return strlen_P(ptr);\n    }\n    \n    void copyTo(char* buffer, size_t maxLen) {\n        strncpy_P(buffer, ptr, maxLen - 1);\n        buffer[maxLen - 1] = '\\0';\n    }\n};\n```\n\n## Memory Pools\n\n### Fixed-Size Block Allocation\n\n```cpp\n// Memory pool for fixed-size allocations\ntemplate<typename T, size_t POOL_SIZE>\nclass MemoryPool {\nprivate:\n    union Block {\n        T data;\n        Block* next;\n    };\n    \n    Block pool[POOL_SIZE];\n    Block* freeList;\n    \npublic:\n    MemoryPool() {\n        // Initialize free list\n        freeList = &pool[0];\n        for (size_t i = 0; i < POOL_SIZE - 1; i++) {\n            pool[i].next = &pool[i + 1];\n        }\n        pool[POOL_SIZE - 1].next = nullptr;\n    }\n    \n    T* allocate() {\n        if (!freeList) return nullptr;\n        \n        Block* block = freeList;\n        freeList = freeList->next;\n        return &block->data;\n    }\n    \n    void deallocate(T* ptr) {\n        if (!ptr) return;\n        \n        Block* block = reinterpret_cast<Block*>(ptr);\n        block->next = freeList;\n        freeList = block;\n    }\n    \n    size_t available() const {\n        size_t count = 0;\n        Block* current = freeList;\n        while (current) {\n            count++;\n            current = current->next;\n        }\n        return count;\n    }\n};\n\n// Usage example\nstruct Message {\n    uint8_t type;\n    uint8_t length;\n    uint8_t data[30];\n};\n\nMemoryPool<Message, 10> messagePool;\n\nMessage* allocateMessage() {\n    return messagePool.allocate();\n}\n\nvoid freeMessage(Message* msg) {\n    messagePool.deallocate(msg);\n}\n```\n\n## Ring Buffers\n\n### Efficient Circular Buffers\n\n```cpp\n// Lock-free ring buffer for ISR communication\ntemplate<typename T, size_t SIZE>\nclass RingBuffer {\n    static_assert((SIZE & (SIZE - 1)) == 0, \"Size must be power of 2\");\n    \nprivate:\n    T buffer[SIZE];\n    volatile size_t head;\n    volatile size_t tail;\n    \npublic:\n    RingBuffer() : head(0), tail(0) {}\n    \n    bool push(const T& item) {\n        size_t next = (head + 1) & (SIZE - 1);\n        if (next == tail) return false;  // Full\n        \n        buffer[head] = item;\n        head = next;\n        return true;\n    }\n    \n    bool pop(T& item) {\n        if (head == tail) return false;  // Empty\n        \n        item = buffer[tail];\n        tail = (tail + 1) & (SIZE - 1);\n        return true;\n    }\n    \n    bool isEmpty() const {\n        return head == tail;\n    }\n    \n    bool isFull() const {\n        return ((head + 1) & (SIZE - 1)) == tail;\n    }\n    \n    size_t size() const {\n        return (head - tail) & (SIZE - 1);\n    }\n    \n    size_t available() const {\n        return SIZE - 1 - size();\n    }\n    \n    // Peek without removing\n    bool peek(T& item) const {\n        if (head == tail) return false;\n        item = buffer[tail];\n        return true;\n    }\n};\n\n// Specialized byte buffer for serial communication\nclass SerialBuffer {\nprivate:\n    static constexpr size_t BUFFER_SIZE = 256;  // Power of 2\n    uint8_t buffer[BUFFER_SIZE];\n    volatile uint8_t head;\n    volatile uint8_t tail;\n    \npublic:\n    SerialBuffer() : head(0), tail(0) {}\n    \n    // ISR-safe push\n    void push(uint8_t data) {\n        uint8_t next = (head + 1) & (BUFFER_SIZE - 1);\n        if (next != tail) {\n            buffer[head] = data;\n            head = next;\n        }\n    }\n    \n    // Main loop pop\n    int pop() {\n        if (head == tail) return -1;\n        \n        uint8_t data = buffer[tail];\n        tail = (tail + 1) & (BUFFER_SIZE - 1);\n        return data;\n    }\n    \n    size_t available() const {\n        return (head - tail) & (BUFFER_SIZE - 1);\n    }\n};\n```\n\n## String Handling\n\n### Safe String Operations\n\n```cpp\n// Safe string utilities\nclass SafeString {\npublic:\n    // Safe string copy with size limit\n    static void copy(char* dest, const char* src, size_t destSize) {\n        if (destSize == 0) return;\n        \n        size_t i;\n        for (i = 0; i < destSize - 1 && src[i] != '\\0'; i++) {\n            dest[i] = src[i];\n        }\n        dest[i] = '\\0';\n    }\n    \n    // Safe string concatenation\n    static void concat(char* dest, const char* src, size_t destSize) {\n        size_t destLen = strlen(dest);\n        if (destLen >= destSize - 1) return;\n        \n        copy(dest + destLen, src, destSize - destLen);\n    }\n    \n    // Safe formatted string\n    template<typename... Args>\n    static void format(char* dest, size_t destSize, const char* format, Args... args) {\n        snprintf(dest, destSize, format, args...);\n        dest[destSize - 1] = '\\0';  // Ensure null termination\n    }\n    \n    // Integer to string conversion without allocation\n    static void itoa(int value, char* buffer, size_t bufferSize) {\n        if (bufferSize == 0) return;\n        \n        bool negative = value < 0;\n        if (negative) value = -value;\n        \n        size_t pos = 0;\n        do {\n            if (pos >= bufferSize - 1) break;\n            buffer[pos++] = '0' + (value % 10);\n            value /= 10;\n        } while (value > 0);\n        \n        if (negative && pos < bufferSize - 1) {\n            buffer[pos++] = '-';\n        }\n        \n        buffer[pos] = '\\0';\n        \n        // Reverse the string\n        for (size_t i = 0; i < pos / 2; i++) {\n            char temp = buffer[i];\n            buffer[i] = buffer[pos - 1 - i];\n            buffer[pos - 1 - i] = temp;\n        }\n    }\n};\n\n// String builder without dynamic allocation\ntemplate<size_t CAPACITY>\nclass StringBuilder {\nprivate:\n    char buffer[CAPACITY];\n    size_t length;\n    \npublic:\n    StringBuilder() : length(0) {\n        buffer[0] = '\\0';\n    }\n    \n    StringBuilder& append(const char* str) {\n        size_t strLen = strlen(str);\n        size_t available = CAPACITY - length - 1;\n        size_t toCopy = (strLen < available) ? strLen : available;\n        \n        memcpy(buffer + length, str, toCopy);\n        length += toCopy;\n        buffer[length] = '\\0';\n        \n        return *this;\n    }\n    \n    StringBuilder& append(char c) {\n        if (length < CAPACITY - 1) {\n            buffer[length++] = c;\n            buffer[length] = '\\0';\n        }\n        return *this;\n    }\n    \n    StringBuilder& append(int value) {\n        char temp[12];  // Enough for 32-bit int\n        SafeString::itoa(value, temp, sizeof(temp));\n        return append(temp);\n    }\n    \n    const char* toString() const { return buffer; }\n    size_t size() const { return length; }\n    void clear() { length = 0; buffer[0] = '\\0'; }\n};\n```\n\n## Stack Usage Monitoring\n\n### Stack Overflow Prevention\n\n```cpp\n// Stack canary implementation\nclass StackMonitor {\nprivate:\n    static constexpr uint32_t CANARY_VALUE = 0xDEADBEEF;\n    uint32_t canary;\n    \npublic:\n    StackMonitor() : canary(CANARY_VALUE) {}\n    \n    ~StackMonitor() {\n        if (canary != CANARY_VALUE) {\n            // Stack corruption detected!\n            // Take appropriate action (reset, log, etc.)\n            while (true) {\n                digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n                delay(100);  // Fast blink indicates error\n            }\n        }\n    }\n    \n    bool isValid() const {\n        return canary == CANARY_VALUE;\n    }\n};\n\n// Stack usage estimation\nint getFreeStackSize() {\n    #ifdef __AVR__\n    extern int __heap_start, *__brkval;\n    int v;\n    return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);\n    #elif defined(ESP32)\n    return uxTaskGetStackHighWaterMark(NULL);\n    #else\n    return -1;  // Not implemented for this platform\n    #endif\n}\n\n// Function to paint stack for usage analysis\nvoid paintStack(uint8_t pattern = 0xA5) {\n    uint8_t dummy;\n    uint8_t* start = &dummy;\n    \n    // Paint downward (typical stack growth direction)\n    for (int i = 1; i < 200; i++) {\n        *(start - i) = pattern;\n    }\n}\n\n// Check how much stack was used\nsize_t checkStackUsage(uint8_t pattern = 0xA5) {\n    uint8_t dummy;\n    uint8_t* start = &dummy;\n    \n    size_t used = 0;\n    for (int i = 1; i < 200; i++) {\n        if (*(start - i) != pattern) {\n            used = i;\n        }\n    }\n    \n    return used;\n}\n```\n\n## Memory-Efficient Data Structures\n\n### Bit-Packed Structures\n\n```cpp\n// Bit fields for memory efficiency\nstruct SensorReading {\n    uint16_t temperature : 10;  // -512 to 511 (0.1¬∞C resolution)\n    uint16_t humidity : 7;      // 0 to 100%\n    uint16_t pressure : 10;     // 0 to 1023 hPa\n    uint16_t battery : 5;       // 0 to 31 (0.1V steps)\n} __attribute__((packed));\n\n// Bit vector for flags\ntemplate<size_t N>\nclass BitVector {\nprivate:\n    static constexpr size_t BYTES = (N + 7) / 8;\n    uint8_t bits[BYTES];\n    \npublic:\n    BitVector() {\n        memset(bits, 0, BYTES);\n    }\n    \n    void set(size_t index, bool value = true) {\n        if (index >= N) return;\n        \n        size_t byte = index / 8;\n        size_t bit = index % 8;\n        \n        if (value) {\n            bits[byte] |= (1 << bit);\n        } else {\n            bits[byte] &= ~(1 << bit);\n        }\n    }\n    \n    bool get(size_t index) const {\n        if (index >= N) return false;\n        \n        size_t byte = index / 8;\n        size_t bit = index % 8;\n        \n        return (bits[byte] & (1 << bit)) != 0;\n    }\n    \n    void clear() {\n        memset(bits, 0, BYTES);\n    }\n    \n    size_t count() const {\n        size_t count = 0;\n        for (size_t i = 0; i < BYTES; i++) {\n            count += __builtin_popcount(bits[i]);\n        }\n        return count;\n    }\n};\n\n// Usage: 100 flags in just 13 bytes\nBitVector<100> deviceFlags;\n```\n\n### Compressed Data Storage\n\n```cpp\n// Simple compression for repetitive data\nclass RunLengthEncoder {\npublic:\n    // Encode data with run-length encoding\n    static size_t encode(const uint8_t* input, size_t inputLen, \n                        uint8_t* output, size_t outputMax) {\n        size_t outPos = 0;\n        size_t inPos = 0;\n        \n        while (inPos < inputLen && outPos < outputMax - 1) {\n            uint8_t value = input[inPos];\n            uint8_t count = 1;\n            \n            // Count consecutive same values\n            while (inPos + count < inputLen && \n                   count < 255 && \n                   input[inPos + count] == value) {\n                count++;\n            }\n            \n            // Write count and value\n            if (outPos + 2 <= outputMax) {\n                output[outPos++] = count;\n                output[outPos++] = value;\n                inPos += count;\n            } else {\n                break;\n            }\n        }\n        \n        return outPos;\n    }\n    \n    // Decode run-length encoded data\n    static size_t decode(const uint8_t* input, size_t inputLen,\n                        uint8_t* output, size_t outputMax) {\n        size_t outPos = 0;\n        size_t inPos = 0;\n        \n        while (inPos < inputLen - 1 && outPos < outputMax) {\n            uint8_t count = input[inPos++];\n            uint8_t value = input[inPos++];\n            \n            for (uint8_t i = 0; i < count && outPos < outputMax; i++) {\n                output[outPos++] = value;\n            }\n        }\n        \n        return outPos;\n    }\n};\n```\n\n## Memory Allocation Tracking\n\n### Debug Memory Usage\n\n```cpp\n#ifdef DEBUG_MEMORY\nclass MemoryTracker {\nprivate:\n    struct AllocationInfo {\n        void* ptr;\n        size_t size;\n        const char* file;\n        int line;\n    };\n    \n    static AllocationInfo allocations[50];\n    static size_t allocationCount;\n    static size_t totalAllocated;\n    \npublic:\n    static void* allocate(size_t size, const char* file, int line) {\n        void* ptr = malloc(size);\n        if (ptr && allocationCount < 50) {\n            allocations[allocationCount++] = {ptr, size, file, line};\n            totalAllocated += size;\n        }\n        return ptr;\n    }\n    \n    static void deallocate(void* ptr) {\n        for (size_t i = 0; i < allocationCount; i++) {\n            if (allocations[i].ptr == ptr) {\n                totalAllocated -= allocations[i].size;\n                // Remove from list\n                for (size_t j = i; j < allocationCount - 1; j++) {\n                    allocations[j] = allocations[j + 1];\n                }\n                allocationCount--;\n                break;\n            }\n        }\n        free(ptr);\n    }\n    \n    static void report() {\n        Serial.print(F(\"Memory allocations: \"));\n        Serial.println(allocationCount);\n        Serial.print(F(\"Total allocated: \"));\n        Serial.println(totalAllocated);\n        \n        for (size_t i = 0; i < allocationCount; i++) {\n            Serial.print(F(\"  \"));\n            Serial.print(allocations[i].size);\n            Serial.print(F(\" bytes at \"));\n            Serial.print(allocations[i].file);\n            Serial.print(F(\":\"));\n            Serial.println(allocations[i].line);\n        }\n    }\n};\n\n// Debug macros\n#define DEBUG_NEW(size) MemoryTracker::allocate(size, __FILE__, __LINE__)\n#define DEBUG_DELETE(ptr) MemoryTracker::deallocate(ptr)\n\n#else\n#define DEBUG_NEW(size) malloc(size)\n#define DEBUG_DELETE(ptr) free(ptr)\n#endif\n```\n\n## Best Practices Summary\n\n1. **Avoid Dynamic Allocation**: Use stack and global variables\n2. **Use PROGMEM**: Store constants in flash memory\n3. **Fixed-Size Buffers**: Prefer compile-time sizing\n4. **Memory Pools**: Use for predictable allocation patterns\n5. **Ring Buffers**: Implement efficient circular buffers\n6. **String Safety**: Never use String class, use char arrays\n7. **Monitor Stack**: Implement stack overflow detection\n8. **Bit Packing**: Use bit fields for compact storage\n9. **Track Usage**: Monitor memory in debug builds\n10. **Platform Awareness**: Consider platform-specific constraints",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/src/**"
          ]
        },
        {
          "id": "no-hiding",
          "title": "No Hiding",
          "fileName": "no-hiding.mdc",
          "frontmatter": {
            "description": "Critical rule - never hide compiler warnings or errors in embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/*.hpp",
              "**/platformio.ini"
            ],
            "alwaysApply": true
          },
          "content": "# No Hiding Rule\n\n## Critical Principle\n\n**NEVER hide compiler warnings or errors. All warnings must be treated as errors and fully resolved.**\n\nIn embedded systems, compiler warnings often indicate serious issues that can lead to:\n- Memory corruption\n- Undefined behavior\n- Race conditions\n- Hardware failures\n- System crashes\n\nHiding warnings is dangerous and unacceptable. Every warning must be understood and fixed.\n\n## Compiler Warnings as Errors\n\n### PlatformIO Configuration\n\n```ini\n; platformio.ini\n[env]\nbuild_flags = \n    -Wall                    ; Enable all warnings\n    -Wextra                  ; Enable extra warnings\n    -Werror                  ; Treat warnings as errors\n    -Wpedantic               ; Strict ISO C++ compliance\n    -Wconversion             ; Warn about implicit conversions\n    -Wsign-conversion        ; Warn about sign conversions\n    -Wunused                 ; Warn about unused variables/functions\n    -Wshadow                 ; Warn about shadowed variables\n    -Wcast-qual              ; Warn about casting away qualifiers\n    -Wformat=2               ; Strict format string checking\n    -Wstrict-overflow=5     ; Warn about overflow assumptions\n```\n\n### Common Warning Categories\n\n```cpp\n// ‚ùå BAD - Implicit conversion warning\nuint8_t value = 500;  // Warning: conversion from 'int' to 'uint8_t'\n\n// ‚úÖ GOOD - Explicit conversion\nuint8_t value = static_cast<uint8_t>(500);\n\n// ‚ùå BAD - Unused variable warning\nvoid processData(uint8_t* data, size_t length) {\n  uint8_t temp = data[0];  // Warning: unused variable\n  // ...\n}\n\n// ‚úÖ GOOD - Remove unused variable or use it\nvoid processData(uint8_t* data, size_t length) {\n  if (data[0] == 0) {  // Use the value\n    return;\n  }\n  // ...\n}\n\n// ‚ùå BAD - Sign comparison warning\nint8_t value = -10;\nif (value < 0) {  // Warning: comparison of signed and unsigned\n  // ...\n}\n\n// ‚úÖ GOOD - Explicit comparison\nint8_t value = -10;\nif (value < static_cast<int8_t>(0)) {\n  // ...\n}\n\n// ‚ùå BAD - Uninitialized variable warning\nuint8_t count;\nfor (uint8_t i = 0; i < 10; i++) {\n  count++;  // Warning: 'count' may be used uninitialized\n}\n\n// ‚úÖ GOOD - Initialize variable\nuint8_t count = 0;\nfor (uint8_t i = 0; i < 10; i++) {\n  count++;\n}\n```\n\n## Never Suppress Warnings\n\n### ‚ùå BAD - Warning Suppression\n\n```cpp\n// NEVER do this\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\nuint8_t unused = 0;\n#pragma GCC diagnostic pop\n\n// NEVER do this\n#pragma GCC diagnostic ignored \"-Wconversion\"\nuint8_t value = 500;\n\n// NEVER do this\n(void)unusedVariable;  // Suppress unused warning\n\n// NEVER do this in platformio.ini\nbuild_unflags = -Werror  // Remove -Werror\n```\n\n### ‚úÖ GOOD - Fix the Underlying Issue\n\n```cpp\n// Fix unused variable by removing it or using it\nvoid processData(uint8_t* data, size_t length) {\n  // Remove unused variable\n  // Or use it: validateData(data, length);\n}\n\n// Fix conversion warning with explicit cast\nuint8_t value = static_cast<uint8_t>(500);\n\n// Fix uninitialized variable\nuint8_t count = 0;  // Initialize properly\n```\n\n## Type Safety Warnings\n\n```cpp\n// ‚ùå BAD - Implicit narrowing conversion\nuint8_t buffer[256];\nint index = 300;\nbuffer[index] = 0;  // Warning: array index out of bounds\n\n// ‚úÖ GOOD - Validate bounds\nuint8_t buffer[256];\nint index = 300;\nif (index >= 0 && index < 256) {\n  buffer[index] = 0;\n}\n\n// ‚ùå BAD - Pointer type mismatch\nuint8_t* data = (uint8_t*)malloc(100);  // Warning: C-style cast\n\n// ‚úÖ GOOD - Use C++ cast\nuint8_t* data = static_cast<uint8_t*>(malloc(100));\n// Or better: avoid malloc entirely\nuint8_t data[100];  // Static allocation\n```\n\n## Format String Warnings\n\n```cpp\n// ‚ùå BAD - Format string mismatch\nuint8_t value = 100;\nSerial.printf(\"Value: %d\\n\", value);  // Warning: format expects int\n\n// ‚úÖ GOOD - Correct format specifier\nuint8_t value = 100;\nSerial.printf(\"Value: %u\\n\", value);  // %u for unsigned\n\n// ‚ùå BAD - Missing format arguments\nSerial.printf(\"Value: %d\\n\");  // Warning: format expects argument\n\n// ‚úÖ GOOD - Provide all arguments\nSerial.printf(\"Value: %d\\n\", value);\n```\n\n## Unused Parameter Warnings\n\n```cpp\n// ‚ùå BAD - Suppress unused parameter\nvoid callback(uint8_t pin) {\n  (void)pin;  // Suppress warning\n}\n\n// ‚úÖ GOOD - Remove parameter name if unused\nvoid callback(uint8_t /* pin */) {\n  // Parameter intentionally unused\n}\n\n// ‚úÖ GOOD - Use parameter\nvoid callback(uint8_t pin) {\n  if (pin < NUM_DIGITAL_PINS) {\n    // Use the parameter\n  }\n}\n\n// ‚úÖ GOOD - Mark as unused with attribute\nvoid callback([[maybe_unused]] uint8_t pin) {\n  // C++17 attribute for intentionally unused\n}\n```\n\n## Shadowing Warnings\n\n```cpp\n// ‚ùå BAD - Variable shadowing\nclass Sensor {\nprivate:\n  uint8_t pin_;\n  \npublic:\n  void setPin(uint8_t pin) {\n    uint8_t pin = pin_;  // Warning: 'pin' shadows member 'pin_'\n  }\n};\n\n// ‚úÖ GOOD - Use different name\nclass Sensor {\nprivate:\n  uint8_t pin_;\n  \npublic:\n  void setPin(uint8_t pin) {\n    pin_ = pin;  // No shadowing\n  }\n};\n```\n\n## Strict Aliasing Warnings\n\n```cpp\n// ‚ùå BAD - Violates strict aliasing\nfloat value = 1.0f;\nuint32_t* ptr = (uint32_t*)&value;  // Warning: strict aliasing\n*ptr = 0x3F800000;\n\n// ‚úÖ GOOD - Use union for type punning\nunion FloatInt {\n  float f;\n  uint32_t i;\n};\n\nFloatInt fi;\nfi.f = 1.0f;\nfi.i = 0x3F800000;\n```\n\n## Overflow Warnings\n\n```cpp\n// ‚ùå BAD - Potential overflow\nuint8_t a = 200;\nuint8_t b = 100;\nuint8_t sum = a + b;  // Warning: overflow in addition\n\n// ‚úÖ GOOD - Check for overflow\nuint8_t a = 200;\nuint8_t b = 100;\nuint16_t sum = static_cast<uint16_t>(a) + b;\nif (sum > 255) {\n  // Handle overflow\n  sum = 255;\n}\nuint8_t result = static_cast<uint8_t>(sum);\n```\n\n## Return Value Warnings\n\n```cpp\n// ‚ùå BAD - Missing return statement\nint getValue() {\n  if (condition) {\n    return 10;\n  }\n  // Warning: control reaches end of non-void function\n}\n\n// ‚úÖ GOOD - Always return a value\nint getValue() {\n  if (condition) {\n    return 10;\n  }\n  return 0;  // Default return\n}\n\n// ‚ùå BAD - Unused return value\nreadSensor();  // Warning: ignoring return value\n\n// ‚úÖ GOOD - Check return value\nif (readSensor() != ErrorCode::OK) {\n  handleError();\n}\n```\n\n## PlatformIO Build Configuration\n\n```ini\n; platformio.ini - Strict warning configuration\n[env]\nbuild_flags = \n    ; Enable all warnings\n    -Wall\n    -Wextra\n    -Wpedantic\n    \n    ; Treat warnings as errors\n    -Werror\n    \n    ; Specific warning categories\n    -Wconversion\n    -Wsign-conversion\n    -Wunused\n    -Wunused-variable\n    -Wunused-function\n    -Wunused-parameter\n    -Wshadow\n    -Wcast-qual\n    -Wformat=2\n    -Wformat-security\n    -Wstrict-overflow=5\n    -Warray-bounds\n    -Wmaybe-uninitialized\n    \n    ; C++ specific\n    -Wold-style-cast\n    -Woverloaded-virtual\n    -Wnon-virtual-dtor\n    \n    ; Platform-specific\n    -Wno-unknown-pragmas  ; Only if necessary for platform compatibility\n\n; NEVER use build_unflags to remove warnings\n; build_unflags = -Werror  ; ‚ùå NEVER DO THIS\n```\n\n## Static Analysis\n\n### Additional Tools\n\n```ini\n; Enable static analysis in platformio.ini\n[env]\ncheck_tool = cppcheck\ncheck_flags = \n    --enable=all\n    --suppress=missingIncludeSystem\n    --suppress=unusedFunction\n```\n\n### Manual Checks\n\n```bash\n# Run static analysis\npio check\n\n# Check for specific issues\npio check --pattern=\"*warning*\"\n\n# Never ignore check results\n# Fix all issues before committing\n```\n\n## Code Review Checklist\n\nWhen reviewing code, ensure:\n\n- [ ] No `#pragma` directives suppressing warnings\n- [ ] No `(void)variable` casts to suppress warnings\n- [ ] No `build_unflags` removing warning flags\n- [ ] All compiler warnings are resolved\n- [ ] All static analysis warnings are addressed\n- [ ] Type conversions are explicit\n- [ ] Return values are checked\n- [ ] Variables are initialized\n- [ ] Format strings match arguments\n- [ ] No shadowing of variables\n\n## Best Practices Summary\n\n1. **Treat Warnings as Errors**: Use `-Werror` flag\n2. **Enable All Warnings**: Use `-Wall -Wextra -Wpedantic`\n3. **Fix, Don't Suppress**: Address root cause, never hide warnings\n4. **Explicit Conversions**: Use static_cast, not C-style casts\n5. **Initialize Variables**: Always initialize before use\n6. **Check Return Values**: Never ignore function return values\n7. **Validate Bounds**: Check array bounds and buffer sizes\n8. **Type Safety**: Use correct types and format specifiers\n9. **No Suppression**: Never use pragmas or casts to suppress warnings\n10. **Code Review**: Verify no warnings are hidden in reviews",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/*.hpp",
            "**/platformio.ini"
          ]
        },
        {
          "id": "performance-guidelines",
          "title": "Performance Guidelines",
          "fileName": "performance-guidelines.mdc",
          "frontmatter": {
            "description": "Performance optimization techniques and best practices for embedded systems",
            "globs": [
              "**/*.cpp",
              "**/*.c",
              "**/*.h",
              "**/src/**"
            ],
            "alwaysApply": true
          },
          "content": "# Performance Guidelines\n\n## Overview\n\nPerformance optimization in embedded systems requires balancing execution speed, memory usage, power consumption, and code size. This document provides techniques for achieving optimal performance while maintaining code readability and reliability.\n\n## Performance Measurement\n\n### Timing and Profiling\n\n```cpp\n// Microsecond-precision timing\nclass PerformanceTimer {\nprivate:\n    uint32_t startTime;\n    const char* name;\n    \npublic:\n    PerformanceTimer(const char* timerName) : name(timerName) {\n        startTime = micros();\n    }\n    \n    ~PerformanceTimer() {\n        uint32_t elapsed = micros() - startTime;\n        Serial.print(F(\"Timer [\"));\n        Serial.print(name);\n        Serial.print(F(\"]: \"));\n        Serial.print(elapsed);\n        Serial.println(F(\" us\"));\n    }\n    \n    uint32_t elapsed() const {\n        return micros() - startTime;\n    }\n};\n\n// Usage\nvoid someFunction() {\n    PerformanceTimer timer(\"someFunction\");\n    // ... function body ...\n    // Timer automatically prints on exit\n}\n\n// Manual timing macros\n#define TIMING_START() uint32_t _timing_start = micros()\n#define TIMING_END(name) \\\n    do { \\\n        uint32_t _elapsed = micros() - _timing_start; \\\n        Serial.print(F(\"Timing \" name \": \")); \\\n        Serial.print(_elapsed); \\\n        Serial.println(F(\" us\")); \\\n    } while(0)\n\n// Cycle counting (platform specific)\n#ifdef ESP32\n    #include \"esp32/rom/ets_sys.h\"\n    #define GET_CYCLE_COUNT() esp_cpu_get_ccount()\n#elif defined(__arm__)\n    #define GET_CYCLE_COUNT() SysTick->VAL\n#else\n    #define GET_CYCLE_COUNT() 0\n#endif\n```\n\n### Performance Profiling Framework\n\n```cpp\n// Simple profiler for embedded systems\nclass Profiler {\nprivate:\n    struct ProfileData {\n        const char* name;\n        uint32_t callCount;\n        uint32_t totalTime;\n        uint32_t minTime;\n        uint32_t maxTime;\n    };\n    \n    static constexpr size_t MAX_PROFILES = 20;\n    static ProfileData profiles[MAX_PROFILES];\n    static size_t profileCount;\n    \npublic:\n    class ScopedTimer {\n    private:\n        ProfileData* data;\n        uint32_t startTime;\n        \n    public:\n        ScopedTimer(const char* name) {\n            data = findOrCreate(name);\n            startTime = micros();\n        }\n        \n        ~ScopedTimer() {\n            uint32_t elapsed = micros() - startTime;\n            data->callCount++;\n            data->totalTime += elapsed;\n            \n            if (elapsed < data->minTime) data->minTime = elapsed;\n            if (elapsed > data->maxTime) data->maxTime = elapsed;\n        }\n        \n    private:\n        static ProfileData* findOrCreate(const char* name) {\n            // Find existing\n            for (size_t i = 0; i < profileCount; i++) {\n                if (strcmp(profiles[i].name, name) == 0) {\n                    return &profiles[i];\n                }\n            }\n            \n            // Create new\n            if (profileCount < MAX_PROFILES) {\n                profiles[profileCount] = {\n                    name, 0, 0, UINT32_MAX, 0\n                };\n                return &profiles[profileCount++];\n            }\n            \n            return &profiles[0];  // Fallback\n        }\n    };\n    \n    static void report() {\n        Serial.println(F(\"\\n=== Performance Profile ===\"));\n        Serial.println(F(\"Function              Calls    Total(us)  Avg(us)  Min(us)  Max(us)\"));\n        Serial.println(F(\"--------              -----    ---------  -------  -------  -------\"));\n        \n        for (size_t i = 0; i < profileCount; i++) {\n            const auto& p = profiles[i];\n            if (p.callCount == 0) continue;\n            \n            uint32_t avg = p.totalTime / p.callCount;\n            \n            // Format output\n            char line[80];\n            snprintf(line, sizeof(line), \"%-20s %5lu    %9lu  %7lu  %7lu  %7lu\",\n                     p.name, p.callCount, p.totalTime, avg, p.minTime, p.maxTime);\n            Serial.println(line);\n        }\n    }\n    \n    static void reset() {\n        for (size_t i = 0; i < profileCount; i++) {\n            profiles[i].callCount = 0;\n            profiles[i].totalTime = 0;\n            profiles[i].minTime = UINT32_MAX;\n            profiles[i].maxTime = 0;\n        }\n    }\n};\n\n// Static member definition\nProfiler::ProfileData Profiler::profiles[Profiler::MAX_PROFILES];\nsize_t Profiler::profileCount = 0;\n\n// Usage macro\n#ifdef ENABLE_PROFILING\n    #define PROFILE(name) Profiler::ScopedTimer _timer(name)\n#else\n    #define PROFILE(name)\n#endif\n```\n\n## Code Optimization Techniques\n\n### Compiler Optimization Flags\n\n```cpp\n// Function-specific optimization\n__attribute__((optimize(\"O3\")))\nvoid criticalFunction() {\n    // This function will be optimized for speed\n}\n\n__attribute__((optimize(\"Os\")))\nvoid largeFunctionRarelyUsed() {\n    // This function will be optimized for size\n}\n\n// Hot path optimization\n__attribute__((hot))\nvoid frequentlyCalledFunction() {\n    // Compiler will optimize this aggressively\n}\n\n// Cold path optimization\n__attribute__((cold))\nvoid errorHandler() {\n    // Compiler will optimize for size, not speed\n}\n\n// Force inlining\n__attribute__((always_inline))\ninline void mustInline() {\n    // This will always be inlined\n}\n\n// Prevent inlining\n__attribute__((noinline))\nvoid doNotInline() {\n    // This will never be inlined\n}\n```\n\n### Loop Optimization\n\n```cpp\n// Loop unrolling for known sizes\ntemplate<size_t N>\nvoid clearBuffer(uint8_t* buffer) {\n    // Manual unrolling for small sizes\n    if constexpr (N == 4) {\n        buffer[0] = 0;\n        buffer[1] = 0;\n        buffer[2] = 0;\n        buffer[3] = 0;\n    } else if constexpr (N == 8) {\n        uint32_t* p = reinterpret_cast<uint32_t*>(buffer);\n        p[0] = 0;\n        p[1] = 0;\n    } else if constexpr (N % 4 == 0) {\n        // Unroll by 4\n        for (size_t i = 0; i < N; i += 4) {\n            buffer[i] = 0;\n            buffer[i + 1] = 0;\n            buffer[i + 2] = 0;\n            buffer[i + 3] = 0;\n        }\n    } else {\n        // Fallback\n        memset(buffer, 0, N);\n    }\n}\n\n// Loop optimization techniques\nclass LoopOptimizations {\npublic:\n    // Strength reduction - replace expensive operations\n    static void multiplyByPowerOf2(uint16_t* data, size_t count, uint8_t shift) {\n        // Instead of: data[i] *= (1 << shift);\n        for (size_t i = 0; i < count; i++) {\n            data[i] <<= shift;  // Bit shift instead of multiply\n        }\n    }\n    \n    // Loop fusion - combine multiple loops\n    static void processArraysFused(int* a, int* b, int* result, size_t count) {\n        // Instead of two separate loops\n        for (size_t i = 0; i < count; i++) {\n            int temp = a[i] + b[i];      // First operation\n            result[i] = temp * temp;      // Second operation\n            // Both in one loop - better cache usage\n        }\n    }\n    \n    // Loop invariant code motion\n    static void processWithInvariant(uint8_t* data, size_t count, uint8_t threshold) {\n        // Move invariant calculations outside loop\n        const uint16_t scaledThreshold = threshold * 256;\n        const uint8_t halfThreshold = threshold >> 1;\n        \n        for (size_t i = 0; i < count; i++) {\n            // Use pre-calculated values\n            if (data[i] > halfThreshold) {\n                data[i] = scaledThreshold / data[i];\n            }\n        }\n    }\n};\n```\n\n### Integer Optimization\n\n```cpp\n// Fast integer operations\nclass FastMath {\npublic:\n    // Division by constant power of 2\n    static constexpr uint32_t divideBy8(uint32_t n) {\n        return n >> 3;  // Instead of n / 8\n    }\n    \n    // Modulo by constant power of 2\n    static constexpr uint32_t modulo32(uint32_t n) {\n        return n & 31;  // Instead of n % 32\n    }\n    \n    // Fast multiply by constants\n    static constexpr uint32_t multiplyBy10(uint32_t n) {\n        return (n << 3) + (n << 1);  // n * 8 + n * 2\n    }\n    \n    // Avoid division for averaging\n    static uint16_t average4(uint16_t a, uint16_t b, uint16_t c, uint16_t d) {\n        // Avoid overflow and division\n        return (a >> 2) + (b >> 2) + (c >> 2) + (d >> 2) + \n               ((a & 3) + (b & 3) + (c & 3) + (d & 3) + 2) >> 2;\n    }\n    \n    // Fast absolute value\n    static int fastAbs(int n) {\n        int mask = n >> 31;  // Sign extension\n        return (n + mask) ^ mask;\n    }\n    \n    // Count leading zeros\n    static uint8_t countLeadingZeros(uint32_t n) {\n        #ifdef __GNUC__\n        return n ? __builtin_clz(n) : 32;\n        #else\n        // Fallback implementation\n        uint8_t count = 0;\n        while (n > 0) {\n            n >>= 1;\n            count++;\n        }\n        return 32 - count;\n        #endif\n    }\n    \n    // Fast bit counting\n    static uint8_t popCount(uint32_t n) {\n        #ifdef __GNUC__\n        return __builtin_popcount(n);\n        #else\n        // Brian Kernighan's algorithm\n        uint8_t count = 0;\n        while (n) {\n            n &= n - 1;\n            count++;\n        }\n        return count;\n        #endif\n    }\n};\n```\n\n### Lookup Tables\n\n```cpp\n// Precomputed lookup tables\nnamespace LookupTables {\n    // CRC lookup table\n    constexpr uint8_t crc8_table[256] PROGMEM = {\n        0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,\n        // ... full table\n    };\n    \n    // Sine table for fast trigonometry (0-90 degrees, 0.1 degree steps)\n    constexpr int16_t sine_table[901] PROGMEM = {\n        0, 17, 35, 52, 70, 87, 105, 122, // sin(0-0.7 degrees) * 10000\n        // ... full table\n    };\n    \n    // Fast sine approximation using lookup\n    int16_t fastSine(uint16_t degrees) {\n        degrees = degrees % 360;\n        \n        if (degrees <= 90) {\n            return pgm_read_word(&sine_table[degrees * 10]);\n        } else if (degrees <= 180) {\n            return pgm_read_word(&sine_table[(180 - degrees) * 10]);\n        } else if (degrees <= 270) {\n            return -pgm_read_word(&sine_table[(degrees - 180) * 10]);\n        } else {\n            return -pgm_read_word(&sine_table[(360 - degrees) * 10]);\n        }\n    }\n    \n    // Bit reverse lookup for FFT\n    constexpr uint8_t bitReverse8[256] PROGMEM = {\n        0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,\n        // ... full table\n    };\n}\n\n// Temperature sensor linearization table\nclass TemperatureLUT {\nprivate:\n    struct TableEntry {\n        uint16_t adc;\n        int16_t temp;  // Temperature * 10\n    };\n    \n    static constexpr TableEntry table[] PROGMEM = {\n        {0, -400},     // -40.0¬∞C\n        {100, -200},   // -20.0¬∞C\n        {512, 250},    // 25.0¬∞C\n        {900, 850},    // 85.0¬∞C\n        {1023, 1250}   // 125.0¬∞C\n    };\n    static constexpr size_t TABLE_SIZE = sizeof(table) / sizeof(table[0]);\n    \npublic:\n    static int16_t adcToTemperature(uint16_t adc) {\n        // Binary search in PROGMEM table\n        size_t low = 0;\n        size_t high = TABLE_SIZE - 1;\n        \n        while (low < high - 1) {\n            size_t mid = (low + high) / 2;\n            uint16_t midAdc = pgm_read_word(&table[mid].adc);\n            \n            if (adc < midAdc) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        \n        // Linear interpolation\n        uint16_t adc1 = pgm_read_word(&table[low].adc);\n        uint16_t adc2 = pgm_read_word(&table[high].adc);\n        int16_t temp1 = pgm_read_word(&table[low].temp);\n        int16_t temp2 = pgm_read_word(&table[high].temp);\n        \n        return temp1 + ((int32_t)(temp2 - temp1) * (adc - adc1)) / (adc2 - adc1);\n    }\n};\n```\n\n### Memory Access Optimization\n\n```cpp\n// Cache-friendly data structures\nstruct alignas(32) CacheAlignedData {\n    uint32_t frequentlyUsed[8];  // 32 bytes - typical cache line\n};\n\n// Structure packing for memory bandwidth\nstruct PackedSensorData {\n    uint16_t values[16];  // Read 32 bytes at once\n} __attribute__((packed));\n\n// Memory access patterns\nclass MemoryOptimized {\npublic:\n    // Row-major access pattern\n    static void processMatrix(uint8_t matrix[64][64]) {\n        // Access in memory order for cache efficiency\n        for (size_t row = 0; row < 64; row++) {\n            for (size_t col = 0; col < 64; col++) {\n                matrix[row][col] = processPixel(matrix[row][col]);\n            }\n        }\n    }\n    \n    // Prefetch hint (platform specific)\n    static void processWithPrefetch(uint32_t* data, size_t count) {\n        for (size_t i = 0; i < count; i += 4) {\n            #ifdef __ARM_ARCH_7A__\n            __builtin_prefetch(&data[i + 16], 0, 1);  // Prefetch ahead\n            #endif\n            \n            // Process current data\n            data[i] = complexCalculation(data[i]);\n            data[i + 1] = complexCalculation(data[i + 1]);\n            data[i + 2] = complexCalculation(data[i + 2]);\n            data[i + 3] = complexCalculation(data[i + 3]);\n        }\n    }\n    \nprivate:\n    static uint8_t processPixel(uint8_t pixel) {\n        return pixel;  // Placeholder\n    }\n    \n    static uint32_t complexCalculation(uint32_t value) {\n        return value;  // Placeholder\n    }\n};\n```\n\n### Float Optimization\n\n```cpp\n// Avoid floating point on 8-bit MCUs\nclass FixedPoint {\npublic:\n    // 16.16 fixed point representation\n    using Fixed32 = int32_t;\n    static constexpr int FRACTION_BITS = 16;\n    static constexpr Fixed32 SCALE = 1 << FRACTION_BITS;\n    \n    static Fixed32 fromFloat(float f) {\n        return static_cast<Fixed32>(f * SCALE + 0.5f);\n    }\n    \n    static float toFloat(Fixed32 f) {\n        return static_cast<float>(f) / SCALE;\n    }\n    \n    static Fixed32 multiply(Fixed32 a, Fixed32 b) {\n        return static_cast<int64_t>(a) * b >> FRACTION_BITS;\n    }\n    \n    static Fixed32 divide(Fixed32 a, Fixed32 b) {\n        return (static_cast<int64_t>(a) << FRACTION_BITS) / b;\n    }\n    \n    // Fast reciprocal approximation\n    static Fixed32 reciprocal(Fixed32 x) {\n        // Newton-Raphson approximation\n        Fixed32 guess = SCALE * SCALE / x;  // Initial guess\n        \n        // Two iterations usually sufficient\n        guess = multiply(guess, fromFloat(2.0f) - multiply(x, guess));\n        guess = multiply(guess, fromFloat(2.0f) - multiply(x, guess));\n        \n        return guess;\n    }\n};\n\n// Integer-only PID controller\nclass IntegerPID {\nprivate:\n    int32_t kp, ki, kd;  // Gains scaled by 256\n    int32_t integral;\n    int32_t lastError;\n    int32_t integralMax;\n    \npublic:\n    IntegerPID(int32_t p, int32_t i, int32_t d, int32_t iMax)\n        : kp(p), ki(i), kd(d), integral(0), lastError(0), integralMax(iMax) {}\n    \n    int32_t calculate(int32_t setpoint, int32_t measured) {\n        int32_t error = setpoint - measured;\n        \n        // Integral with anti-windup\n        integral += error;\n        if (integral > integralMax) integral = integralMax;\n        if (integral < -integralMax) integral = -integralMax;\n        \n        // Derivative\n        int32_t derivative = error - lastError;\n        lastError = error;\n        \n        // PID calculation (gains pre-scaled by 256)\n        int32_t output = (kp * error + ki * integral + kd * derivative) >> 8;\n        \n        return output;\n    }\n    \n    void reset() {\n        integral = 0;\n        lastError = 0;\n    }\n};\n```\n\n## Interrupt Optimization\n\n```cpp\n// Minimal ISR with deferred processing\nvolatile bool dataReady = false;\nvolatile uint8_t isrData[64];\nvolatile size_t isrDataCount = 0;\n\n// Fast ISR - just copy data and set flag\nISR(TIMER1_COMPA_vect) {\n    if (isrDataCount < sizeof(isrData)) {\n        isrData[isrDataCount++] = PIND;  // Direct port read\n        dataReady = true;\n    }\n}\n\n// Main loop processes data\nvoid loop() {\n    if (dataReady) {\n        noInterrupts();\n        uint8_t localData[64];\n        size_t count = isrDataCount;\n        memcpy(localData, (void*)isrData, count);\n        isrDataCount = 0;\n        dataReady = false;\n        interrupts();\n        \n        // Process data outside ISR\n        processData(localData, count);\n    }\n}\n\n// Table-driven state machine in ISR\nclass FastStateMachine {\nprivate:\n    enum State : uint8_t {\n        IDLE, START, DATA, STOP\n    };\n    \n    struct Transition {\n        uint8_t nextState;\n        void (*action)(uint8_t);\n    };\n    \n    static Transition stateTable[4][2];  // [state][input]\n    static volatile State currentState;\n    \npublic:\n    static void IRAM_ATTR handleInterrupt(uint8_t input) {\n        input = input ? 1 : 0;  // Normalize to 0 or 1\n        const Transition& t = stateTable[currentState][input];\n        \n        if (t.action) {\n            t.action(input);\n        }\n        \n        currentState = static_cast<State>(t.nextState);\n    }\n};\n```\n\n## DMA Optimization\n\n```cpp\n#ifdef ESP32\n// DMA transfer for ESP32\n#include <driver/spi_master.h>\n\nclass DMATransfer {\nprivate:\n    spi_device_handle_t spi;\n    spi_transaction_t transaction;\n    \npublic:\n    void setupDMA() {\n        spi_bus_config_t buscfg = {\n            .mosi_io_num = 23,\n            .miso_io_num = 19,\n            .sclk_io_num = 18,\n            .quadwp_io_num = -1,\n            .quadhd_io_num = -1,\n            .max_transfer_sz = 4096,\n            .flags = SPICOMMON_BUSFLAG_MASTER | SPICOMMON_BUSFLAG_IOMUX_PINS,\n        };\n        \n        spi_bus_initialize(HSPI_HOST, &buscfg, 1);  // DMA channel 1\n    }\n    \n    void transferDMA(const uint8_t* txData, uint8_t* rxData, size_t length) {\n        memset(&transaction, 0, sizeof(transaction));\n        transaction.length = length * 8;  // Length in bits\n        transaction.tx_buffer = txData;\n        transaction.rx_buffer = rxData;\n        \n        // Non-blocking transfer\n        spi_device_queue_trans(spi, &transaction, portMAX_DELAY);\n        \n        // Do other work while DMA runs...\n        \n        // Wait for completion\n        spi_transaction_t* rtrans;\n        spi_device_get_trans_result(spi, &rtrans, portMAX_DELAY);\n    }\n};\n#endif\n\n#ifdef STM32\n// DMA for STM32\nclass STM32_DMA {\n    // Platform-specific DMA implementation\n};\n#endif\n```\n\n## Power-Aware Performance\n\n```cpp\n// Dynamic frequency scaling\nclass PowerOptimizedPerformance {\npublic:\n    enum PerformanceMode {\n        POWER_SAVE,    // Lowest frequency\n        BALANCED,      // Medium frequency\n        PERFORMANCE    // Maximum frequency\n    };\n    \n    static void setPerformanceMode(PerformanceMode mode) {\n        #ifdef ESP32\n        switch (mode) {\n            case POWER_SAVE:\n                setCpuFrequencyMhz(80);\n                break;\n            case BALANCED:\n                setCpuFrequencyMhz(160);\n                break;\n            case PERFORMANCE:\n                setCpuFrequencyMhz(240);\n                break;\n        }\n        #endif\n    }\n    \n    // Adaptive performance based on workload\n    static void adaptivePerformance(uint32_t taskDuration) {\n        static uint32_t avgDuration = 0;\n        \n        // Moving average\n        avgDuration = (avgDuration * 7 + taskDuration) >> 3;\n        \n        if (avgDuration > 10000) {  // > 10ms average\n            setPerformanceMode(PERFORMANCE);\n        } else if (avgDuration > 1000) {  // > 1ms average\n            setPerformanceMode(BALANCED);\n        } else {\n            setPerformanceMode(POWER_SAVE);\n        }\n    }\n};\n```\n\n## Code Size Optimization\n\n```cpp\n// Shared string constants\nnamespace SharedStrings {\n    const char OK[] PROGMEM = \"OK\";\n    const char ERROR[] PROGMEM = \"ERROR\";\n    const char READY[] PROGMEM = \"Ready\";\n    \n    // Use single format string\n    const char VALUE_FORMAT[] PROGMEM = \"%s: %d\\n\";\n}\n\n// Template to reduce code duplication\ntemplate<typename T>\nclass GenericSensor {\nprotected:\n    T lastValue;\n    uint32_t lastRead;\n    const uint32_t minInterval;\n    \npublic:\n    GenericSensor(uint32_t interval) : minInterval(interval), lastRead(0) {}\n    \n    bool shouldRead() {\n        return (millis() - lastRead) >= minInterval;\n    }\n    \n    T getValue() {\n        if (shouldRead()) {\n            lastValue = readSensor();\n            lastRead = millis();\n        }\n        return lastValue;\n    }\n    \nprotected:\n    virtual T readSensor() = 0;\n};\n\n// Macro to generate similar functions\n#define GENERATE_SETTER(type, name) \\\n    void set##name(type value) { \\\n        name##_ = value; \\\n        markDirty(); \\\n    }\n```\n\n## Best Practices Summary\n\n1. **Measure First**: Profile before optimizing\n2. **Compiler Flags**: Use appropriate optimization levels\n3. **Integer Math**: Prefer integer over floating-point\n4. **Lookup Tables**: Precompute expensive calculations\n5. **Loop Optimization**: Unroll, fuse, and optimize loops\n6. **Memory Access**: Optimize for cache and alignment\n7. **Minimal ISRs**: Keep interrupt handlers short\n8. **DMA Usage**: Use DMA for bulk transfers\n9. **Power Scaling**: Adjust performance to workload\n10. **Code Size**: Balance speed vs size optimization",
          "alwaysApply": true,
          "globs": [
            "**/*.cpp",
            "**/*.c",
            "**/*.h",
            "**/src/**"
          ]
        }
      ]
    },
    {
      "id": "python-fastapi",
      "name": "Python + FastAPI",
      "directory": "Python + FastAPI",
      "icon": "icons/fastapi.png",
      "summary": "Backend API development with FastAPI",
      "focus": "Async APIs, validation, security, testing",
      "readme": "# Cursor Rules for Python FastAPI Projects\n\nThis repository contains Cursor AI coding rules and guidelines for Python and FastAPI projects. These rules help maintain consistency, code quality, and best practices across the codebase when working with AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and architectural decisions.\n\n## Overview of Rules\n\n### üìã Core Framework & Language (`core-framework-&-language.mdc`)\nDefines the foundational technology stack:\n- **Framework:** FastAPI (Async REST API Framework)\n- **Language:** Python 3.11+\n- **Runtime:** Python with Uvicorn ASGI server\n\n### üîß Backend Architecture (`backend-architecture.mdc`)\nBackend architecture and patterns:\n- **API Design:** RESTful API with OpenAPI/Swagger\n- **Dependency Injection:** FastAPI's built-in DI system\n- **Database:** SQLAlchemy ORM with PostgreSQL\n- **Background Tasks:** Celery with Redis\n- **Validation:** Pydantic schemas\n- **Authentication:** JWT tokens with OAuth2\n\n### üèóÔ∏è Key Architectural Patterns (`key-architecture-patterns.mdc`)\nCore architectural patterns used in the codebase:\n- **Service Layer:** Business logic in `app/services/`\n- **Repository Pattern:** Data access in `app/repositories/`\n- **Domain Models:** Pydantic models and SQLAlchemy models\n- **Dependency Injection:** FastAPI's Depends system\n- **Modular Routers:** Feature-based API routes\n\n### üí¨ Commenting Guidelines (`commenting-guidelines.mdc`)\nComprehensive docstring standards:\n- **Format:** Google-style docstrings for all public functions\n- **Focus:** Explain the \"why\" and \"intent\", not the \"what\"\n- **When to Comment:** Public APIs, complex logic, non-obvious decisions\n- **Key Elements:** Parameters, returns, raises, examples\n- **Type Hints:** Always use type annotations\n\n### üìù Logging Guidelines (`logging-guidelines.mdc`)\n**‚ö†Ô∏è IMPORTANT: Only add logs when asked for. By default, do NOT add logs.**\n\nComprehensive logging standards:\n- **Logger:** Use Python's `logging` module with custom formatters\n- **Log Levels:** `error`, `warning`, `info`, `debug`\n- **Context:** Include request IDs, user IDs, operation context\n- **Best Practices:** Structured logging, avoid sensitive data\n- **Performance:** Async-aware logging, minimal performance impact\n\n### üéØ Code Style Guidelines (`code-style-guidelines.mdc`)\nComprehensive code style guide following PEP 8 and beyond:\n- **Formatting:** Black formatter with 100-char line length\n- **Import Order:** isort with custom grouping\n- **Type Hints:** Mandatory for all functions\n- **Naming:** snake_case for functions/variables, PascalCase for classes\n- **Async:** Prefer async/await for I/O operations\n- **Docstrings:** Google-style for all public functions\n\n### ‚úÖ No Hiding (`no-hiding.mdc`)\n**Critical Rule:** Never hide linter errors or type checker warnings. All must be resolved.\n\n### üß™ Testing (`testing.mdc`)\nComprehensive testing philosophy:\n- **Framework:** Pytest with async support\n- **Coverage:** 100% for service and repository layers\n- **Test Types:** Unit, integration, and API tests\n- **Test Organization:** Tests mirror source structure\n- **Mocking:** Use `pytest-mock` and `unittest.mock`\n- **Fixtures:** Extensive use of pytest fixtures\n\n### üö® Error Handling Patterns (`error-handling-patterns.mdc`)\nComprehensive error management:\n- **Custom Exceptions:** Domain-specific error classes\n- **API Error Responses:** Consistent error format\n- **Exception Handlers:** Global and route-specific\n- **Validation Errors:** Pydantic validation with clear messages\n- **Logging:** All errors logged with context\n\n### ‚ö° Performance Guidelines (`performance-guidelines.mdc`)\nPython and FastAPI optimization:\n- **Async Best Practices:** Proper async/await usage\n- **Database Optimization:** Query optimization, connection pooling\n- **Caching:** Redis caching strategies\n- **Background Tasks:** Offload heavy operations\n- **Response Streaming:** For large datasets\n- **Profiling:** Performance monitoring tools\n\n### üóÑÔ∏è Data Management Patterns (`data-management-patterns.mdc`)\nDatabase and data handling:\n- **SQLAlchemy Patterns:** Async sessions, proper transactions\n- **Migrations:** Alembic for database schema management\n- **Query Optimization:** Eager loading, query builders\n- **Data Validation:** Pydantic models for all I/O\n- **Serialization:** Proper JSON encoding/decoding\n\n### üîí Security Guidelines (`security-guidelines.mdc`)\nSecurity best practices:\n- **Authentication:** JWT with refresh tokens\n- **Authorization:** Role-based access control (RBAC)\n- **Input Validation:** Always validate with Pydantic\n- **SQL Injection:** Use parameterized queries\n- **Secrets Management:** Environment variables, never hardcode\n- **CORS:** Properly configured CORS middleware\n\n### üîÄ Git Workflow (`git-workflow.mdc`)\nVersion control standards:\n- **Commit Format:** Conventional Commits\n- **Branch Naming:** Consistent conventions\n- **Pull Requests:** PR template and process\n- **Pre-commit Hooks:** Black, isort, mypy, ruff\n\n### üëÄ Code Review (`code-review.mdc`)\nCode review checklist:\n- **Functionality:** Does it work as intended?\n- **Tests:** Are there adequate tests?\n- **Performance:** Any obvious bottlenecks?\n- **Security:** Any security concerns?\n- **Style:** Follows all guidelines?\n\n### üöÄ API Design Guidelines (`api-design-guidelines.mdc`)\nRESTful API design principles:\n- **Resource Naming:** Plural nouns, kebab-case\n- **HTTP Methods:** Proper use of GET, POST, PUT, DELETE\n- **Status Codes:** Appropriate HTTP status codes\n- **Pagination:** Cursor-based pagination\n- **Versioning:** URL path versioning (/v1/)\n- **Documentation:** OpenAPI/Swagger auto-generated\n\n### üîß Configuration Management (`configuration-management.mdc`)\nConfiguration best practices:\n- **Environment Variables:** Using Pydantic Settings\n- **Configuration Layers:** Development, staging, production\n- **Secrets:** Never in code, use env vars or secret manager\n- **Validation:** All config validated at startup\n\n### üì¶ Dependency Management (`dependency-management.mdc`)\nPackage and dependency handling:\n- **Poetry:** For dependency management\n- **Version Pinning:** Exact versions in lock file\n- **Security:** Regular dependency audits\n- **Docker:** Multi-stage builds for production\n\n### ‚öñÔ∏è Conflict Resolution (`conflict-resolution.mdc`)\nGuidance for resolving rule conflicts:\n- **Priority Hierarchy:** Rule precedence order\n- **Common Scenarios:** How to handle specific conflicts\n- **Decision Process:** Step-by-step conflict resolution\n- **Documentation:** When and how to document exceptions\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @commenting-guidelines.mdc Please add docstrings to this function\n   ```\n\n### File Structure\n\n```\nvibe-coding-rules/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ Python + FastAPI/\n    ‚îú‚îÄ‚îÄ api-design-guidelines.mdc\n    ‚îú‚îÄ‚îÄ backend-architecture.mdc\n    ‚îú‚îÄ‚îÄ code-review.mdc\n    ‚îú‚îÄ‚îÄ code-style-guidelines.mdc\n    ‚îú‚îÄ‚îÄ commenting-guidelines.mdc\n    ‚îú‚îÄ‚îÄ configuration-management.mdc\n    ‚îú‚îÄ‚îÄ conflict-resolution.mdc\n    ‚îú‚îÄ‚îÄ core-framework-&-language.mdc\n    ‚îú‚îÄ‚îÄ data-management-patterns.mdc\n    ‚îú‚îÄ‚îÄ dependency-management.mdc\n    ‚îú‚îÄ‚îÄ error-handling-patterns.mdc\n    ‚îú‚îÄ‚îÄ git-workflow.mdc\n    ‚îú‚îÄ‚îÄ key-architecture-patterns.mdc\n    ‚îú‚îÄ‚îÄ logging-guidelines.mdc\n    ‚îú‚îÄ‚îÄ no-hiding.mdc\n    ‚îú‚îÄ‚îÄ performance-guidelines.mdc\n    ‚îú‚îÄ‚îÄ security-guidelines.mdc\n    ‚îî‚îÄ‚îÄ testing.mdc\n```\n\n## Quick Reference\n\n### When Writing Code\n- ‚úÖ Follow PEP 8 and use Black formatter\n- ‚úÖ **NEVER abbreviate variables** - Always use descriptive names\n- ‚úÖ Use type hints for all function signatures\n- ‚úÖ Write Google-style docstrings for public APIs\n- ‚úÖ Never hide linter or type checker errors\n- ‚úÖ Use appropriate logging (only when requested)\n- ‚úÖ Follow architectural patterns (Service Layer, Repository Pattern)\n\n### When Building APIs\n- ‚úÖ Use Pydantic models for request/response validation\n- ‚úÖ Implement proper error handling with custom exceptions\n- ‚úÖ Use dependency injection for shared resources\n- ‚úÖ Document endpoints with OpenAPI schemas\n- ‚úÖ Implement proper authentication and authorization\n- ‚úÖ Use async/await for I/O operations\n\n### When Testing\n- ‚úÖ Write tests for service and repository layers (100% coverage)\n- ‚úÖ Use pytest fixtures for test data\n- ‚úÖ Mock external dependencies properly\n- ‚úÖ Test both success and error cases\n- ‚úÖ Use async test functions for async code\n\n### When Handling Errors\n- ‚úÖ Use custom exception classes\n- ‚úÖ Never expose internal errors to API consumers\n- ‚úÖ Log errors with proper context\n- ‚úÖ Return consistent error responses\n- ‚úÖ Validate all inputs with Pydantic\n\n### When Optimizing Performance\n- ‚úÖ Profile before optimizing\n- ‚úÖ Use async/await properly\n- ‚úÖ Implement caching where appropriate\n- ‚úÖ Optimize database queries\n- ‚úÖ Use background tasks for heavy operations\n- ‚úÖ Monitor API response times\n\n### When Managing Data\n- ‚úÖ Use SQLAlchemy ORM with async support\n- ‚úÖ Implement proper transaction management\n- ‚úÖ Use Alembic for migrations\n- ‚úÖ Validate all data with Pydantic\n- ‚úÖ Handle database connections properly\n\n### When Committing Code\n- ‚úÖ Use Conventional Commits format\n- ‚úÖ Run pre-commit hooks (black, isort, mypy, ruff)\n- ‚úÖ Write clear commit messages\n- ‚úÖ Make atomic commits\n- ‚úÖ Never commit secrets\n\n### When Reviewing Code\n- ‚úÖ Check functionality and edge cases\n- ‚úÖ Verify test coverage\n- ‚úÖ Look for security issues\n- ‚úÖ Ensure performance considerations\n- ‚úÖ Verify adherence to all guidelines\n\n### When Designing APIs\n- ‚úÖ Use RESTful principles\n- ‚úÖ Return appropriate status codes\n- ‚úÖ Implement proper pagination\n- ‚úÖ Version your APIs\n- ‚úÖ Document with OpenAPI/Swagger\n\n## Contributing\n\nWhen updating these rules:\n1. Keep guidelines clear and actionable\n2. Include examples where helpful\n3. Update this README if adding new rule files\n4. Ensure consistency across all rule files\n\n## Notes\n\n- These rules are specifically tailored for Python + FastAPI projects\n- Rules marked with `alwaysApply: true` are enforced automatically\n- The logging guidelines emphasize minimal logging by default - only log when explicitly requested\n- The \"no-hiding\" rule is critical - all linter and type checker errors must be resolved\n- When rules conflict, refer to `conflict-resolution.mdc` for guidance\n- Focus on async patterns as FastAPI is async-first\n",
      "guides": [
        {
          "id": "api-design-guidelines",
          "title": "Api Design Guidelines",
          "fileName": "api-design-guidelines.mdc",
          "frontmatter": {
            "description": "RESTful API design principles and best practices for FastAPI",
            "globs": [
              "**/app/api/**"
            ],
            "alwaysApply": true
          },
          "content": "# API Design Guidelines\n\n## RESTful Principles\n\n### Resource Naming\n\n- **Use nouns, not verbs** - Resources are things, not actions\n- **Use plural nouns** - Collections are plural\n- **Use kebab-case** - For multi-word resources\n- **Be consistent** - Follow the same pattern throughout\n\n```python\n# ‚úÖ GOOD\nGET    /api/v1/users\nGET    /api/v1/users/123\nPOST   /api/v1/users\nPUT    /api/v1/users/123\nDELETE /api/v1/users/123\n\nGET    /api/v1/user-profiles\nGET    /api/v1/user-profiles/123\n\n# ‚ùå BAD\nGET    /api/v1/getUsers\nGET    /api/v1/user  # Should be plural\nPOST   /api/v1/createUser  # Verb in URL\nGET    /api/v1/userProfiles  # camelCase instead of kebab-case\n```\n\n### HTTP Methods\n\nUse HTTP methods correctly:\n\n- **GET** - Retrieve resources (idempotent, safe)\n- **POST** - Create resources or perform actions\n- **PUT** - Replace entire resource (idempotent)\n- **PATCH** - Partial update (idempotent)\n- **DELETE** - Delete resource (idempotent)\n\n```python\n# ‚úÖ GOOD\n@router.get(\"/users/{user_id}\")\nasync def get_user(user_id: int) -> UserResponse:\n    \"\"\"Get user by ID.\"\"\"\n    pass\n\n@router.post(\"/users\")\nasync def create_user(user_data: UserCreate) -> UserResponse:\n    \"\"\"Create new user.\"\"\"\n    pass\n\n@router.put(\"/users/{user_id}\")\nasync def update_user(user_id: int, user_data: UserUpdate) -> UserResponse:\n    \"\"\"Replace entire user.\"\"\"\n    pass\n\n@router.patch(\"/users/{user_id}\")\nasync def partial_update_user(user_id: int, user_data: UserPartialUpdate) -> UserResponse:\n    \"\"\"Partially update user.\"\"\"\n    pass\n\n@router.delete(\"/users/{user_id}\")\nasync def delete_user(user_id: int) -> None:\n    \"\"\"Delete user.\"\"\"\n    pass\n```\n\n### Status Codes\n\nUse appropriate HTTP status codes:\n\n- **200 OK** - Successful GET, PUT, PATCH\n- **201 Created** - Successful POST (resource created)\n- **204 No Content** - Successful DELETE\n- **400 Bad Request** - Client error (validation)\n- **401 Unauthorized** - Authentication required\n- **403 Forbidden** - Authorization failed\n- **404 Not Found** - Resource doesn't exist\n- **409 Conflict** - Resource conflict (e.g., duplicate)\n- **422 Unprocessable Entity** - Validation error (Pydantic)\n- **500 Internal Server Error** - Server error\n\n```python\n# ‚úÖ GOOD\n@router.post(\"/users\", status_code=201)\nasync def create_user(user_data: UserCreate) -> UserResponse:\n    \"\"\"Create user - returns 201.\"\"\"\n    pass\n\n@router.delete(\"/users/{user_id}\", status_code=204)\nasync def delete_user(user_id: int) -> None:\n    \"\"\"Delete user - returns 204.\"\"\"\n    pass\n\n@router.get(\"/users/{user_id}\", status_code=200)\nasync def get_user(user_id: int) -> UserResponse:\n    \"\"\"Get user - returns 200.\"\"\"\n    pass\n```\n\n## Request/Response Patterns\n\n### Request Validation\n\nAlways validate requests with Pydantic:\n\n```python\n# ‚úÖ GOOD - Pydantic validation\nfrom pydantic import BaseModel, EmailStr, Field\n\nclass UserCreate(BaseModel):\n    \"\"\"User creation schema.\"\"\"\n    email: EmailStr\n    full_name: str = Field(..., min_length=1, max_length=255)\n    password: str = Field(..., min_length=8, max_length=100)\n\n@router.post(\"/users\")\nasync def create_user(user_data: UserCreate) -> UserResponse:\n    \"\"\"Create user - automatically validated.\"\"\"\n    # user_data is already validated\n    pass\n```\n\n### Response Models\n\nAlways define response models:\n\n```python\n# ‚úÖ GOOD - Explicit response model\n@router.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(user_id: int) -> UserResponse:\n    \"\"\"Get user with typed response.\"\"\"\n    pass\n\n# ‚úÖ GOOD - List response\n@router.get(\"/users\", response_model=List[UserResponse])\nasync def list_users() -> List[UserResponse]:\n    \"\"\"List users.\"\"\"\n    pass\n```\n\n### Error Responses\n\nUse consistent error format:\n\n```python\n# app/core/exceptions.py\nclass ApplicationError(Exception):\n    \"\"\"Base exception with consistent format.\"\"\"\n    def __init__(self, message: str, status_code: int = 500):\n        self.message = message\n        self.status_code = status_code\n\n# Error response format\n{\n    \"error\": {\n        \"message\": \"User not found\",\n        \"code\": \"NotFoundError\",\n        \"detail\": {}\n    }\n}\n```\n\n## Pagination\n\n### Cursor-Based Pagination (Preferred)\n\n```python\n# app/schemas/pagination.py\nfrom pydantic import BaseModel\nfrom typing import Optional, Generic, TypeVar, List\n\nT = TypeVar(\"T\")\n\nclass PaginatedResponse(BaseModel, Generic[T]):\n    \"\"\"Cursor-based paginated response.\"\"\"\n    items: List[T]\n    next_cursor: Optional[str] = None\n    has_more: bool\n\n# Usage\n@router.get(\"/users\", response_model=PaginatedResponse[UserResponse])\nasync def list_users(\n    cursor: Optional[str] = None,\n    limit: int = Query(20, ge=1, le=100),\n) -> PaginatedResponse[UserResponse]:\n    \"\"\"List users with cursor pagination.\"\"\"\n    users, next_cursor, has_more = await user_service.list_paginated(\n        cursor=cursor,\n        limit=limit,\n    )\n    return PaginatedResponse(\n        items=[UserResponse.from_orm(u) for u in users],\n        next_cursor=next_cursor,\n        has_more=has_more,\n    )\n```\n\n### Offset-Based Pagination (Alternative)\n\n```python\nclass PaginatedResponse(BaseModel, Generic[T]):\n    \"\"\"Offset-based paginated response.\"\"\"\n    items: List[T]\n    total: int\n    page: int\n    page_size: int\n    pages: int\n\n@router.get(\"/users\", response_model=PaginatedResponse[UserResponse])\nasync def list_users(\n    page: int = Query(1, ge=1),\n    page_size: int = Query(20, ge=1, le=100),\n) -> PaginatedResponse[UserResponse]:\n    \"\"\"List users with offset pagination.\"\"\"\n    offset = (page - 1) * page_size\n    users, total = await asyncio.gather(\n        user_service.list_paginated(offset, page_size),\n        user_service.count(),\n    )\n    return PaginatedResponse(\n        items=[UserResponse.from_orm(u) for u in users],\n        total=total,\n        page=page,\n        page_size=page_size,\n        pages=(total + page_size - 1) // page_size,\n    )\n```\n\n## Filtering and Sorting\n\n### Query Parameters\n\n```python\n@router.get(\"/users\", response_model=List[UserResponse])\nasync def list_users(\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    sort_by: str = Query(\"created_at\", description=\"Sort field\"),\n    sort_order: str = Query(\"desc\", regex=\"^(asc|desc)$\"),\n    limit: int = Query(20, ge=1, le=100),\n) -> List[UserResponse]:\n    \"\"\"List users with filtering and sorting.\"\"\"\n    users = await user_service.list_filtered(\n        status=status,\n        sort_by=sort_by,\n        sort_order=sort_order,\n        limit=limit,\n    )\n    return [UserResponse.from_orm(u) for u in users]\n```\n\n## API Versioning\n\n### URL Path Versioning (Preferred)\n\n```python\n# app/api/v1/router.py\nfrom fastapi import APIRouter\n\napi_router = APIRouter(prefix=\"/api/v1\")\n\n# app/main.py\nfrom app.api.v1.router import api_router\n\napp.include_router(api_router)\n```\n\n### Header Versioning (Alternative)\n\n```python\n@router.get(\"/users\", dependencies=[Depends(require_api_version(\"v1\"))])\nasync def list_users() -> List[UserResponse]:\n    \"\"\"List users - requires v1 API version header.\"\"\"\n    pass\n```\n\n## OpenAPI Documentation\n\nFastAPI automatically generates OpenAPI docs:\n\n```python\n# app/main.py\napp = FastAPI(\n    title=\"My API\",\n    description=\"API for managing users and resources\",\n    version=\"1.0.0\",\n    docs_url=\"/docs\",  # Swagger UI\n    redoc_url=\"/redoc\",  # ReDoc\n    openapi_url=\"/openapi.json\",\n)\n```\n\n### Enhance Documentation\n\n```python\n@router.post(\n    \"/users\",\n    response_model=UserResponse,\n    status_code=201,\n    summary=\"Create a new user\",\n    description=\"Create a new user account with email and password\",\n    response_description=\"The created user\",\n    tags=[\"users\"],\n)\nasync def create_user(user_data: UserCreate) -> UserResponse:\n    \"\"\"\n    Create a new user account.\n    \n    This endpoint allows creating a new user account. The user will\n    receive a welcome email with login credentials.\n    \"\"\"\n    pass\n```\n\n## Best Practices\n\n1. **Consistent Naming** - Use consistent resource naming\n2. **Proper HTTP Methods** - Use correct methods for operations\n3. **Status Codes** - Return appropriate status codes\n4. **Validation** - Always validate with Pydantic\n5. **Error Handling** - Consistent error response format\n6. **Pagination** - Implement pagination for list endpoints\n7. **Versioning** - Version your APIs\n8. **Documentation** - Use OpenAPI/Swagger\n9. **Idempotency** - Make operations idempotent where possible\n10. **Security** - Implement authentication and authorization\n\n## Remember\n\n- **RESTful Principles** - Follow REST conventions\n- **Consistency** - Be consistent across all endpoints\n- **Documentation** - Use OpenAPI for automatic docs\n- **Validation** - Always validate requests\n- **Error Handling** - Consistent error responses\n- **Versioning** - Version your APIs from the start",
          "alwaysApply": true,
          "globs": [
            "**/app/api/**"
          ]
        },
        {
          "id": "backend-architecture",
          "title": "Backend Architecture",
          "fileName": "backend-architecture.mdc",
          "frontmatter": {
            "description": "Backend architecture, API patterns, and service integrations for FastAPI",
            "globs": [
              "**/app/api/**",
              "**/app/services/**",
              "**/app/repositories/**",
              "**/app/core/**"
            ],
            "alwaysApply": true
          },
          "content": "# Backend Architecture\n\n## Overview\n\nThis document defines the backend architecture, API patterns, and external service integrations used in the FastAPI application.\n\n## API Routes\n\n**Framework:** [FastAPI](https://fastapi.tiangolo.com/) with APIRouter\n\n**Location:** `app/api/v1/endpoints/` directory\n\n**Pattern:** Thin route handlers that delegate to services\n\n**Example:**\n\n```python\n# app/api/v1/endpoints/users.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.api.dependencies import get_current_user, get_db\nfrom app.models.domain.user import User\nfrom app.schemas.user import UserResponse, UserCreate\nfrom app.services.user_service import UserService\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n\n@router.get(\"/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n) -> UserResponse:\n    \"\"\"Get user by ID.\"\"\"\n    user_service = UserService(db)\n    user = await user_service.get_user_by_id(user_id)\n    \n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\"\n        )\n    \n    return UserResponse.from_orm(user)\n```\n\n## Database\n\n**ORM:** [SQLAlchemy](https://www.sqlalchemy.org/) 2.0+ (async)\n\n**Database:** PostgreSQL\n\n**Connection Pooling:** Built-in SQLAlchemy async engine\n\n**Usage:**\n\n```python\n# app/core/database.py\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import declarative_base\n\nfrom app.core.config import settings\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=settings.DEBUG,\n    future=True,\n    pool_pre_ping=True,\n    pool_size=10,\n    max_overflow=20,\n)\n\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n    autocommit=False,\n    autoflush=False,\n)\n\nBase = declarative_base()\n\n\n# Dependency for getting database session\nasync def get_db() -> AsyncSession:\n    \"\"\"Get database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n## API Validation\n\n**Library:** [Pydantic](https://docs.pydantic.dev/) v2\n\n**Location:** `app/schemas/` directory\n\n**Pattern:** Pydantic models for request/response validation\n\n**Example:**\n\n```python\n# app/schemas/user.py\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, ConfigDict\n\n\nclass UserBase(BaseModel):\n    \"\"\"Base user schema.\"\"\"\n    email: EmailStr\n    full_name: str = Field(..., min_length=1, max_length=255)\n    is_active: bool = True\n\n\nclass UserCreate(UserBase):\n    \"\"\"Schema for creating a user.\"\"\"\n    password: str = Field(..., min_length=8, max_length=100)\n\n\nclass UserUpdate(BaseModel):\n    \"\"\"Schema for updating a user.\"\"\"\n    email: Optional[EmailStr] = None\n    full_name: Optional[str] = Field(None, min_length=1, max_length=255)\n    is_active: Optional[bool] = None\n\n\nclass UserResponse(UserBase):\n    \"\"\"Schema for user response.\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime\n    \n    model_config = ConfigDict(from_attributes=True)\n```\n\n## API Authentication\n\n**Pattern:** JWT tokens with OAuth2 password flow\n\n**Location:** `app/core/security.py` and `app/api/dependencies.py`\n\n**Dependencies:**\n\n```python\n# app/core/security.py\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against a hash.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hash a password.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(\n        to_encode,\n        settings.SECRET_KEY,\n        algorithm=settings.ALGORITHM\n    )\n    return encoded_jwt\n\n\n# app/api/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.models.domain.user import User\nfrom app.repositories.user_repository import UserRepository\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"api/v1/auth/login\")\n\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    db: AsyncSession = Depends(get_db),\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    try:\n        payload = jwt.decode(\n            token,\n            settings.SECRET_KEY,\n            algorithms=[settings.ALGORITHM]\n        )\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user_repo = UserRepository(db)\n    user = await user_repo.get_by_id(user_id)\n    \n    if user is None:\n        raise credentials_exception\n    \n    return user\n\n\nasync def get_current_active_user(\n    current_user: User = Depends(get_current_user),\n) -> User:\n    \"\"\"Get current active user.\"\"\"\n    if not current_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Inactive user\"\n        )\n    return current_user\n```\n\n## Background Tasks\n\n**Library:** [Celery](https://docs.celeryproject.org/) with Redis\n\n**Usage:**\n\n```python\n# app/core/celery_app.py\nfrom celery import Celery\n\nfrom app.core.config import settings\n\ncelery_app = Celery(\n    \"worker\",\n    broker=settings.REDIS_URL,\n    backend=settings.REDIS_URL,\n    include=[\"app.tasks\"]\n)\n\ncelery_app.conf.task_routes = {\n    \"app.tasks.*\": \"main-queue\",\n}\n\n# app/tasks/email_tasks.py\nfrom app.core.celery_app import celery_app\n\n@celery_app.task(name=\"send_email\")\ndef send_email_task(email_to: str, subject: str, body: str) -> None:\n    \"\"\"Send email task.\"\"\"\n    # Email sending logic\n    pass\n```\n\n## Caching\n\n**Library:** Redis with aioredis\n\n**Pattern:** Cache decorators and explicit cache management\n\n**Example:**\n\n```python\n# app/core/cache.py\nfrom functools import wraps\nfrom typing import Callable, TypeVar, Any\nimport json\nfrom redis import asyncio as aioredis\n\nfrom app.core.config import settings\n\nredis_client: Optional[aioredis.Redis] = None\n\n\nasync def get_redis() -> aioredis.Redis:\n    \"\"\"Get Redis client.\"\"\"\n    global redis_client\n    if redis_client is None:\n        redis_client = await aioredis.from_url(\n            settings.REDIS_URL,\n            encoding=\"utf-8\",\n            decode_responses=True\n        )\n    return redis_client\n\n\ndef cache_result(ttl: int = 300):\n    \"\"\"Cache function result decorator.\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            redis = await get_redis()\n            cache_key = f\"{func.__name__}:{args}:{kwargs}\"\n            \n            cached = await redis.get(cache_key)\n            if cached:\n                return json.loads(cached)\n            \n            result = await func(*args, **kwargs)\n            await redis.setex(cache_key, ttl, json.dumps(result))\n            return result\n        \n        return wrapper\n    return decorator\n```\n\n## Best Practices\n\n1. **Thin Route Handlers:** Keep API routes thin, delegate to services\n2. **Always Validate:** Use Pydantic models for all request/response validation\n3. **Error Handling:** Use custom exceptions and exception handlers\n4. **Service Layer:** All business logic in services, not routes\n5. **Type Safety:** Use type hints throughout, leverage Pydantic models\n6. **Security:** Never expose sensitive data in error messages or logs\n7. **Consistent Responses:** Use consistent response format\n8. **Async First:** Use async/await for all I/O operations\n9. **Dependency Injection:** Use FastAPI's Depends for shared resources\n10. **Database Sessions:** Always use async sessions, manage transactions properly",
          "alwaysApply": true,
          "globs": [
            "**/app/api/**",
            "**/app/services/**",
            "**/app/repositories/**",
            "**/app/core/**"
          ]
        },
        {
          "id": "code-review",
          "title": "Code Review",
          "fileName": "code-review.mdc",
          "frontmatter": {
            "description": "Code review checklist and best practices for Python FastAPI projects",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Code Review Guidelines\n\n## Review Philosophy\n\nCode review is a collaborative process focused on:\n1. **Code Quality** - Ensuring code meets standards\n2. **Knowledge Sharing** - Learning from each other\n3. **Bug Prevention** - Catching issues before production\n4. **Consistency** - Maintaining codebase consistency\n\n## Review Checklist\n\n### Functionality\n\n- [ ] Does the code work as intended?\n- [ ] Are edge cases handled?\n- [ ] Are error cases handled properly?\n- [ ] Is the code complete (no TODOs or placeholders)?\n- [ ] Are there any obvious bugs or logic errors?\n\n### Code Quality\n\n- [ ] Does the code follow style guidelines (Black, PEP 8)?\n- [ ] Are type hints present and correct?\n- [ ] Are docstrings present for public functions?\n- [ ] Is the code readable and maintainable?\n- [ ] Are variable names descriptive (no abbreviations)?\n- [ ] Is there any code duplication that should be refactored?\n\n### Architecture\n\n- [ ] Does the code follow architectural patterns (Service Layer, Repository Pattern)?\n- [ ] Is business logic in services, not in routes?\n- [ ] Are dependencies properly injected?\n- [ ] Is the code properly organized (correct file/directory structure)?\n\n### Testing\n\n- [ ] Are there adequate tests?\n- [ ] Do tests cover edge cases?\n- [ ] Do tests follow testing guidelines?\n- [ ] Is test coverage adequate (100% for services/repositories)?\n- [ ] Are tests readable and maintainable?\n\n### Performance\n\n- [ ] Are I/O operations async?\n- [ ] Are database queries optimized (no N+1 problems)?\n- [ ] Is caching used appropriately?\n- [ ] Are heavy operations offloaded to background tasks?\n- [ ] Are there any obvious performance bottlenecks?\n\n### Security\n\n- [ ] Is input validation present (Pydantic schemas)?\n- [ ] Are authentication/authorization checks in place?\n- [ ] Are secrets properly handled (not hardcoded)?\n- [ ] Is sensitive data not logged or exposed?\n- [ ] Are SQL injection risks mitigated (using ORM)?\n\n### Error Handling\n\n- [ ] Are errors handled appropriately?\n- [ ] Are custom exceptions used where appropriate?\n- [ ] Are error messages user-friendly?\n- [ ] Are errors logged with proper context?\n\n### Documentation\n\n- [ ] Are docstrings present for public functions?\n- [ ] Is the code self-documenting (clear variable names)?\n- [ ] Are complex algorithms explained?\n- [ ] Is API documentation updated (if applicable)?\n\n## Review Process\n\n### For Authors\n\n1. **Self-Review First**\n   - Review your own code before requesting review\n   - Run all linters and tests\n   - Check that all guidelines are followed\n\n2. **Prepare PR**\n   - Write clear PR description\n   - Reference related issues\n   - Add screenshots if UI changes\n   - Keep PRs focused and small\n\n3. **Respond to Feedback**\n   - Be open to feedback\n   - Ask questions if unclear\n   - Make requested changes promptly\n   - Explain your reasoning if you disagree\n\n### For Reviewers\n\n1. **Be Constructive**\n   - Provide specific, actionable feedback\n   - Explain the \"why\" behind suggestions\n   - Acknowledge good code\n   - Be respectful and professional\n\n2. **Focus on What Matters**\n   - Prioritize functionality and correctness\n   - Don't nitpick style (tools handle that)\n   - Focus on architecture and design\n   - Consider maintainability\n\n3. **Review Promptly**\n   - Review within 24 hours if possible\n   - Don't let PRs sit for days\n   - Communicate if you need more time\n\n## Common Review Comments\n\n### Positive Feedback\n\n```python\n# ‚úÖ GOOD - Clear and concise\n# \"Great use of async/await here!\"\n# \"Excellent error handling with custom exceptions\"\n# \"Good separation of concerns between service and repository\"\n```\n\n### Constructive Feedback\n\n```python\n# ‚ùå ISSUE - Missing type hints\ndef process_data(data):\n    pass\n\n# Comment: \"Please add type hints for better type safety\"\n\n# ‚úÖ SUGGESTION\ndef process_data(data: Dict[str, Any]) -> Dict[str, Any]:\n    pass\n```\n\n### Code Examples\n\n```python\n# ‚ùå ISSUE - Business logic in route\n@router.post(\"/users\")\nasync def create_user(user_data: UserCreate):\n    # Business logic here\n    if await db.execute(select(User).where(User.email == user_data.email)):\n        raise HTTPException(...)\n    # ...\n\n# Comment: \"Please move business logic to UserService. Routes should be thin wrappers.\"\n\n# ‚úÖ SUGGESTION\n@router.post(\"/users\")\nasync def create_user(user_data: UserCreate, service: UserService = Depends(get_user_service)):\n    user = await service.create_user(user_data)\n    return UserResponse.from_orm(user)\n```\n\n## Review Scenarios\n\n### Scenario 1: New Feature\n\n**Check:**\n- [ ] Feature is complete and working\n- [ ] Tests are comprehensive\n- [ ] Documentation is updated\n- [ ] No breaking changes (or properly documented)\n- [ ] Performance considerations addressed\n\n### Scenario 2: Bug Fix\n\n**Check:**\n- [ ] Root cause is addressed, not just symptoms\n- [ ] Regression test is added\n- [ ] Similar bugs don't exist elsewhere\n- [ ] Fix doesn't introduce new issues\n\n### Scenario 3: Refactoring\n\n**Check:**\n- [ ] Functionality is unchanged\n- [ ] Tests still pass\n- [ ] Code is more maintainable\n- [ ] No performance regressions\n\n### Scenario 4: Performance Optimization\n\n**Check:**\n- [ ] Performance is actually improved (measurements provided)\n- [ ] Code readability is maintained\n- [ ] Tests are updated if needed\n- [ ] Optimization is appropriate (not premature)\n\n## Approval Criteria\n\nA PR should be approved when:\n\n1. ‚úÖ All checklist items are satisfied\n2. ‚úÖ All tests pass\n3. ‚úÖ All linters pass (no errors)\n4. ‚úÖ Code follows all guidelines\n5. ‚úÖ At least one reviewer has approved\n6. ‚úÖ All conversations are resolved\n\n## Handling Disagreements\n\n### When Reviewer and Author Disagree\n\n1. **Discuss in PR Comments**\n   - Explain your reasoning\n   - Reference guidelines or best practices\n   - Be open to different perspectives\n\n2. **Escalate if Needed**\n   - Involve team lead or senior developer\n   - Make decision based on team consensus\n   - Document decision if it's a pattern\n\n3. **Document Exceptions**\n   - If deviating from guidelines, document why\n   - Update guidelines if pattern emerges\n   - Don't create one-off exceptions\n\n## Review Tools\n\n### Automated Checks\n\n- **Linters:** ruff, mypy, black, isort\n- **Tests:** pytest with coverage\n- **Security:** bandit, safety\n- **Type Checking:** mypy\n\n### Manual Review\n\n- **Code Structure:** Architecture patterns\n- **Logic:** Business logic correctness\n- **Design:** API design, data models\n- **Documentation:** Docstrings, comments\n\n## Best Practices\n\n### For Authors\n\n1. **Keep PRs Small**\n   - One logical change per PR\n   - Easier to review and understand\n   - Faster to merge\n\n2. **Write Clear Commit Messages**\n   - Follow conventional commits\n   - Explain what and why\n   - Reference issues\n\n3. **Respond Promptly**\n   - Address feedback quickly\n   - Ask questions if unclear\n   - Don't take feedback personally\n\n### For Reviewers\n\n1. **Be Specific**\n   - Point to exact lines\n   - Provide code examples\n   - Explain the reasoning\n\n2. **Be Respectful**\n   - Critique code, not person\n   - Use \"we\" instead of \"you\"\n   - Acknowledge good work\n\n3. **Be Thorough**\n   - Check all aspects\n   - Don't rush reviews\n   - Test if possible\n\n## Remember\n\n- **Code review is a learning opportunity** - For both author and reviewer\n- **Be constructive** - Help improve the code, don't just criticize\n- **Focus on what matters** - Functionality, architecture, security\n- **Be timely** - Don't let PRs sit for days\n- **Be respectful** - We're all working toward the same goal",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "code-style-guidelines",
          "title": "Code Style Guidelines",
          "fileName": "code-style-guidelines.mdc",
          "frontmatter": {
            "description": "Comprehensive code style guide for Python following PEP 8 and modern best practices",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Code Style Guidelines\n\nYou MUST follow these coding guidelines when adding ANY code to the codebase.\n\n## 1. Code Formatting\n\n### Black Formatter\n\n- **Tool:** [Black](https://black.readthedocs.io/)\n- **Line Length:** 100 characters (default)\n- **String Quotes:** Double quotes (Black default)\n- **Trailing Commas:** Yes, for multiline structures\n\n**Configuration (`pyproject.toml`):**\n\n```toml\n[tool.black]\nline-length = 100\ntarget-version = ['py311']\ninclude = '\\.pyi?$'\n```\n\n**Usage:**\n\n```bash\n# Format all files\nblack .\n\n# Check without formatting\nblack --check .\n```\n\n### Import Sorting\n\n- **Tool:** [isort](https://pycqa.github.io/isort/)\n- **Style:** Black-compatible\n\n**Configuration (`pyproject.toml`):**\n\n```toml\n[tool.isort]\nprofile = \"black\"\nline_length = 100\nknown_first_party = [\"app\"]\n```\n\n## 2. Type Hints\n\n### Mandatory Type Hints\n\nAll functions must have type hints:\n\n```python\n# ‚ùå BAD - No type hints\ndef process_user(user_data):\n    return user_data\n\n# ‚úÖ GOOD - Type hints included\ndef process_user(user_data: dict) -> dict:\n    return user_data\n\n# ‚úÖ BETTER - Specific types\nfrom typing import Dict, Any\n\ndef process_user(user_data: Dict[str, Any]) -> Dict[str, Any]:\n    return user_data\n\n# ‚úÖ BEST - Use Pydantic models\nfrom app.schemas.user import UserCreate, UserResponse\n\ndef process_user(user_data: UserCreate) -> UserResponse:\n    return UserResponse.from_orm(user_data)\n```\n\n### Type Hint Best Practices\n\n```python\nfrom typing import Optional, List, Dict, Union, Any\nfrom datetime import datetime\n\n# Optional types\ndef get_user(user_id: Optional[int] = None) -> Optional[User]:\n    pass\n\n# Lists and Dicts\ndef process_items(items: List[str]) -> Dict[str, int]:\n    pass\n\n# Union types (Python 3.10+)\ndef process_value(value: int | str) -> None:\n    pass\n\n# Async functions\nasync def fetch_data(url: str) -> Dict[str, Any]:\n    pass\n\n# Forward references (use __future__ import)\nfrom __future__ import annotations\n\ndef process_user(user: \"User\") -> \"UserResponse\":\n    pass\n```\n\n## 3. Naming Conventions\n\n### Variables and Functions\n\n- **Style:** `snake_case`\n- **NEVER abbreviate variables** - Always use full, descriptive names\n- Single-letter variables are forbidden except for standard mathematical conventions (e.g., `x`, `y` in coordinate systems, `i` in mathematical contexts)\n\n```python\n# ‚ùå BAD - Abbreviated variables\nworkflows.filter((w) => w.status == 'active')\ndata.map((p) => p.id == temp_id ? new_post : p)\nusers.map((u) => u.id)\n\n# ‚úÖ GOOD - Full descriptive names\nworkflows.filter((workflow) => workflow.status == 'active')\ndata.map((post) => post.id == temp_id ? new_post : post)\nusers.map((user) => user.id)\n\n# ‚ùå BAD - Single letter (except math)\nfor i in range(10):  # OK for loop index\nfor item in items:  # Better\n\n# ‚úÖ GOOD - Descriptive names\nfor user in users:\n    process_user(user)\n\nfor workflow_item in workflow_items:\n    process_workflow_item(workflow_item)\n```\n\n### Classes\n\n- **Style:** `PascalCase`\n\n```python\nclass UserService:\n    pass\n\nclass UserRepository:\n    pass\n\nclass HTTPClient:\n    pass\n```\n\n### Constants\n\n- **Style:** `UPPER_SNAKE_CASE`\n\n```python\nMAX_RETRY_ATTEMPTS = 3\nDEFAULT_TIMEOUT = 30\nAPI_BASE_URL = \"https://api.example.com\"\n```\n\n### Private Methods/Attributes\n\n- **Style:** Leading underscore for private\n\n```python\nclass UserService:\n    def __init__(self):\n        self._cache: Dict[str, Any] = {}\n    \n    def _internal_method(self) -> None:\n        pass\n    \n    def public_method(self) -> None:\n        pass\n```\n\n## 4. Imports\n\n### Import Order\n\n1. Standard library imports\n2. Third-party imports\n3. Local application imports\n\n```python\n# Standard library\nfrom datetime import datetime\nfrom typing import Optional, List\n\n# Third-party\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\n# Local\nfrom app.core.config import settings\nfrom app.models.domain.user import User\nfrom app.services.user_service import UserService\n```\n\n### Import Style\n\n```python\n# ‚úÖ GOOD - Absolute imports\nfrom app.services.user_service import UserService\n\n# ‚ùå BAD - Relative imports (avoid)\nfrom ..services.user_service import UserService\n\n# ‚úÖ GOOD - Group related imports\nfrom fastapi import APIRouter, Depends, HTTPException, status\n\n# ‚úÖ GOOD - Import only what you need\nfrom app.models.domain.user import User  # Not: from app.models.domain import *\n\n# ‚úÖ GOOD - Use aliases for clarity\nfrom app.core.logging import get_logger as get_app_logger\n```\n\n## 5. Functions\n\n### Function Definitions\n\n```python\n# ‚úÖ GOOD - Type hints, docstring\ndef get_user_by_id(user_id: int, include_inactive: bool = False) -> Optional[User]:\n    \"\"\"\n    Get user by ID.\n    \n    Args:\n        user_id: The user ID to look up\n        include_inactive: Whether to include inactive users\n    \n    Returns:\n        User object if found, None otherwise\n    \"\"\"\n    pass\n\n# ‚úÖ GOOD - Async functions\nasync def fetch_user_data(user_id: int) -> Dict[str, Any]:\n    \"\"\"Fetch user data from external API.\"\"\"\n    pass\n\n# ‚úÖ GOOD - Multiple parameters, trailing comma\ndef process_data(\n    data: List[Dict[str, Any]],\n    options: Optional[Dict[str, Any]] = None,\n    validate: bool = True,\n) -> Dict[str, Any]:\n    pass\n```\n\n### Function Best Practices\n\n```python\n# ‚úÖ GOOD - Single responsibility\ndef calculate_total(items: List[Item]) -> float:\n    \"\"\"Calculate total price of items.\"\"\"\n    return sum(item.price for item in items)\n\n# ‚ùå BAD - Multiple responsibilities\ndef process_order(order: Order) -> None:\n    # Validates order\n    # Calculates total\n    # Sends email\n    # Updates database\n    # Logs activity\n    pass\n\n# ‚úÖ GOOD - Small, focused functions\ndef validate_order(order: Order) -> bool:\n    pass\n\ndef calculate_order_total(order: Order) -> float:\n    pass\n\ndef send_order_confirmation(order: Order) -> None:\n    pass\n```\n\n## 6. Classes\n\n### Class Definitions\n\n```python\n# ‚úÖ GOOD - Type hints, docstring\nclass UserService:\n    \"\"\"Service for user-related business logic.\"\"\"\n    \n    def __init__(self, db: AsyncSession) -> None:\n        \"\"\"Initialize user service.\"\"\"\n        self.db = db\n        self.repository = UserRepository(db)\n    \n    async def get_user_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        pass\n\n# ‚úÖ GOOD - Dataclasses for simple data structures\nfrom dataclasses import dataclass\n\n@dataclass\nclass UserConfig:\n    \"\"\"User configuration.\"\"\"\n    max_items: int = 10\n    timeout: int = 30\n```\n\n## 7. Docstrings\n\n### Google-Style Docstrings\n\n```python\ndef process_user_data(\n    user_id: int,\n    include_metadata: bool = False,\n) -> Dict[str, Any]:\n    \"\"\"\n    Process user data and return formatted result.\n    \n    This function fetches user data from the database, applies\n    transformations, and returns a formatted dictionary.\n    \n    Args:\n        user_id: The ID of the user to process\n        include_metadata: Whether to include metadata in the result\n    \n    Returns:\n        Dictionary containing processed user data with keys:\n        - id: User ID\n        - name: User name\n        - email: User email\n        - metadata: Optional metadata dict (if include_metadata is True)\n    \n    Raises:\n        NotFoundError: If user with given ID doesn't exist\n        ValidationError: If user data is invalid\n    \n    Example:\n        >>> result = process_user_data(123, include_metadata=True)\n        >>> print(result['name'])\n        'John Doe'\n    \"\"\"\n    pass\n```\n\n## 8. Async/Await\n\n### Async Best Practices\n\n```python\n# ‚úÖ GOOD - Async for I/O operations\nasync def fetch_user(user_id: int) -> User:\n    \"\"\"Fetch user from database.\"\"\"\n    async with AsyncSession() as session:\n        result = await session.execute(select(User).where(User.id == user_id))\n        return result.scalar_one()\n\n# ‚úÖ GOOD - Async context managers\nasync def process_file(file_path: str) -> None:\n    async with aiofiles.open(file_path, 'r') as f:\n        content = await f.read()\n        await process_content(content)\n\n# ‚ùå BAD - Blocking I/O in async function\nasync def fetch_user(user_id: int) -> User:\n    # ‚ùå Don't use blocking I/O\n    with open('file.txt') as f:\n        content = f.read()\n    \n    # ‚úÖ Use async I/O\n    async with aiofiles.open('file.txt') as f:\n        content = await f.read()\n```\n\n## 9. Error Handling\n\n### Exception Handling\n\n```python\n# ‚úÖ GOOD - Specific exceptions\ntry:\n    user = await user_service.get_user_by_id(user_id)\nexcept NotFoundError:\n    raise HTTPException(status_code=404, detail=\"User not found\")\nexcept ValidationError as e:\n    raise HTTPException(status_code=400, detail=str(e))\n\n# ‚ùå BAD - Bare except\ntry:\n    user = await user_service.get_user_by_id(user_id)\nexcept:  # Too broad\n    pass\n\n# ‚úÖ GOOD - Log and re-raise\ntry:\n    result = await risky_operation()\nexcept Exception as e:\n    logger.error(\"Operation failed\", exc_info=True)\n    raise\n```\n\n## 10. Comments\n\n### Comment Style\n\n```python\n# ‚úÖ GOOD - Single-line comments\n# Process user data before saving\nuser_data = process_user_data(raw_data)\n\n# ‚úÖ GOOD - Inline comments (sparingly)\ntotal = price * quantity  # Calculate total including tax\n\n# ‚úÖ GOOD - Block comments for complex logic\n# This algorithm uses a two-pass approach:\n# 1. First pass: collect all items\n# 2. Second pass: process items in batches\nresult = process_items(items)\n\n# ‚ùå BAD - Obvious comments\n# Increment counter\ncounter += 1\n\n# ‚ùå BAD - Commented-out code\n# old_code()\n```\n\n## 11. Whitespace\n\n### Indentation\n\n- **Spaces:** 4 spaces (never tabs)\n- **Continuation:** Align with opening delimiter\n\n```python\n# ‚úÖ GOOD - 4 spaces\ndef function():\n    if condition:\n        do_something()\n\n# ‚úÖ GOOD - Aligned continuation\nresult = process_data(\n    data=user_data,\n    options=processing_options,\n    validate=True,\n)\n\n# ‚ùå BAD - Tabs or wrong indentation\ndef function():\n\tif condition:  # Tab instead of spaces\n\t\tdo_something()\n```\n\n### Blank Lines\n\n- Two blank lines between top-level definitions\n- One blank line between methods in a class\n- No blank lines at start/end of file\n\n```python\n# ‚úÖ GOOD\nimport os\n\nfrom app.core.config import settings\n\n\nclass UserService:\n    \"\"\"User service.\"\"\"\n    \n    def __init__(self):\n        pass\n    \n    def method_one(self):\n        pass\n    \n    def method_two(self):\n        pass\n\n\ndef helper_function():\n    pass\n```\n\n## 12. Line Length\n\n- **Maximum:** 100 characters\n- **Exceptions:** Long URLs, import statements\n\n```python\n# ‚úÖ GOOD - Within limit\ndef process_user_data(user_id: int, include_metadata: bool = False) -> Dict[str, Any]:\n    pass\n\n# ‚úÖ GOOD - Break long lines\ndef process_user_data(\n    user_id: int,\n    include_metadata: bool = False,\n    validate_input: bool = True,\n) -> Dict[str, Any]:\n    pass\n\n# ‚úÖ GOOD - Long strings can exceed limit\nlong_url = \"https://very-long-url-that-exceeds-100-characters.com/path/to/resource\"\n```\n\n## 13. Comprehensions\n\n### List/Dict Comprehensions\n\n```python\n# ‚úÖ GOOD - Simple comprehensions\nsquares = [x**2 for x in range(10)]\nuser_dict = {user.id: user.name for user in users}\n\n# ‚úÖ GOOD - Complex comprehensions (multiline)\nfiltered_users = [\n    user for user in users\n    if user.is_active and user.email.endswith('@example.com')\n]\n\n# ‚ùå BAD - Too complex, use loop instead\nresult = [process(x) for x in data if validate(x) and transform(x) and check(x)]\n```\n\n## 14. String Formatting\n\n### f-strings (Preferred)\n\n```python\n# ‚úÖ GOOD - f-strings\nname = \"John\"\nmessage = f\"Hello, {name}!\"\n\n# ‚úÖ GOOD - f-strings with expressions\ntotal = 100\nmessage = f\"Total: ${total:.2f}\"\n\n# ‚úÖ GOOD - Multiline f-strings\nmessage = (\n    f\"User {user.name} (ID: {user.id}) \"\n    f\"has {len(user.items)} items\"\n)\n```\n\n### Format Method\n\n```python\n# ‚úÖ ACCEPTABLE - .format() for complex formatting\nmessage = \"User {name} has {count} items\".format(\n    name=user.name,\n    count=len(user.items)\n)\n\n# ‚ùå BAD - % formatting (old style)\nmessage = \"User %s has %d items\" % (user.name, len(user.items))\n```\n\n## 15. Testing\n\n### Test Function Names\n\n```python\n# ‚úÖ GOOD - Descriptive test names\ndef test_get_user_by_id_returns_user_when_exists():\n    pass\n\ndef test_get_user_by_id_raises_not_found_when_missing():\n    pass\n\n# ‚ùå BAD - Vague test names\ndef test_user():\n    pass\n\ndef test_get_user():\n    pass\n```\n\n## 16. Pre-commit Hooks\n\n**Configuration (`.pre-commit-config.yaml`):**\n\n```yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 23.9.1\n    hooks:\n      - id: black\n  \n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n  \n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n  \n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.0.292\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n```\n\n## Remember\n\n- **Follow PEP 8** - Python style guide\n- **Use Black** - Automatic code formatting\n- **Type Hints** - Mandatory for all functions\n- **Descriptive Names** - Never abbreviate\n- **Docstrings** - Google-style for all public functions\n- **Async First** - Use async/await for I/O\n- **100 Char Limit** - Maximum line length",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "commenting-guidelines",
          "title": "Commenting Guidelines",
          "fileName": "commenting-guidelines.mdc",
          "frontmatter": {
            "description": "Commenting and documentation standards for Python FastAPI codebase",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Commenting Guidelines\n\n## Philosophy\n\nComments should explain the **\"why\"** and **\"intent\"**, not the **\"what\"**. The code itself should be self-documenting through clear variable names, type hints, and structure.\n\n## When to Comment\n\n### ‚úÖ DO Comment\n\n1. **Public APIs** - All public functions, classes, and methods\n2. **Complex Logic** - Non-obvious algorithms or business rules\n3. **Non-Obvious Decisions** - Why a particular approach was chosen\n4. **Workarounds** - Temporary fixes or known issues\n5. **Performance Considerations** - Why a specific optimization was made\n6. **Business Rules** - Domain-specific logic that isn't obvious from code\n\n### ‚ùå DON'T Comment\n\n1. **Obvious Code** - Code that is self-explanatory\n2. **Type Duplication** - Don't repeat what type hints already say\n3. **Version Control Info** - Don't include git history in comments\n4. **Commented-Out Code** - Delete it, don't comment it out\n5. **Implementation Details** - Focus on intent, not how it's done\n\n## Docstring Format\n\nUse **Google-style docstrings** for all public functions, classes, and methods.\n\n### Function Docstrings\n\n```python\ndef get_user_by_id(\n    user_id: int,\n    include_inactive: bool = False,\n) -> Optional[User]:\n    \"\"\"\n    Get user by ID from the database.\n    \n    This function retrieves a user by their unique identifier. It can optionally\n    include inactive users in the search.\n    \n    Args:\n        user_id: The unique identifier of the user to retrieve\n        include_inactive: If True, includes inactive users in the search.\n            Defaults to False.\n    \n    Returns:\n        User object if found, None if user doesn't exist or is inactive\n        (when include_inactive is False).\n    \n    Raises:\n        ValidationError: If user_id is not a positive integer.\n        DatabaseError: If database query fails.\n    \n    Example:\n        >>> user = get_user_by_id(123)\n        >>> print(user.email)\n        'user@example.com'\n        \n        >>> inactive_user = get_user_by_id(456, include_inactive=True)\n    \"\"\"\n    pass\n```\n\n### Class Docstrings\n\n```python\nclass UserService:\n    \"\"\"\n    Service for user-related business logic.\n    \n    This service encapsulates all business logic related to user management,\n    including user creation, updates, and retrieval. It acts as an intermediary\n    between API routes and the repository layer.\n    \n    Attributes:\n        db: Database session for data access\n        repository: User repository instance\n    \n    Example:\n        >>> service = UserService(db_session)\n        >>> user = await service.create_user(user_data)\n        >>> print(user.email)\n    \"\"\"\n    \n    def __init__(self, db: AsyncSession) -> None:\n        \"\"\"Initialize user service with database session.\"\"\"\n        self.db = db\n        self.repository = UserRepository(db)\n```\n\n### Method Docstrings\n\n```python\nclass UserService:\n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"\n        Create a new user in the system.\n        \n        This method validates the user data, checks for duplicate emails,\n        hashes the password, and creates the user record. It also sends\n        a welcome email asynchronously.\n        \n        Args:\n            user_data: Pydantic model containing user creation data\n        \n        Returns:\n            Created User object with generated ID\n        \n        Raises:\n            ConflictError: If user with same email already exists\n            ValidationError: If user data fails validation\n        \n        Note:\n            Password is automatically hashed before storage. The original\n            password is never stored in plain text.\n        \"\"\"\n        pass\n```\n\n## Inline Comments\n\n### When to Use Inline Comments\n\n```python\n# ‚úÖ GOOD - Explains why, not what\n# Use async here because we're making multiple I/O calls\nresults = await asyncio.gather(\n    fetch_user_data(user_id),\n    fetch_user_posts(user_id),\n    fetch_user_comments(user_id),\n)\n\n# ‚úÖ GOOD - Explains business rule\n# Users created before 2020 are grandfathered into the old pricing model\nif user.created_at < datetime(2020, 1, 1):\n    apply_legacy_pricing(user)\n\n# ‚úÖ GOOD - Explains non-obvious decision\n# Using selectinload instead of joinedload to avoid cartesian product\n# when loading user posts and comments simultaneously\nusers = await session.execute(\n    select(User).options(\n        selectinload(User.posts),\n        selectinload(User.comments),\n    )\n)\n\n# ‚ùå BAD - States the obvious\n# Increment the counter\ncounter += 1\n\n# ‚ùå BAD - Repeats what code says\n# Get user by ID\nuser = get_user_by_id(user_id)\n\n# ‚ùå BAD - Commented-out code\n# old_code()\n# if old_condition:\n#     do_something()\n```\n\n## TODO Comments\n\nUse TODO comments sparingly and include context:\n\n```python\n# ‚úÖ GOOD - Specific TODO with context\n# TODO: Refactor this when we migrate to Redis caching\n# Current in-memory cache will be replaced with Redis in Q2\ndef get_cached_user(user_id: int) -> Optional[User]:\n    pass\n\n# ‚ùå BAD - Vague TODO\n# TODO: Fix this later\ndef broken_function():\n    pass\n```\n\n## FIXME Comments\n\nUse FIXME for known issues that need attention:\n\n```python\n# ‚úÖ GOOD - Explains the issue and workaround\n# FIXME: This is a workaround for a bug in external API v1.2\n# Remove when external API is updated to v1.3 (expected Q2)\nresponse = await external_api.get_data()\nif response.status_code == 500:\n    # Retry with legacy endpoint\n    response = await external_api.get_data_legacy()\n\n# ‚ùå BAD - Vague FIXME\n# FIXME: This doesn't work\ndef broken_function():\n    pass\n```\n\n## Type Hints vs Comments\n\nType hints eliminate the need for many comments:\n\n```python\n# ‚ùå BAD - Comment describes type\n# user_id is an integer\ndef get_user(user_id):\n    pass\n\n# ‚úÖ GOOD - Type hint is self-documenting\ndef get_user(user_id: int) -> Optional[User]:\n    pass\n```\n\n## Complex Logic Comments\n\nFor complex algorithms, explain the approach:\n\n```python\ndef calculate_user_score(user: User) -> float:\n    \"\"\"\n    Calculate user engagement score.\n    \n    Uses a weighted algorithm that considers:\n    - Post frequency (40% weight)\n    - Comment activity (30% weight)\n    - Login frequency (20% weight)\n    - Profile completeness (10% weight)\n    \n    Returns a score between 0.0 and 100.0.\n    \"\"\"\n    # Calculate time-weighted post frequency\n    # More recent posts have higher weight\n    post_score = calculate_post_score(user.posts)\n    \n    # Calculate comment engagement\n    # Comments on others' posts count more than own posts\n    comment_score = calculate_comment_score(user.comments)\n    \n    # ... rest of calculation\n    return final_score\n```\n\n## API Documentation Comments\n\nFor API endpoints, document request/response:\n\n```python\n@router.post(\"/users\", response_model=UserResponse, status_code=201)\nasync def create_user(\n    user_data: UserCreate,\n    current_user: User = Depends(get_current_admin),\n) -> UserResponse:\n    \"\"\"\n    Create a new user account.\n    \n    This endpoint allows administrators to create new user accounts.\n    The user will receive a welcome email with login credentials.\n    \n    **Request Body:**\n    - email: Valid email address (required)\n    - full_name: User's full name (required, 1-255 chars)\n    - password: Password (required, min 8 chars)\n    - is_active: Whether account is active (default: true)\n    \n    **Response:**\n    - 201: User created successfully\n    - 400: Validation error\n    - 401: Unauthorized (not admin)\n    - 409: User with email already exists\n    \n    **Example Request:**\n    ```json\n    {\n        \"email\": \"user@example.com\",\n        \"full_name\": \"John Doe\",\n        \"password\": \"securepassword123\"\n    }\n    ```\n    \"\"\"\n    pass\n```\n\n## Module-Level Docstrings\n\nDocument modules at the top:\n\n```python\n\"\"\"\nUser service module.\n\nThis module contains the UserService class which handles all business logic\nrelated to user management, including:\n- User creation and updates\n- User authentication\n- User profile management\n- User permissions\n\nThe service acts as an intermediary between API routes and the repository\nlayer, ensuring business rules are enforced and data is properly validated.\n\"\"\"\n```\n\n## Best Practices\n\n1. **Write Self-Documenting Code**\n   - Use descriptive variable names\n   - Use type hints\n   - Keep functions small and focused\n   - Then add comments only where needed\n\n2. **Keep Comments Up to Date**\n   - Update comments when code changes\n   - Delete outdated comments\n   - Don't let comments drift from code\n\n3. **Use Docstrings for Public APIs**\n   - All public functions need docstrings\n   - Private functions may not need them if code is clear\n   - Classes always need docstrings\n\n4. **Explain Why, Not What**\n   - Code shows what it does\n   - Comments explain why it does it\n   - Focus on intent and reasoning\n\n5. **Be Concise**\n   - Don't write novels\n   - Be clear and to the point\n   - Use examples when helpful\n\n## Common Patterns\n\n### Pattern 1: Business Rule Explanation\n\n```python\n# ‚úÖ GOOD\n# Users created before 2020 are exempt from the new verification process\n# This is a grandfather clause from the legacy system\nif user.created_at < datetime(2020, 1, 1):\n    return skip_verification(user)\n```\n\n### Pattern 2: Performance Optimization\n\n```python\n# ‚úÖ GOOD\n# Using selectinload to avoid N+1 query problem\n# This loads all user posts in a single additional query\nusers = await session.execute(\n    select(User).options(selectinload(User.posts))\n)\n```\n\n### Pattern 3: Workaround\n\n```python\n# ‚úÖ GOOD\n# FIXME: Workaround for bug in external API v1.2\n# The API returns 500 for valid requests with special characters\n# Expected fix in v1.3 (Q2 2024)\nif \"special_char\" in request_data:\n    request_data = sanitize_special_chars(request_data)\n```\n\n## Remember\n\n- **Code > Comments** - Write clear code first\n- **Explain Why** - Focus on intent and reasoning\n- **Keep Updated** - Maintain comments with code\n- **Public APIs** - Always document public functions\n- **Be Concise** - Don't over-comment obvious code",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "configuration-management",
          "title": "Configuration Management",
          "fileName": "configuration-management.mdc",
          "frontmatter": {
            "description": "Configuration management best practices for Python FastAPI applications",
            "globs": [
              "**/app/core/config.py",
              "**/.env*"
            ],
            "alwaysApply": true
          },
          "content": "# Configuration Management\n\n## Pydantic Settings\n\n### Using Pydantic Settings\n\n```python\n# app/core/config.py\nfrom pydantic_settings import BaseSettings\nfrom pydantic import Field, validator\nfrom typing import List, Optional\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    \n    # Application\n    APP_NAME: str = \"My FastAPI App\"\n    DEBUG: bool = False\n    ENVIRONMENT: str = Field(default=\"development\", env=\"ENV\")\n    \n    # API\n    API_V1_PREFIX: str = \"/api/v1\"\n    API_TITLE: str = \"My API\"\n    API_VERSION: str = \"1.0.0\"\n    \n    # Security\n    SECRET_KEY: str = Field(..., min_length=32)\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    \n    # Database\n    DATABASE_URL: str = Field(...)\n    DB_POOL_SIZE: int = 20\n    DB_MAX_OVERFLOW: int = 10\n    \n    # Redis\n    REDIS_URL: str = Field(default=\"redis://localhost:6379\")\n    \n    # CORS\n    ALLOWED_ORIGINS: List[str] = Field(default=[\"http://localhost:3000\"])\n    \n    # Logging\n    LOG_LEVEL: str = Field(default=\"INFO\")\n    \n    @validator(\"ALLOWED_ORIGINS\", pre=True)\n    def parse_cors_origins(cls, v):\n        \"\"\"Parse CORS origins from string or list.\"\"\"\n        if isinstance(v, str):\n            return [origin.strip() for origin in v.split(\",\")]\n        return v\n    \n    @validator(\"ENVIRONMENT\")\n    def validate_environment(cls, v):\n        \"\"\"Validate environment value.\"\"\"\n        allowed = [\"development\", \"staging\", \"production\"]\n        if v not in allowed:\n            raise ValueError(f\"ENVIRONMENT must be one of {allowed}\")\n        return v\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        case_sensitive = True\n\n\nsettings = Settings()\n```\n\n## Environment Variables\n\n### .env File Structure\n\n```bash\n# .env.example (template)\n# Application\nAPP_NAME=My FastAPI App\nDEBUG=false\nENVIRONMENT=development\n\n# Security\nSECRET_KEY=your-secret-key-here-minimum-32-characters-long\nALGORITHM=HS256\nACCESS_TOKEN_EXPIRE_MINUTES=30\n\n# Database\nDATABASE_URL=postgresql+asyncpg://user:password@localhost/dbname\n\n# Redis\nREDIS_URL=redis://localhost:6379\n\n# CORS\nALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001\n\n# Logging\nLOG_LEVEL=INFO\n```\n\n### Environment-Specific Files\n\n```bash\n# .env.development\nDEBUG=true\nLOG_LEVEL=DEBUG\nDATABASE_URL=postgresql+asyncpg://user:password@localhost/dev_db\n\n# .env.production\nDEBUG=false\nLOG_LEVEL=WARNING\nDATABASE_URL=postgresql+asyncpg://user:password@prod-host/prod_db\n```\n\n## Configuration Loading\n\n### Load Based on Environment\n\n```python\n# app/core/config.py\nimport os\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    \n    ENVIRONMENT: str = Field(default=\"development\")\n    \n    @classmethod\n    def load_from_env(cls) -> \"Settings\":\n        \"\"\"Load settings based on environment.\"\"\"\n        env = os.getenv(\"ENVIRONMENT\", \"development\")\n        env_file = f\".env.{env}\"\n        \n        return cls(\n            _env_file=env_file if os.path.exists(env_file) else \".env\",\n        )\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\nsettings = Settings.load_from_env()\n```\n\n## Secrets Management\n\n### Never Commit Secrets\n\n```bash\n# .gitignore\n.env\n.env.local\n.env*.local\n*.key\n*.pem\nsecrets/\n```\n\n### Use Secret Managers in Production\n\n```python\n# app/core/secrets.py\nimport os\nfrom typing import Optional\n\ndef get_secret_from_env(secret_name: str, default: Optional[str] = None) -> str:\n    \"\"\"Get secret from environment variable.\"\"\"\n    secret = os.getenv(secret_name, default)\n    if secret is None:\n        raise ValueError(f\"Secret {secret_name} not found\")\n    return secret\n\n# For AWS Secrets Manager\nimport boto3\n\ndef get_secret_from_aws(secret_name: str) -> str:\n    \"\"\"Get secret from AWS Secrets Manager.\"\"\"\n    client = boto3.client('secretsmanager', region_name='us-east-1')\n    response = client.get_secret_value(SecretId=secret_name)\n    return response['SecretString']\n```\n\n## Configuration Validation\n\n### Validate at Startup\n\n```python\n# app/main.py\nfrom app.core.config import settings\n\ndef validate_settings():\n    \"\"\"Validate settings at startup.\"\"\"\n    if settings.ENVIRONMENT == \"production\" and settings.DEBUG:\n        raise ValueError(\"DEBUG must be False in production\")\n    \n    if len(settings.SECRET_KEY) < 32:\n        raise ValueError(\"SECRET_KEY must be at least 32 characters\")\n    \n    if not settings.DATABASE_URL:\n        raise ValueError(\"DATABASE_URL is required\")\n\n# Validate on startup\nvalidate_settings()\n```\n\n## Configuration Documentation\n\n### Document Configuration Options\n\n```python\n# app/core/config.py\nclass Settings(BaseSettings):\n    \"\"\"\n    Application settings.\n    \n    All settings can be overridden via environment variables.\n    See .env.example for all available options.\n    \n    Environment Variables:\n        APP_NAME: Application name\n        DEBUG: Enable debug mode (default: False)\n        ENVIRONMENT: Environment (development|staging|production)\n        SECRET_KEY: Secret key for JWT (required, min 32 chars)\n        DATABASE_URL: Database connection URL (required)\n        REDIS_URL: Redis connection URL\n        ALLOWED_ORIGINS: Comma-separated list of allowed CORS origins\n        LOG_LEVEL: Logging level (DEBUG|INFO|WARNING|ERROR)\n    \"\"\"\n    pass\n```\n\n## Best Practices\n\n1. **Use Pydantic Settings** - Type-safe configuration\n2. **Environment Variables** - For all configuration\n3. **Never Commit Secrets** - Use .gitignore\n4. **Validate at Startup** - Catch errors early\n5. **Document Options** - Help developers understand\n6. **Environment-Specific** - Different configs per environment\n7. **Secret Managers** - Use in production\n8. **Defaults** - Provide sensible defaults\n\n## Remember\n\n- **Never hardcode** - Use environment variables\n- **Never commit secrets** - Use .gitignore\n- **Validate early** - Check at startup\n- **Type safety** - Use Pydantic Settings\n- **Documentation** - Document all options\n- **Environment-specific** - Different configs per environment",
          "alwaysApply": true,
          "globs": [
            "**/app/core/config.py",
            "**/.env*"
          ]
        },
        {
          "id": "conflict-resolution",
          "title": "Conflict Resolution",
          "fileName": "conflict-resolution.mdc",
          "frontmatter": {
            "description": "Guidance for resolving rule conflicts and handling exceptions",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Conflict Resolution\n\n## Overview\n\nWhen coding guidelines conflict or when exceptions are needed, this document provides guidance on how to resolve conflicts and document exceptions.\n\n## Priority Hierarchy\n\nWhen rules conflict, follow this priority order:\n\n1. **Security Guidelines** - Security always takes precedence\n2. **No Hiding Rule** - Never suppress errors or warnings\n3. **Core Framework & Language** - Framework requirements\n4. **Error Handling Patterns** - Consistent error handling\n5. **Code Style Guidelines** - Formatting and style\n6. **Performance Guidelines** - Optimization considerations\n7. **Commenting Guidelines** - Documentation standards\n\n## Common Conflict Scenarios\n\n### Scenario 1: Performance vs Code Style\n\n**Conflict:** Performance optimization requires less readable code\n\n**Resolution:**\n- Optimize for performance when there's measurable impact\n- Add comments explaining the optimization\n- Consider if the optimization is necessary\n\n**Example:**\n\n```python\n# Performance requires complex query\n# Style prefers simpler code\n# Resolution: Optimize, but document why\n\n# ‚úÖ GOOD - Optimized with explanation\n# Using raw SQL for performance - this query processes 1M+ rows\n# The ORM version is 10x slower due to object overhead\nresult = await session.execute(\n    text(\"SELECT user_id, COUNT(*) FROM posts GROUP BY user_id\")\n)\n```\n\n### Scenario 2: Type Safety vs Flexibility\n\n**Conflict:** Strict type hints vs need for flexibility\n\n**Resolution:**\n- Prefer type safety\n- Use Union types or TypeVar for flexibility\n- Avoid `Any` unless absolutely necessary\n\n**Example:**\n\n```python\n# Type safety requires specific types\n# Flexibility needs generic handling\n# Resolution: Use generics\n\n# ‚úÖ GOOD - Type-safe and flexible\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\n\nclass Repository(Generic[T]):\n    async def get_by_id(self, id: int) -> Optional[T]:\n        pass\n```\n\n### Scenario 3: Async vs Synchronous Code\n\n**Conflict:** Some libraries only have sync versions\n\n**Resolution:**\n- Prefer async when possible\n- Wrap sync code in executor if needed\n- Document why sync code is used\n\n**Example:**\n\n```python\n# Async preferred, but library is sync-only\n# Resolution: Use executor, document\n\n# ‚úÖ GOOD - Wrapped sync code\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nexecutor = ThreadPoolExecutor(max_workers=4)\n\nasync def process_with_sync_library(data: dict) -> dict:\n    \"\"\"\n    Process data using sync-only library.\n    \n    Note: Library doesn't support async, so we use executor\n    to avoid blocking the event loop.\n    \"\"\"\n    loop = asyncio.get_event_loop()\n    return await loop.run_in_executor(\n        executor,\n        sync_library.process,\n        data\n    )\n```\n\n### Scenario 4: Logging vs Performance\n\n**Conflict:** Logging guidelines vs performance requirements\n\n**Resolution:**\n- Log errors and critical operations\n- Use appropriate log levels\n- Consider async logging for high-volume scenarios\n\n**Example:**\n\n```python\n# Logging guidelines require logging\n# Performance requires minimal overhead\n# Resolution: Use appropriate log levels\n\n# ‚úÖ GOOD - Log errors, skip verbose logging in hot path\nasync def process_request(request: Request) -> Response:\n    # Don't log every request (performance)\n    # But log errors (required)\n    try:\n        result = await process_data(request.data)\n        return Response(data=result)\n    except Exception as e:\n        logger.error(\"Request processing failed\", exc_info=True)  # Required\n        raise\n```\n\n## Exception Documentation\n\nWhen deviating from guidelines, document why:\n\n### Format\n\n```python\n# EXCEPTION: [Rule Name]\n# Reason: [Why exception is needed]\n# Duration: [Temporary or permanent]\n# TODO: [If temporary, what needs to happen]\n\n# Example:\n# EXCEPTION: Code Style Guidelines - Line Length\n# Reason: Long URL cannot be broken without breaking functionality\n# Duration: Permanent (external API URL)\n# TODO: N/A\nlong_url = \"https://very-long-external-api-url-that-cannot-be-broken.com/endpoint\"\n```\n\n### When to Document Exceptions\n\n1. **Temporary Workarounds** - Document and add TODO\n2. **Performance Requirements** - Explain the trade-off\n3. **External Constraints** - Document the limitation\n4. **Legacy Code** - Note why it can't be changed yet\n\n## Decision Process\n\n### Step 1: Identify the Conflict\n\n- What rules are conflicting?\n- What are the trade-offs?\n- What is the impact?\n\n### Step 2: Evaluate Options\n\n- Can both rules be satisfied?\n- What's the best compromise?\n- What are the consequences?\n\n### Step 3: Make Decision\n\n- Choose based on priority hierarchy\n- Document the decision\n- Consider team input\n\n### Step 4: Document Exception\n\n- Add comment explaining exception\n- Reference this document if needed\n- Update guidelines if pattern emerges\n\n## Team Consensus\n\nFor significant conflicts:\n\n1. **Discuss in PR Comments** - Get team input\n2. **Escalate to Team Lead** - For architectural decisions\n3. **Update Guidelines** - If pattern becomes common\n4. **Document Decision** - For future reference\n\n## Updating Guidelines\n\nIf exceptions become common:\n\n1. **Identify Pattern** - Is this exception happening frequently?\n2. **Evaluate Rule** - Is the rule too strict or wrong?\n3. **Propose Change** - Update the guideline\n4. **Team Review** - Get consensus on change\n5. **Update Documentation** - Reflect new guideline\n\n## Examples\n\n### Example 1: Temporary Exception\n\n```python\n# EXCEPTION: Error Handling Patterns\n# Reason: External API has inconsistent error responses\n# Duration: Temporary - until external API v2 is released (Q2 2024)\n# TODO: Update when external API v2 is available\ntry:\n    response = await external_api.get_data()\nexcept Exception as e:\n    # External API sometimes returns 200 with error in body\n    # This is a known issue they're fixing in v2\n    if \"error\" in str(e).lower():\n        raise ExternalServiceError(\"External API error\")\n    raise\n```\n\n### Example 2: Performance Exception\n\n```python\n# EXCEPTION: Code Style Guidelines - Function Complexity\n# Reason: Performance-critical path requires optimized algorithm\n# Duration: Permanent\n# TODO: N/A\n# Note: This function is called millions of times per day\n# Optimizations are necessary for acceptable performance\ndef optimized_calculation(data: List[float]) -> float:\n    # Complex algorithm for performance\n    # See performance-guidelines.mdc for optimization rationale\n    pass\n```\n\n### Example 3: External Constraint\n\n```python\n# EXCEPTION: Type Hints - Using Any\n# Reason: Third-party library returns untyped data\n# Duration: Until library adds type stubs\n# TODO: Create type stubs for library or wait for official types\nfrom typing import Any\n\ndef process_third_party_data(data: Any) -> dict:  # Any required by library\n    \"\"\"Process data from third-party library without type stubs.\"\"\"\n    # Library doesn't provide type hints yet\n    # We validate data structure at runtime\n    if not isinstance(data, dict):\n        raise ValidationError(\"Expected dict\")\n    return data\n```\n\n## Remember\n\n- **Security First** - Security rules always win\n- **Document Exceptions** - Explain why deviation is needed\n- **Team Consensus** - Get input for significant conflicts\n- **Update Guidelines** - If exceptions become patterns\n- **Be Pragmatic** - Rules are guidelines, not absolutes",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "core-framework-language",
          "title": "Core Framework & Language",
          "fileName": "core-framework-&-language.mdc",
          "frontmatter": {
            "description": "Core framework, language, and runtime specifications for Python FastAPI projects",
            "globs": [
              "**/*.py",
              "**/app/**",
              "**/tests/**",
              "**/pyproject.toml",
              "**/requirements*.txt"
            ],
            "alwaysApply": true
          },
          "content": "# Core Framework & Language\n\n## Overview\n\nThis document defines the foundational technology stack and runtime environment for the project. All code must align with these specifications.\n\n## Framework\n\n- **Framework:** [FastAPI](https://fastapi.tiangolo.com/)\n  - Modern, fast (high-performance) web framework for building APIs\n  - Built on Starlette for the web parts and Pydantic for data validation\n  - Automatic API documentation (OpenAPI/Swagger)\n  - Full async/await support with Python type hints\n  - Dependency injection system built-in\n\n## Language\n\n- **Language:** [Python](https://www.python.org/) 3.11+\n  - Used throughout the codebase with strict type hints\n  - Type checking with mypy enabled\n  - All files must use Python 3.11+ features where beneficial\n  - Async/await for all I/O operations\n\n## Runtime\n\n- **ASGI Server:** [Uvicorn](https://www.uvicorn.org/)\n  - Lightning-fast ASGI server implementation\n  - Built on uvloop and httptools\n  - Supports HTTP/1.1 and WebSockets\n  - Hot reload in development\n\n## Python Version Management\n\nAlways check and use the correct Python version:\n\n```bash\n# Using pyenv\npyenv install 3.11.7\npyenv local 3.11.7\n\n# Using asdf\nasdf install python 3.11.7\nasdf local python 3.11.7\n\n# Verify version\npython --version  # Should show Python 3.11.x\n```\n\n## Type System Configuration\n\nThe project uses strict type checking. Key requirements:\n\n- **mypy** configuration in `pyproject.toml`:\n\n  ```toml\n  [tool.mypy]\n  python_version = \"3.11\"\n  strict = true\n  warn_return_any = true\n  warn_unused_configs = true\n  disallow_untyped_defs = true\n  disallow_incomplete_defs = true\n  check_untyped_defs = true\n  no_implicit_optional = true\n  warn_redundant_casts = true\n  warn_unused_ignores = true\n  warn_no_return = true\n  warn_unreachable = true\n  strict_equality = true\n  ```\n\n- All functions must have type hints\n- Use `from __future__ import annotations` for forward references\n- Prefer `Union[X, None]` or `X | None` (Python 3.10+) over `Optional[X]`\n- Use TypeVar, Generic types where appropriate\n\n## Project Structure\n\nStandard FastAPI project structure:\n\n```\nproject-root/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ main.py              # FastAPI application instance\n‚îÇ   ‚îú‚îÄ‚îÄ api/                 # API routes\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/              # API version 1\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints/   # Route handlers\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py    # Main v1 router\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py  # Shared dependencies\n‚îÇ   ‚îú‚îÄ‚îÄ core/                # Core functionality\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py        # Settings management\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py      # Security utilities\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py    # Custom exceptions\n‚îÇ   ‚îú‚îÄ‚îÄ models/              # Pydantic models & SQLAlchemy models\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/          # Domain models\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database/        # Database models\n‚îÇ   ‚îú‚îÄ‚îÄ services/            # Business logic\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # Data access layer\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ utils/               # Utility functions\n‚îÇ       ‚îî‚îÄ‚îÄ __init__.py\n‚îú‚îÄ‚îÄ tests/                   # Test files\n‚îú‚îÄ‚îÄ alembic/                 # Database migrations\n‚îú‚îÄ‚îÄ scripts/                 # Utility scripts\n‚îú‚îÄ‚îÄ .env.example             # Example environment variables\n‚îú‚îÄ‚îÄ pyproject.toml           # Project configuration\n‚îú‚îÄ‚îÄ poetry.lock              # Locked dependencies\n‚îî‚îÄ‚îÄ Dockerfile               # Container configuration\n```\n\n## Core Dependencies\n\nEssential packages for FastAPI development:\n\n```toml\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.104.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.24.0\"}\npydantic = \"^2.4.0\"\npydantic-settings = \"^2.0.0\"\nsqlalchemy = \"^2.0.0\"\nasyncpg = \"^0.29.0\"  # For PostgreSQL\nalembic = \"^1.12.0\"\npython-jose = {extras = [\"cryptography\"], version = \"^3.3.0\"}\npasslib = {extras = [\"bcrypt\"], version = \"^1.7.4\"}\npython-multipart = \"^0.0.6\"\nredis = \"^5.0.0\"\ncelery = \"^5.3.0\"\nhttpx = \"^0.25.0\"  # Async HTTP client\n```\n\n## Development Dependencies\n\n```toml\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\npytest-cov = \"^4.1.0\"\npytest-mock = \"^3.11.0\"\nblack = \"^23.9.0\"\nisort = \"^5.12.0\"\nmypy = \"^1.5.0\"\nruff = \"^0.0.292\"\npre-commit = \"^3.4.0\"\n```\n\n## Environment Setup\n\n1. **Install Poetry** (dependency management):\n\n   ```bash\n   curl -sSL https://install.python-poetry.org | python3 -\n   ```\n\n2. **Install dependencies**:\n\n   ```bash\n   poetry install\n   ```\n\n3. **Activate virtual environment**:\n\n   ```bash\n   poetry shell\n   ```\n\n4. **Install pre-commit hooks**:\n   ```bash\n   pre-commit install\n   ```\n\n## Running the Application\n\nDevelopment mode with hot reload:\n\n```bash\n# Using Poetry\npoetry run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000\n\n# Or directly if in poetry shell\nuvicorn app.main:app --reload --host 0.0.0.0 --port 8000\n```\n\nProduction mode:\n\n```bash\n# With multiple workers\nuvicorn app.main:app --workers 4 --host 0.0.0.0 --port 8000\n\n# Or using Gunicorn with Uvicorn workers\ngunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker\n```\n",
          "alwaysApply": true,
          "globs": [
            "**/*.py",
            "**/app/**",
            "**/tests/**",
            "**/pyproject.toml",
            "**/requirements*.txt"
          ]
        },
        {
          "id": "data-management-patterns",
          "title": "Data Management Patterns",
          "fileName": "data-management-patterns.mdc",
          "frontmatter": {
            "description": "Database and data management patterns for Python FastAPI applications",
            "globs": [
              "**/app/repositories/**",
              "**/app/models/**"
            ],
            "alwaysApply": true
          },
          "content": "# Data Management Patterns\n\n## SQLAlchemy Patterns\n\n### Async Sessions\n\nAlways use async sessions:\n\n```python\n# ‚úÖ GOOD - Async session\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    pool_size=20,\n    max_overflow=10,\n    pool_pre_ping=True,\n)\n\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n# ‚ùå BAD - Sync session (don't use)\nfrom sqlalchemy.orm import Session\nsession = Session()  # Blocking\n```\n\n### Session Management\n\nProper session lifecycle:\n\n```python\n# app/core/database.py\nasync def get_db() -> AsyncSession:\n    \"\"\"Get database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n### Transactions\n\nUse transactions for multi-step operations:\n\n```python\n# ‚úÖ GOOD - Explicit transaction\nasync def transfer_funds(from_account_id: int, to_account_id: int, amount: float):\n    \"\"\"Transfer funds between accounts.\"\"\"\n    async with session.begin():\n        # Both operations in same transaction\n        from_account = await session.get(Account, from_account_id)\n        to_account = await session.get(Account, to_account_id)\n        \n        from_account.balance -= amount\n        to_account.balance += amount\n        \n        # Commit happens automatically at end of context\n```\n\n## Query Patterns\n\n### Eager Loading\n\nAvoid N+1 query problems:\n\n```python\n# ‚ùå BAD - N+1 queries\nusers = await session.execute(select(User))\nfor user in users.scalars():\n    posts = await session.execute(\n        select(Post).where(Post.user_id == user.id)\n    )  # One query per user\n\n# ‚úÖ GOOD - Eager loading\nfrom sqlalchemy.orm import selectinload\n\nusers = await session.execute(\n    select(User).options(selectinload(User.posts))\n)  # Two queries total\n```\n\n### Query Builders\n\nBuild queries dynamically:\n\n```python\n# ‚úÖ GOOD - Dynamic query building\ndef build_user_query(\n    status: Optional[str] = None,\n    email_contains: Optional[str] = None,\n) -> Select:\n    \"\"\"Build user query with optional filters.\"\"\"\n    query = select(User)\n    \n    if status:\n        query = query.where(User.status == status)\n    \n    if email_contains:\n        query = query.where(User.email.contains(email_contains))\n    \n    return query\n\n# Usage\nquery = build_user_query(status=\"active\", email_contains=\"@example.com\")\nresult = await session.execute(query)\n```\n\n## Repository Pattern\n\n### Basic Repository\n\n```python\n# app/repositories/user_repository.py\nfrom typing import Optional, List\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.models.database.user import User as UserModel\nfrom app.models.domain.user import User\n\n\nclass UserRepository:\n    \"\"\"Repository for user data access.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n    \n    async def get_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user_id)\n        )\n        user_model = result.scalar_one_or_none()\n        return User.from_orm(user_model) if user_model else None\n    \n    async def get_by_email(self, email: str) -> Optional[User]:\n        \"\"\"Get user by email.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.email == email)\n        )\n        user_model = result.scalar_one_or_none()\n        return User.from_orm(user_model) if user_model else None\n    \n    async def create(self, user_data: dict) -> User:\n        \"\"\"Create new user.\"\"\"\n        user_model = UserModel(**user_data)\n        self.db.add(user_model)\n        await self.db.flush()\n        await self.db.refresh(user_model)\n        return User.from_orm(user_model)\n    \n    async def update(self, user: User) -> User:\n        \"\"\"Update user.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user.id)\n        )\n        user_model = result.scalar_one()\n        \n        for key, value in user.model_dump(exclude_unset=True).items():\n            setattr(user_model, key, value)\n        \n        await self.db.flush()\n        await self.db.refresh(user_model)\n        return User.from_orm(user_model)\n    \n    async def delete(self, user_id: int) -> None:\n        \"\"\"Delete user.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user_id)\n        )\n        user_model = result.scalar_one_or_none()\n        if user_model:\n            await self.db.delete(user_model)\n            await self.db.flush()\n```\n\n## Migrations with Alembic\n\n### Creating Migrations\n\n```bash\n# Create migration\nalembic revision --autogenerate -m \"Add user table\"\n\n# Apply migration\nalembic upgrade head\n\n# Rollback migration\nalembic downgrade -1\n```\n\n### Migration Best Practices\n\n```python\n# ‚úÖ GOOD - Migration with proper up/down\n\"\"\"Add user table\n\nRevision ID: abc123\nRevises: \nCreate Date: 2024-01-15 10:00:00\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\ndef upgrade() -> None:\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('email', sa.String(), nullable=False),\n        sa.Column('full_name', sa.String(), nullable=False),\n        sa.Column('hashed_password', sa.String(), nullable=False),\n        sa.Column('is_active', sa.Boolean(), default=True),\n        sa.Column('created_at', sa.DateTime(), nullable=False),\n        sa.Column('updated_at', sa.DateTime(), nullable=False),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('email'),\n    )\n    op.create_index('ix_users_email', 'users', ['email'])\n\ndef downgrade() -> None:\n    op.drop_index('ix_users_email', table_name='users')\n    op.drop_table('users')\n```\n\n## Data Validation\n\n### Pydantic Models\n\nUse Pydantic for all I/O:\n\n```python\n# app/schemas/user.py\nfrom pydantic import BaseModel, EmailStr, Field, validator\nfrom datetime import datetime\n\nclass UserCreate(BaseModel):\n    \"\"\"User creation schema.\"\"\"\n    email: EmailStr\n    full_name: str = Field(..., min_length=1, max_length=255)\n    password: str = Field(..., min_length=8, max_length=100)\n    \n    @validator('password')\n    def validate_password(cls, v):\n        \"\"\"Validate password strength.\"\"\"\n        if not any(c.isupper() for c in v):\n            raise ValueError('Password must contain uppercase letter')\n        if not any(c.islower() for c in v):\n            raise ValueError('Password must contain lowercase letter')\n        if not any(c.isdigit() for c in v):\n            raise ValueError('Password must contain digit')\n        return v\n\nclass UserResponse(BaseModel):\n    \"\"\"User response schema.\"\"\"\n    id: int\n    email: EmailStr\n    full_name: str\n    is_active: bool\n    created_at: datetime\n    updated_at: datetime\n    \n    class Config:\n        from_attributes = True\n```\n\n## Serialization\n\n### Model to Pydantic\n\n```python\n# ‚úÖ GOOD - Use from_attributes\nuser_model = await session.get(UserModel, user_id)\nuser_response = UserResponse.from_orm(user_model)\n\n# ‚úÖ GOOD - Manual conversion\nuser_response = UserResponse(\n    id=user_model.id,\n    email=user_model.email,\n    full_name=user_model.full_name,\n    is_active=user_model.is_active,\n    created_at=user_model.created_at,\n    updated_at=user_model.updated_at,\n)\n```\n\n## Best Practices\n\n1. **Async First** - Always use async sessions\n2. **Eager Loading** - Avoid N+1 queries\n3. **Transactions** - Use for multi-step operations\n4. **Validation** - Validate with Pydantic\n5. **Migrations** - Use Alembic for schema changes\n6. **Repository Pattern** - Abstract data access\n7. **Connection Pooling** - Configure properly\n8. **Query Optimization** - Use indexes, optimize queries\n\n## Remember\n\n- **Async Sessions** - Always use async\n- **Eager Loading** - Prevent N+1 problems\n- **Transactions** - For multi-step operations\n- **Validation** - Pydantic for all I/O\n- **Migrations** - Alembic for schema changes",
          "alwaysApply": true,
          "globs": [
            "**/app/repositories/**",
            "**/app/models/**"
          ]
        },
        {
          "id": "dependency-management",
          "title": "Dependency Management",
          "fileName": "dependency-management.mdc",
          "frontmatter": {
            "description": "Dependency management best practices for Python FastAPI projects",
            "globs": [
              "**/pyproject.toml",
              "**/requirements*.txt",
              "**/poetry.lock"
            ],
            "alwaysApply": true
          },
          "content": "# Dependency Management\n\n## Poetry (Preferred)\n\n### Project Setup\n\n```toml\n# pyproject.toml\n[tool.poetry]\nname = \"my-fastapi-app\"\nversion = \"1.0.0\"\ndescription = \"FastAPI application\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.104.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.24.0\"}\npydantic = \"^2.4.0\"\npydantic-settings = \"^2.0.0\"\nsqlalchemy = \"^2.0.0\"\nasyncpg = \"^0.29.0\"\nalembic = \"^1.12.0\"\npython-jose = {extras = [\"cryptography\"], version = \"^3.3.0\"}\npasslib = {extras = [\"bcrypt\"], version = \"^1.7.4\"}\npython-multipart = \"^0.0.6\"\nredis = \"^5.0.0\"\ncelery = \"^5.3.0\"\nhttpx = \"^0.25.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\npytest-cov = \"^4.1.0\"\npytest-mock = \"^3.11.0\"\nblack = \"^23.9.0\"\nisort = \"^5.12.0\"\nmypy = \"^1.5.0\"\nruff = \"^0.0.292\"\npre-commit = \"^3.4.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n```\n\n### Common Commands\n\n```bash\n# Install dependencies\npoetry install\n\n# Add dependency\npoetry add fastapi\n\n# Add dev dependency\npoetry add --group dev pytest\n\n# Update dependencies\npoetry update\n\n# Show outdated packages\npoetry show --outdated\n\n# Export to requirements.txt (if needed)\npoetry export -f requirements.txt --output requirements.txt --without-hashes\n```\n\n## Version Pinning\n\n### Exact Versions in Lock File\n\n```toml\n# pyproject.toml - Use ranges\nfastapi = \"^0.104.0\"  # Allows 0.104.0 to <0.105.0\n\n# poetry.lock - Exact versions (auto-generated)\n# Don't edit manually\n```\n\n### Version Strategies\n\n```toml\n# Caret (^) - Recommended for most dependencies\nfastapi = \"^0.104.0\"  # >=0.104.0, <0.105.0\n\n# Tilde (~) - More restrictive\nfastapi = \"~0.104.0\"  # >=0.104.0, <0.104.1\n\n# Exact - Only for critical dependencies\nfastapi = \"0.104.0\"  # Exactly this version\n\n# Wildcard - Not recommended\nfastapi = \"*\"  # Any version (dangerous)\n```\n\n## Security\n\n### Regular Audits\n\n```bash\n# Check for vulnerabilities\npoetry audit\n\n# Update vulnerable packages\npoetry update package-name\n\n# Use safety (additional security checker)\npip install safety\nsafety check\n```\n\n### Dependency Updates\n\n```bash\n# Check what would be updated\npoetry update --dry-run\n\n# Update specific package\npoetry update fastapi\n\n# Update all packages (be careful!)\npoetry update\n```\n\n## Docker Integration\n\n### Multi-Stage Builds\n\n```dockerfile\n# Dockerfile\nFROM python:3.11-slim as builder\n\nWORKDIR /app\n\n# Install Poetry\nRUN pip install poetry\n\n# Copy dependency files\nCOPY pyproject.toml poetry.lock ./\n\n# Install dependencies\nRUN poetry config virtualenvs.create false \\\n    && poetry install --no-interaction --no-ansi --no-root\n\n# Production stage\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Copy installed packages from builder\nCOPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\nCOPY --from=builder /usr/local/bin /usr/local/bin\n\n# Copy application code\nCOPY . .\n\n# Run application\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n## Requirements.txt (Alternative)\n\n### If Not Using Poetry\n\n```txt\n# requirements.txt\nfastapi==0.104.0\nuvicorn[standard]==0.24.0\npydantic==2.4.0\npydantic-settings==2.0.0\nsqlalchemy==2.0.0\nasyncpg==0.29.0\nalembic==1.12.0\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\npython-multipart==0.0.6\nredis==5.0.0\ncelery==5.3.0\nhttpx==0.25.0\n\n# requirements-dev.txt\npytest==7.4.0\npytest-asyncio==0.21.0\npytest-cov==4.1.0\npytest-mock==3.11.0\nblack==23.9.0\nisort==5.12.0\nmypy==1.5.0\nruff==0.0.292\npre-commit==3.4.0\n```\n\n## Best Practices\n\n1. **Use Poetry** - Better dependency resolution\n2. **Pin Versions** - Use ranges in pyproject.toml, exact in lock file\n3. **Regular Updates** - Keep dependencies up to date\n4. **Security Audits** - Check for vulnerabilities regularly\n5. **Separate Dev Dependencies** - Keep dev tools separate\n6. **Lock File** - Commit poetry.lock to version control\n7. **Document Dependencies** - Explain why each dependency is needed\n\n## Remember\n\n- **Use Poetry** - Preferred dependency manager\n- **Pin Versions** - Use version ranges appropriately\n- **Security First** - Regular audits and updates\n- **Lock Files** - Commit lock files to version control\n- **Separate Dev** - Keep dev dependencies separate\n- **Document** - Explain why dependencies are needed",
          "alwaysApply": true,
          "globs": [
            "**/pyproject.toml",
            "**/requirements*.txt",
            "**/poetry.lock"
          ]
        },
        {
          "id": "error-handling-patterns",
          "title": "Error Handling Patterns",
          "fileName": "error-handling-patterns.mdc",
          "frontmatter": {
            "description": "Error handling patterns and best practices for Python FastAPI applications",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Error Handling Patterns\n\n## Philosophy\n\nErrors are inevitable in any application. Our error handling strategy focuses on:\n1. **Graceful Degradation** - The application should continue functioning even when errors occur\n2. **User-Friendly Feedback** - Users should understand what went wrong without technical jargon\n3. **Developer Debugging** - Errors should contain enough context for debugging\n4. **Security** - Never expose sensitive information in error messages\n\n## Error Types\n\n### 1. Custom Application Exceptions\n\nCustom exception classes for domain-specific errors:\n\n```python\n# app/core/exceptions.py\nfrom typing import Optional\n\n\nclass ApplicationError(Exception):\n    \"\"\"Base exception for application errors.\"\"\"\n    \n    def __init__(\n        self,\n        message: str,\n        status_code: int = 500,\n        detail: Optional[dict] = None,\n    ):\n        self.message = message\n        self.status_code = status_code\n        self.detail = detail or {}\n        super().__init__(self.message)\n\n\nclass ValidationError(ApplicationError):\n    \"\"\"Validation error.\"\"\"\n    \n    def __init__(self, message: str, detail: Optional[dict] = None):\n        super().__init__(message, status_code=400, detail=detail)\n\n\nclass AuthenticationError(ApplicationError):\n    \"\"\"Authentication error.\"\"\"\n    \n    def __init__(self, message: str = \"Authentication failed\"):\n        super().__init__(message, status_code=401)\n\n\nclass AuthorizationError(ApplicationError):\n    \"\"\"Authorization error.\"\"\"\n    \n    def __init__(self, message: str = \"Access denied\"):\n        super().__init__(message, status_code=403)\n\n\nclass NotFoundError(ApplicationError):\n    \"\"\"Resource not found error.\"\"\"\n    \n    def __init__(self, resource: str):\n        super().__init__(f\"{resource} not found\", status_code=404)\n\n\nclass ConflictError(ApplicationError):\n    \"\"\"Conflict error (e.g., duplicate resource).\"\"\"\n    \n    def __init__(self, message: str):\n        super().__init__(message, status_code=409)\n\n\nclass RateLimitError(ApplicationError):\n    \"\"\"Rate limit exceeded error.\"\"\"\n    \n    def __init__(self, message: str = \"Too many requests\"):\n        super().__init__(message, status_code=429)\n\n\nclass ExternalServiceError(ApplicationError):\n    \"\"\"External service error.\"\"\"\n    \n    def __init__(self, service: str, message: str, original_error: Optional[Exception] = None):\n        super().__init__(\n            f\"{service} error: {message}\",\n            status_code=503,\n            detail={\"service\": service, \"original_error\": str(original_error) if original_error else None}\n        )\n        self.service = service\n        self.original_error = original_error\n```\n\n### 2. Exception Handlers\n\nGlobal exception handlers for consistent error responses:\n\n```python\n# app/core/exception_handlers.py\nfrom fastapi import Request, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\nfrom sqlalchemy.exc import SQLAlchemyError\n\nfrom app.core.exceptions import ApplicationError\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nasync def application_error_handler(\n    request: Request,\n    exc: ApplicationError,\n) -> JSONResponse:\n    \"\"\"Handle application errors.\"\"\"\n    logger.error(\n        \"Application error\",\n        extra={\n            \"error\": exc.message,\n            \"status_code\": exc.status_code,\n            \"detail\": exc.detail,\n            \"path\": request.url.path,\n        }\n    )\n    \n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": {\n                \"message\": exc.message,\n                \"code\": exc.__class__.__name__,\n                \"detail\": exc.detail,\n            }\n        }\n    )\n\n\nasync def validation_error_handler(\n    request: Request,\n    exc: RequestValidationError,\n) -> JSONResponse:\n    \"\"\"Handle validation errors.\"\"\"\n    errors = exc.errors()\n    logger.warning(\n        \"Validation error\",\n        extra={\n            \"errors\": errors,\n            \"path\": request.url.path,\n        }\n    )\n    \n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content={\n            \"error\": {\n                \"message\": \"Validation failed\",\n                \"code\": \"ValidationError\",\n                \"detail\": errors,\n            }\n        }\n    )\n\n\nasync def database_error_handler(\n    request: Request,\n    exc: SQLAlchemyError,\n) -> JSONResponse:\n    \"\"\"Handle database errors.\"\"\"\n    logger.error(\n        \"Database error\",\n        extra={\n            \"error\": str(exc),\n            \"path\": request.url.path,\n        },\n        exc_info=True,\n    )\n    \n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            \"error\": {\n                \"message\": \"Database error occurred\",\n                \"code\": \"DatabaseError\",\n            }\n        }\n    )\n\n\nasync def general_exception_handler(\n    request: Request,\n    exc: Exception,\n) -> JSONResponse:\n    \"\"\"Handle unexpected exceptions.\"\"\"\n    logger.error(\n        \"Unexpected error\",\n        extra={\n            \"error\": str(exc),\n            \"path\": request.url.path,\n        },\n        exc_info=True,\n    )\n    \n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            \"error\": {\n                \"message\": \"An unexpected error occurred\",\n                \"code\": \"InternalServerError\",\n            }\n        }\n    )\n\n# app/main.py\nfrom fastapi import FastAPI\nfrom fastapi.exceptions import RequestValidationError\nfrom sqlalchemy.exc import SQLAlchemyError\n\nfrom app.core.exceptions import ApplicationError\nfrom app.core.exception_handlers import (\n    application_error_handler,\n    validation_error_handler,\n    database_error_handler,\n    general_exception_handler,\n)\n\napp = FastAPI()\n\napp.add_exception_handler(ApplicationError, application_error_handler)\napp.add_exception_handler(RequestValidationError, validation_error_handler)\napp.add_exception_handler(SQLAlchemyError, database_error_handler)\napp.add_exception_handler(Exception, general_exception_handler)\n```\n\n## Error Handling Patterns\n\n### 1. Service Layer Error Handling\n\nServices should handle errors and provide meaningful context:\n\n```python\n# app/services/user_service.py\nfrom typing import Optional\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.models.domain.user import User\nfrom app.repositories.user_repository import UserRepository\nfrom app.schemas.user import UserCreate\nfrom app.core.exceptions import NotFoundError, ConflictError, ExternalServiceError\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass UserService:\n    \"\"\"Service for user-related business logic.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n        self.repository = UserRepository(db)\n    \n    async def get_user_by_id(self, user_id: int) -> User:\n        \"\"\"Get user by ID.\"\"\"\n        try:\n            if not user_id or user_id <= 0:\n                raise ValidationError(\"Invalid user ID format\")\n            \n            user = await self.repository.get_by_id(user_id)\n            \n            if not user:\n                raise NotFoundError(\"User\")\n            \n            return user\n        except NotFoundError:\n            raise\n        except Exception as e:\n            logger.error(\n                \"Failed to fetch user profile\",\n                extra={\n                    \"user_id\": user_id,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n            raise ApplicationError(\"Failed to fetch user profile\") from e\n    \n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            # Check if user exists\n            existing_user = await self.repository.get_by_email(user_data.email)\n            if existing_user:\n                raise ConflictError(\"User with this email already exists\")\n            \n            # Create user\n            user = await self.repository.create(user_data)\n            \n            return user\n        except ConflictError:\n            raise\n        except Exception as e:\n            logger.error(\n                \"Failed to create user\",\n                extra={\n                    \"email\": user_data.email,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n            raise ApplicationError(\"Failed to create user\") from e\n```\n\n### 2. Repository Error Handling\n\nRepositories should handle database-specific errors:\n\n```python\n# app/repositories/user_repository.py\nfrom typing import Optional\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.exc import IntegrityError\n\nfrom app.models.database.user import User as UserModel\nfrom app.core.exceptions import ConflictError, ApplicationError\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass UserRepository:\n    \"\"\"Repository for user data access.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n    \n    async def create(self, user_data: dict) -> UserModel:\n        \"\"\"Create a new user.\"\"\"\n        try:\n            user_model = UserModel(**user_data)\n            self.db.add(user_model)\n            await self.db.flush()\n            await self.db.refresh(user_model)\n            return user_model\n        except IntegrityError as e:\n            await self.db.rollback()\n            logger.warning(\n                \"Integrity error creating user\",\n                extra={\"error\": str(e)},\n            )\n            raise ConflictError(\"User with this email already exists\") from e\n        except Exception as e:\n            await self.db.rollback()\n            logger.error(\n                \"Database error creating user\",\n                extra={\"error\": str(e)},\n                exc_info=True,\n            )\n            raise ApplicationError(\"Database error\") from e\n```\n\n### 3. API Route Error Handling\n\nRoutes should catch and handle service errors:\n\n```python\n# app/api/v1/endpoints/users.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.api.dependencies import get_db\nfrom app.services.user_service import UserService\nfrom app.schemas.user import UserResponse, UserCreate\nfrom app.core.exceptions import NotFoundError, ConflictError\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n\n@router.get(\"/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_db),\n) -> UserResponse:\n    \"\"\"Get user by ID.\"\"\"\n    user_service = UserService(db)\n    try:\n        user = await user_service.get_user_by_id(user_id)\n        return UserResponse.from_orm(user)\n    except NotFoundError as e:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=e.message\n        )\n```\n\n## Error Recovery Strategies\n\n### 1. Retry Logic\n\nFor transient failures:\n\n```python\n# app/utils/retry.py\nfrom typing import TypeVar, Callable, Optional\nimport asyncio\nfrom functools import wraps\n\nfrom app.core.exceptions import ExternalServiceError\n\nT = TypeVar(\"T\")\n\n\ndef retry_on_failure(\n    max_attempts: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    exceptions: tuple = (Exception,),\n):\n    \"\"\"Retry decorator for async functions.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        async def wrapper(*args, **kwargs) -> T:\n            last_exception = None\n            \n            for attempt in range(1, max_attempts + 1):\n                try:\n                    return await func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt == max_attempts:\n                        break\n                    \n                    wait_time = delay * (backoff ** (attempt - 1))\n                    await asyncio.sleep(wait_time)\n            \n            raise last_exception\n        \n        return wrapper\n    return decorator\n\n# Usage\n@retry_on_failure(max_attempts=3, exceptions=(ExternalServiceError,))\nasync def fetch_external_data():\n    # External API call\n    pass\n```\n\n### 2. Circuit Breaker\n\nPrevent cascading failures:\n\n```python\n# app/utils/circuit_breaker.py\nfrom enum import Enum\nfrom typing import Callable, TypeVar\nfrom datetime import datetime, timedelta\nimport asyncio\n\nT = TypeVar(\"T\")\n\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for external service calls.\"\"\"\n    \n    def __init__(\n        self,\n        failure_threshold: int = 5,\n        timeout: int = 60,\n    ):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.last_failure_time: Optional[datetime] = None\n        self.state = CircuitState.CLOSED\n    \n    async def call(self, func: Callable[..., T], *args, **kwargs) -> T:\n        \"\"\"Execute function with circuit breaker.\"\"\"\n        if self.state == CircuitState.OPEN:\n            if self._should_attempt_reset():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n        \n        try:\n            result = await func(*args, **kwargs)\n            self._on_success()\n            return result\n        except Exception as e:\n            self._on_failure()\n            raise\n    \n    def _should_attempt_reset(self) -> bool:\n        \"\"\"Check if enough time has passed to attempt reset.\"\"\"\n        if not self.last_failure_time:\n            return True\n        return datetime.utcnow() - self.last_failure_time > timedelta(seconds=self.timeout)\n    \n    def _on_success(self) -> None:\n        \"\"\"Handle successful call.\"\"\"\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n    \n    def _on_failure(self) -> None:\n        \"\"\"Handle failed call.\"\"\"\n        self.failures += 1\n        self.last_failure_time = datetime.utcnow()\n        \n        if self.failures >= self.failure_threshold:\n            self.state = CircuitState.OPEN\n```\n\n## Best Practices\n\n1. **Be Specific** - Create specific error types for different scenarios\n2. **Add Context** - Include relevant IDs, operations, and state in error logs\n3. **User-Friendly Messages** - Separate technical errors from user-facing messages\n4. **Don't Swallow Errors** - Always handle errors explicitly\n5. **Test Error Paths** - Include error scenarios in your tests\n6. **Document Errors** - Document possible errors in function docstrings\n7. **Fail Fast** - Validate inputs early and raise immediately\n8. **Graceful Degradation** - Provide fallbacks where possible\n9. **Security First** - Never expose sensitive data in error messages\n10. **Monitor Proactively** - Set up alerts for error spikes\n\n## Common Patterns to Avoid\n\n```python\n# ‚ùå BAD - Silent failures\ntry:\n    await risky_operation()\nexcept Exception:\n    pass  # Silently ignoring errors\n\n# ‚ùå BAD - Generic error messages\nraise Exception(\"Error occurred\")\n\n# ‚ùå BAD - Exposing internals\nraise HTTPException(status_code=500, detail=str(internal_error))\n\n# ‚ùå BAD - Inconsistent error handling\nif not user:\n    return {\"msg\": \"Not found\"}\nif not valid:\n    return {\"error\": \"Bad request\"}\n\n# ‚úÖ GOOD - Consistent, informative errors\nif not user:\n    raise NotFoundError(\"User\")\nif not valid:\n    raise ValidationError(\"Invalid input format\")\n```",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "git-workflow",
          "title": "Git Workflow",
          "fileName": "git-workflow.mdc",
          "frontmatter": {
            "description": "Git workflow, commit message conventions, and version control best practices for Python projects",
            "globs": [
              "**/.git/**",
              "**/.gitignore"
            ],
            "alwaysApply": true
          },
          "content": "# Git Workflow Guidelines\n\n## Commit Message Format\n\nFollow the [Conventional Commits](https://www.conventionalcommits.org/) specification for consistent commit messages.\n\n### Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- **`feat`**: A new feature\n- **`fix`**: A bug fix\n- **`docs`**: Documentation only changes\n- **`style`**: Code style changes (formatting, missing semicolons, etc.)\n- **`refactor`**: Code refactoring without bug fixes or features\n- **`perf`**: Performance improvements\n- **`test`**: Adding or updating tests\n- **`chore`**: Maintenance tasks, dependency updates\n- **`build`**: Build system or external dependencies\n- **`ci`**: CI/CD configuration changes\n\n### Examples\n\n```bash\n# Feature\nfeat(auth): add JWT token refresh mechanism\n\n# Bug fix\nfix(api): resolve user profile null reference error\n\n# Breaking change\nfeat(api)!: change user endpoint response format\n\nBREAKING CHANGE: The user endpoint now returns nested user object instead of flat structure\n\n# Multiple changes\nfeat(users): add user profile management\n\n- Add user profile service\n- Create profile API endpoints\n- Update user schema with profile fields\n```\n\n### Scope\n\nUse scope to indicate which part of the codebase is affected:\n\n- `api`: API routes and handlers\n- `auth`: Authentication and authorization\n- `services`: Service layer functions\n- `repositories`: Repository layer\n- `models`: Database and domain models\n- `schemas`: Pydantic schemas\n- `utils`: Utility functions\n- `config`: Configuration files\n- `deps`: Dependencies\n- `tests`: Test files\n\n### Subject\n\n- Use imperative mood (\"add\" not \"added\" or \"adds\")\n- First line should be 50 characters or less\n- Don't end with a period\n- Be specific and descriptive\n\n### Body (Optional)\n\n- Explain the \"what\" and \"why\" vs \"how\"\n- Wrap at 72 characters\n- Can include multiple paragraphs\n\n### Footer (Optional)\n\n- Reference issues: `Closes #123`, `Fixes #456`\n- Breaking changes: `BREAKING CHANGE: <description>`\n\n## Branch Naming\n\n### Format\n\n```\n<type>/<description>\n```\n\n### Types\n\n- `feature/`: New features\n- `fix/`: Bug fixes\n- `hotfix/`: Critical production fixes\n- `refactor/`: Code refactoring\n- `docs/`: Documentation updates\n- `test/`: Test additions/updates\n\n### Examples\n\n```bash\nfeature/user-profile-editor\nfix/api-authentication-error\nhotfix/critical-data-loss-bug\nrefactor/user-service-layer\n```\n\n## Commit Best Practices\n\n### ‚úÖ DO\n\n- Make atomic commits (one logical change per commit)\n- Write clear, descriptive commit messages\n- Commit frequently (small, incremental changes)\n- Test before committing\n- Run pre-commit hooks before committing\n- Review your changes with `git diff` before committing\n\n### ‚ùå DON'T\n\n- Commit commented-out code\n- Commit debugging code or print statements\n- Commit with lint errors (see `no-hiding.mdc`)\n- Mix unrelated changes in one commit\n- Commit secrets or sensitive data\n- Force push to main/master branch\n- Commit without running tests\n\n## Workflow\n\n### 1. Create Feature Branch\n\n```bash\ngit checkout -b feature/my-new-feature\n```\n\n### 2. Make Changes\n\n- Write code following all guidelines\n- Ensure no lint errors (run `ruff check .`)\n- Ensure no type errors (run `mypy app/`)\n- Ensure code is formatted (run `black .`)\n- Test your changes (run `pytest`)\n\n### 3. Stage Changes\n\n```bash\n# Review what you're committing\ngit status\ngit diff\n\n# Stage specific files\ngit add path/to/file.py\n\n# Or stage all changes\ngit add .\n```\n\n### 4. Run Pre-commit Hooks\n\n```bash\n# Pre-commit hooks should run automatically\n# But you can run manually:\npre-commit run --all-files\n```\n\n### 5. Commit\n\n```bash\ngit commit -m \"feat(scope): descriptive message\"\n```\n\n### 6. Push and Create PR\n\n```bash\ngit push origin feature/my-new-feature\n```\n\nThen create a Pull Request with:\n- Clear title matching commit message format\n- Description explaining the change\n- Reference to related issues\n- Screenshots for UI changes (if applicable)\n\n## Pull Request Guidelines\n\n### PR Title\n\nFollow the same format as commit messages:\n\n```\nfeat(auth): add password reset functionality\n```\n\n### PR Description Template\n\n```markdown\n## Description\nBrief description of what this PR does.\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Testing\n- [ ] Tests pass locally (`pytest`)\n- [ ] Linters pass (`ruff check .`, `mypy app/`)\n- [ ] Code formatted (`black .`)\n- [ ] Manual testing completed\n- [ ] Edge cases considered\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] No lint errors\n- [ ] No type checker errors\n- [ ] Self-review completed\n- [ ] Docstrings added for public functions\n- [ ] Tests added/updated\n- [ ] Documentation updated if needed\n```\n\n## Handling Conflicts\n\n### When Your Branch is Behind\n\n```bash\n# Fetch latest changes\ngit fetch origin\n\n# Rebase your branch on main\ngit checkout feature/my-feature\ngit rebase origin/main\n\n# Resolve conflicts if any\n# Then continue rebase\ngit rebase --continue\n\n# Force push (only on feature branches)\ngit push --force-with-lease origin feature/my-feature\n```\n\n## Git Ignore\n\nEnsure these are in `.gitignore`:\n\n```\n# Python\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# Virtual environments\nvenv/\nENV/\nenv/\n.venv\n\n# Testing\n.pytest_cache/\n.coverage\nhtmlcov/\n.tox/\n.hypothesis/\n\n# IDEs\n.vscode/\n.idea/\n*.swp\n*.swo\n*.sublime-project\n*.sublime-workspace\n\n# Environment variables\n.env\n.env.local\n.env*.local\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Database\n*.db\n*.sqlite\n*.sqlite3\n\n# Temporary files\n*.tmp\n.cache/\n```\n\n## Pre-commit Hooks\n\n**Configuration (`.pre-commit-config.yaml`):**\n\n```yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 23.9.1\n    hooks:\n      - id: black\n        language_version: python3.11\n  \n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n  \n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n        args: [--strict]\n  \n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.0.292\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n  \n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n```\n\n**Install hooks:**\n\n```bash\npre-commit install\n```\n\n## Common Commands\n\n```bash\n# Check status\ngit status\n\n# View changes\ngit diff\ngit diff --staged\n\n# View commit history\ngit log --oneline --graph\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Undo last commit (discard changes)\ngit reset --hard HEAD~1\n\n# Stash changes\ngit stash\ngit stash pop\n\n# View stashes\ngit stash list\n\n# Create branch from main\ngit checkout main\ngit pull origin main\ngit checkout -b feature/new-feature\n```\n\n## Remember\n\n- **Small, frequent commits** are better than large, infrequent ones\n- **Clear commit messages** help future you and your team\n- **Test before committing** to avoid broken commits\n- **Run pre-commit hooks** to catch issues early\n- **Review your changes** with `git diff` before committing\n- **Never commit secrets** or sensitive data\n- **Follow conventional commits** for consistency",
          "alwaysApply": true,
          "globs": [
            "**/.git/**",
            "**/.gitignore"
          ]
        },
        {
          "id": "key-architecture-patterns",
          "title": "Key Architecture Patterns",
          "fileName": "key-architecture-patterns.mdc",
          "frontmatter": {
            "description": "Key architectural patterns and organizational principles for Python FastAPI codebase",
            "globs": [
              "**/app/services/**",
              "**/app/repositories/**",
              "**/app/api/**",
              "**/app/models/**"
            ],
            "alwaysApply": true
          },
          "content": "# Key Architectural Patterns\n\n## Overview\n\nThis document outlines the core architectural patterns used throughout the FastAPI codebase. These patterns ensure consistency, maintainability, and separation of concerns.\n\n## Service Layer Pattern\n\n**Purpose:** Encapsulate business logic and orchestrate operations.\n\n**Location:** `app/services/` directory\n\n**Principles:**\n- API routes should be thin wrappers that delegate to service functions\n- All business logic lives in services, not in route handlers\n- Services handle data transformation, validation, and external API calls\n- Services are async functions that can be easily tested\n- Services use repositories for data access\n\n**Example:**\n\n```python\n# ‚ùå BAD - Business logic in route handler\n# app/api/v1/endpoints/users.py\n@router.post(\"/users\", response_model=UserResponse)\nasync def create_user(\n    user_data: UserCreate,\n    db: AsyncSession = Depends(get_db),\n) -> UserResponse:\n    # Business logic mixed with route handling\n    if await db.execute(select(User).where(User.email == user_data.email)):\n        raise HTTPException(status_code=400, detail=\"Email already exists\")\n    \n    hashed_password = get_password_hash(user_data.password)\n    user = User(\n        email=user_data.email,\n        full_name=user_data.full_name,\n        hashed_password=hashed_password\n    )\n    db.add(user)\n    await db.commit()\n    await db.refresh(user)\n    \n    return UserResponse.from_orm(user)\n\n# ‚úÖ GOOD - Business logic in service\n# app/services/user_service.py\nfrom typing import Optional\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.models.domain.user import User\nfrom app.repositories.user_repository import UserRepository\nfrom app.schemas.user import UserCreate, UserUpdate\nfrom app.core.security import get_password_hash, verify_password\nfrom app.core.exceptions import NotFoundError, ConflictError\n\n\nclass UserService:\n    \"\"\"Service for user-related business logic.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n        self.repository = UserRepository(db)\n    \n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create a new user.\"\"\"\n        # Check if user exists\n        existing_user = await self.repository.get_by_email(user_data.email)\n        if existing_user:\n            raise ConflictError(\"User with this email already exists\")\n        \n        # Hash password\n        hashed_password = get_password_hash(user_data.password)\n        \n        # Create user\n        user = User(\n            email=user_data.email,\n            full_name=user_data.full_name,\n            hashed_password=hashed_password,\n            is_active=True,\n        )\n        \n        return await self.repository.create(user)\n    \n    async def get_user_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        user = await self.repository.get_by_id(user_id)\n        if not user:\n            raise NotFoundError(\"User not found\")\n        return user\n    \n    async def update_user(self, user_id: int, user_data: UserUpdate) -> User:\n        \"\"\"Update user.\"\"\"\n        user = await self.get_user_by_id(user_id)\n        \n        # Update fields\n        update_data = user_data.model_dump(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(user, field, value)\n        \n        return await self.repository.update(user)\n\n# app/api/v1/endpoints/users.py\n@router.post(\"/users\", response_model=UserResponse)\nasync def create_user(\n    user_data: UserCreate,\n    db: AsyncSession = Depends(get_db),\n) -> UserResponse:\n    \"\"\"Create a new user.\"\"\"\n    user_service = UserService(db)\n    user = await user_service.create_user(user_data)\n    return UserResponse.from_orm(user)\n```\n\n## Repository Pattern\n\n**Purpose:** Abstract data access layer and provide a clean interface for database operations.\n\n**Location:** `app/repositories/` directory\n\n**Principles:**\n- Encapsulate all database queries\n- Provide a consistent interface for data access\n- Hide SQLAlchemy implementation details\n- Support async operations\n- Handle transactions at the service layer\n\n**Example:**\n\n```python\n# app/repositories/user_repository.py\nfrom typing import Optional, List\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.models.database.user import User as UserModel\nfrom app.models.domain.user import User\n\n\nclass UserRepository:\n    \"\"\"Repository for user data access.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        self.db = db\n    \n    async def get_by_id(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user_id)\n        )\n        user_model = result.scalar_one_or_none()\n        return User.from_orm(user_model) if user_model else None\n    \n    async def get_by_email(self, email: str) -> Optional[User]:\n        \"\"\"Get user by email.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.email == email)\n        )\n        user_model = result.scalar_one_or_none()\n        return User.from_orm(user_model) if user_model else None\n    \n    async def create(self, user: User) -> User:\n        \"\"\"Create a new user.\"\"\"\n        user_model = UserModel(**user.model_dump())\n        self.db.add(user_model)\n        await self.db.flush()\n        await self.db.refresh(user_model)\n        return User.from_orm(user_model)\n    \n    async def update(self, user: User) -> User:\n        \"\"\"Update user.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user.id)\n        )\n        user_model = result.scalar_one()\n        \n        for key, value in user.model_dump(exclude_unset=True).items():\n            setattr(user_model, key, value)\n        \n        await self.db.flush()\n        await self.db.refresh(user_model)\n        return User.from_orm(user_model)\n    \n    async def delete(self, user_id: int) -> None:\n        \"\"\"Delete user.\"\"\"\n        result = await self.db.execute(\n            select(UserModel).where(UserModel.id == user_id)\n        )\n        user_model = result.scalar_one_or_none()\n        if user_model:\n            await self.db.delete(user_model)\n            await self.db.flush()\n```\n\n## Domain Models vs Database Models\n\n**Purpose:** Separate domain logic from persistence concerns.\n\n**Structure:**\n\n```\napp/models/\n‚îú‚îÄ‚îÄ domain/          # Domain models (Pydantic)\n‚îÇ   ‚îî‚îÄ‚îÄ user.py\n‚îî‚îÄ‚îÄ database/        # Database models (SQLAlchemy)\n    ‚îî‚îÄ‚îÄ user.py\n```\n\n**Example:**\n\n```python\n# app/models/domain/user.py\nfrom datetime import datetime\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    \"\"\"Domain model for User.\"\"\"\n    id: int\n    email: EmailStr\n    full_name: str\n    is_active: bool\n    created_at: datetime\n    updated_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n# app/models/database/user.py\nfrom datetime import datetime\nfrom sqlalchemy import Column, Integer, String, Boolean, DateTime\nfrom sqlalchemy.orm import relationship\n\nfrom app.core.database import Base\n\n\nclass User(Base):\n    \"\"\"Database model for User.\"\"\"\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    full_name = Column(String, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n```\n\n## Dependency Injection Pattern\n\n**Purpose:** Manage shared resources and dependencies.\n\n**Location:** `app/api/dependencies.py`\n\n**Example:**\n\n```python\n# app/api/dependencies.py\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.core.database import get_db\nfrom app.services.user_service import UserService\n\n\ndef get_user_service(\n    db: AsyncSession = Depends(get_db),\n) -> UserService:\n    \"\"\"Get user service instance.\"\"\"\n    return UserService(db)\n\n# Usage in route\n@router.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: UserService = Depends(get_user_service),\n) -> UserResponse:\n    \"\"\"Get user.\"\"\"\n    user = await user_service.get_user_by_id(user_id)\n    return UserResponse.from_orm(user)\n```\n\n## Modular Router Pattern\n\n**Purpose:** Organize API routes by feature/domain.\n\n**Structure:**\n\n```\napp/api/\n‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îú‚îÄ‚îÄ endpoints/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ items.py\n‚îÇ   ‚îî‚îÄ‚îÄ router.py\n```\n\n**Example:**\n\n```python\n# app/api/v1/endpoints/users.py\nfrom fastapi import APIRouter\n\nfrom app.api.v1.endpoints import auth, users, items\n\napi_router = APIRouter()\n\napi_router.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\napi_router.include_router(items.router, prefix=\"/items\", tags=[\"items\"])\n\n# app/main.py\nfrom fastapi import FastAPI\n\nfrom app.api.v1.router import api_router\n\napp = FastAPI(title=\"My API\", version=\"1.0.0\")\napp.include_router(api_router, prefix=\"/api/v1\")\n```\n\n## Best Practices\n\n1. **Separation of Concerns:** Keep routes thin, services focused, repositories isolated\n2. **Single Responsibility:** Each module/class should do one thing well\n3. **Testability:** Architecture should make testing easy (services are pure, repositories are isolated)\n4. **Consistency:** Follow these patterns consistently across the codebase\n5. **Type Safety:** Use type hints throughout, leverage Pydantic for validation\n6. **Async First:** All I/O operations should be async\n7. **Error Handling:** Use custom exceptions, handle at appropriate layer\n8. **Documentation:** Document architectural decisions and patterns in code comments",
          "alwaysApply": true,
          "globs": [
            "**/app/services/**",
            "**/app/repositories/**",
            "**/app/api/**",
            "**/app/models/**"
          ]
        },
        {
          "id": "logging-guidelines",
          "title": "Logging Guidelines",
          "fileName": "logging-guidelines.mdc",
          "frontmatter": {
            "description": "Logging standards for Python FastAPI applications with emphasis on minimal logging by default",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Logging Guidelines\n\n## Introduction\n\n### ‚ö†Ô∏è CRITICAL DEFAULT BEHAVIOR\n\n**BY DEFAULT: DO NOT ADD LOGS TO YOUR CODE**\n\n**Only add logging when:**\n1. Explicitly requested by the user/stakeholder\n2. Debugging a specific issue (temporary, remove after resolution)\n3. Required for production monitoring (errors, critical operations)\n\n**Default behavior when writing code:**\n- ‚úÖ Write code without logging statements\n- ‚úÖ Focus on proper error handling instead of logging\n- ‚úÖ Use type hints and exceptions for debugging\n- ‚ùå Do NOT add `logger.info()`, `logger.debug()`, or `print()` by default\n- ‚ùå Do NOT add logging \"just in case\" or for future debugging\n\n**When logging IS needed (after explicit request):**\nFollow all guidelines below for proper logging implementation.\n\n---\n\nThis document outlines the mandatory rules and best practices for implementing logging within the FastAPI application using Python's `logging` module. Adherence to these guidelines is crucial for maintaining consistent, informative, and manageable logs across the application.\n\nThe primary goals are:\n\n1. **Consistency:** Ensure logs follow a standard format and approach\n2. **Context:** Provide sufficient context within logs for effective debugging\n3. **Performance:** Avoid negatively impacting application performance\n4. **Security:** Prevent logging sensitive information\n5. **Manageability:** Structure logs appropriately for different environments and potential aggregation tools\n\n## General Logging Principles\n\n- **Context is Key:** Always include relevant context in your log messages. Use structured logging with extra fields for IDs (e.g., `user_id`, `request_id`, `workflow_id`).\n- **Appropriate Levels:** Use the correct log level (`error`, `warning`, `info`, `debug`) based on the severity and purpose of the message.\n- **Be Descriptive:** Log messages should clearly explain the event or state being logged.\n- **Avoid Sensitive Data:** **NEVER** log passwords, API keys, full access tokens, personally identifiable information (PII), or other sensitive credentials. Mask or omit this data.\n- **Structured Logging:** Use structured logging with extra fields for better parsing and filtering.\n- **Error Objects:** When logging errors, log the `Exception` object itself to capture stack traces.\n\n## Logger Setup\n\n**Location:** `app/core/logging.py`\n\n**Configuration:**\n\n```python\n# app/core/logging.py\nimport logging\nimport sys\nfrom typing import Optional\n\nfrom app.core.config import settings\n\n\ndef setup_logging() -> None:\n    \"\"\"Configure application logging.\"\"\"\n    log_level = getattr(logging, settings.LOG_LEVEL.upper(), logging.INFO)\n    \n    logging.basicConfig(\n        level=log_level,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n        ],\n    )\n    \n    # Set third-party loggers to WARNING\n    logging.getLogger(\"uvicorn\").setLevel(logging.WARNING)\n    logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.WARNING)\n\n\ndef get_logger(name: str) -> logging.Logger:\n    \"\"\"Get logger instance for a module.\"\"\"\n    return logging.getLogger(name)\n```\n\n## Log Levels Guidance\n\nUse log levels consistently:\n\n- **`ERROR` (40):** For actual errors, application failures, exceptions caught in `except` blocks, failed critical operations (e.g., failed DB write, failed critical API call). **These are essential for production monitoring.**\n- **`WARNING` (30):** For potential problems, unexpected situations that don't crash the app, use of deprecated features, non-critical API failures (e.g., optional data fetch failed). **Use judiciously in production.**\n- **`INFO` (20):** For high-level application lifecycle events (e.g., \"Server started\", \"User logged in\", \"Workflow started/completed\"), successful completion of major operations. **Should be relatively low volume in production.**\n- **`DEBUG` (10):** For detailed diagnostic information useful only during development and troubleshooting (e.g., variable values, function entry/exit, detailed state changes). **Should NOT be enabled in production.**\n\n**Rule:** The configured `LOG_LEVEL` environment variable determines the _maximum_ level that will be processed. Messages logged at a level _numerically higher_ than the configured level will be ignored (e.g., if `LOG_LEVEL=INFO`, `DEBUG` messages won't be processed).\n\n## Logging Patterns\n\n### 1. Service Layer Logging\n\n```python\n# app/services/user_service.py\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass UserService:\n    \"\"\"Service for user-related business logic.\"\"\"\n    \n    async def get_user_by_id(self, user_id: int) -> User:\n        \"\"\"Get user by ID.\"\"\"\n        logger.info(\n            \"Fetching user profile\",\n            extra={\"user_id\": user_id}\n        )\n        \n        try:\n            user = await self.repository.get_by_id(user_id)\n            \n            if not user:\n                logger.warning(\n                    \"User not found\",\n                    extra={\"user_id\": user_id}\n                )\n                raise NotFoundError(\"User\")\n            \n            logger.info(\n                \"User profile fetched successfully\",\n                extra={\"user_id\": user_id}\n            )\n            \n            return user\n        except NotFoundError:\n            raise\n        except Exception as e:\n            logger.error(\n                \"Failed to fetch user profile\",\n                extra={\n                    \"user_id\": user_id,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n            raise ApplicationError(\"Failed to fetch user profile\") from e\n```\n\n### 2. API Route Logging\n\n```python\n# app/api/v1/endpoints/users.py\nfrom fastapi import APIRouter, Depends\nfrom app.core.logging import get_logger\nfrom app.api.dependencies import get_current_user\n\nlogger = get_logger(__name__)\nrouter = APIRouter()\n\n\n@router.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"Get user endpoint.\"\"\"\n    logger.info(\n        \"API request: get user\",\n        extra={\n            \"user_id\": user_id,\n            \"request_user_id\": current_user.id,\n            \"endpoint\": \"/users/{user_id}\",\n        }\n    )\n    \n    try:\n        user = await user_service.get_user_by_id(user_id)\n        logger.info(\n            \"API request successful: get user\",\n            extra={\"user_id\": user_id}\n        )\n        return user\n    except Exception as e:\n        logger.error(\n            \"API request failed: get user\",\n            extra={\n                \"user_id\": user_id,\n                \"error\": str(e),\n            },\n            exc_info=True,\n        )\n        raise\n```\n\n### 3. Error Logging\n\n```python\n# Always log errors with context and stack traces\ntry:\n    result = await risky_operation()\nexcept Exception as e:\n    logger.error(\n        \"Operation failed\",\n        extra={\n            \"operation\": \"risky_operation\",\n            \"user_id\": user_id,\n            \"error\": str(e),\n        },\n        exc_info=True,  # Include stack trace\n    )\n    raise\n```\n\n### 4. Structured Logging\n\n```python\n# Use extra parameter for structured data\nlogger.info(\n    \"User created\",\n    extra={\n        \"user_id\": user.id,\n        \"email\": user.email,  # Safe to log email\n        \"created_at\": user.created_at.isoformat(),\n    }\n)\n\n# ‚ùå NEVER log sensitive data\nlogger.info(\n    \"User created\",\n    extra={\n        \"password\": user.password,  # ‚ùå NEVER DO THIS\n        \"api_key\": api_key,  # ‚ùå NEVER DO THIS\n    }\n)\n```\n\n## Middleware for Request Logging\n\n```python\n# app/core/middleware.py\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware for logging HTTP requests.\"\"\"\n    \n    async def dispatch(self, request: Request, call_next):\n        \"\"\"Log request and response.\"\"\"\n        start_time = time.time()\n        \n        # Log request\n        logger.info(\n            \"HTTP request started\",\n            extra={\n                \"method\": request.method,\n                \"path\": request.url.path,\n                \"client\": request.client.host if request.client else None,\n            }\n        )\n        \n        try:\n            response = await call_next(request)\n            \n            # Calculate duration\n            duration = time.time() - start_time\n            \n            # Log response\n            logger.info(\n                \"HTTP request completed\",\n                extra={\n                    \"method\": request.method,\n                    \"path\": request.url.path,\n                    \"status_code\": response.status_code,\n                    \"duration_ms\": duration * 1000,\n                }\n            )\n            \n            return response\n        except Exception as e:\n            duration = time.time() - start_time\n            \n            logger.error(\n                \"HTTP request failed\",\n                extra={\n                    \"method\": request.method,\n                    \"path\": request.url.path,\n                    \"duration_ms\": duration * 1000,\n                    \"error\": str(e),\n                },\n                exc_info=True,\n            )\n            raise\n\n# app/main.py\nfrom app.core.middleware import LoggingMiddleware\n\napp.add_middleware(LoggingMiddleware)\n```\n\n## What to Log\n\n### Server-Side Logging\n\n- API request start/end (consider `INFO` level)\n- Significant state changes or operations (e.g., user signup, workflow execution start/end)\n- Successful completion of critical tasks\n- Errors and exceptions (always include the error object and stack trace)\n- Warnings about potential issues or deprecated usage\n- Detailed debugging information (`DEBUG` level) for development tracing\n\n## What NOT to Log\n\n- **Sensitive Data:** Passwords, API keys, tokens, credit card numbers, SSNs\n- **Large Objects:** Don't log entire request/response bodies\n- **Personal Information:** Be careful with PII (emails are usually OK, but be mindful)\n- **Debug Logs in Production:** Don't enable DEBUG level in production\n- **Excessive Verbosity:** Don't log every function call or variable value\n\n## Performance Considerations\n\n- **Async Logging:** Use async-compatible logging handlers if needed\n- **Minimal Impact:** Logging should not significantly impact request processing time\n- **Batch Logging:** For high-volume scenarios, consider batching logs\n- **Log Rotation:** Configure log rotation to prevent disk space issues\n\n## Best Practices\n\n1. **Use Structured Logging:** Include context in `extra` parameter\n2. **Log Errors Properly:** Always use `exc_info=True` for exceptions\n3. **Be Consistent:** Use consistent log message formats\n4. **Include Context:** Add relevant IDs, operations, and state\n5. **Security First:** Never log sensitive information\n6. **Appropriate Levels:** Use correct log levels for the situation\n7. **Performance Aware:** Don't log excessively in hot paths\n8. **Test Logging:** Verify logs in tests when testing error paths\n\n## Conclusion\n\nYou **MUST** use the `get_logger(name)` function for all logging. Adhere strictly to the guidelines on what to log and which levels to use. Remember: **by default, do NOT add logging** - only add it when explicitly requested or for critical production monitoring needs.",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "no-hiding",
          "title": "No Hiding",
          "fileName": "no-hiding.mdc",
          "frontmatter": {
            "description": "Critical rule - never hide linter errors or type checker warnings",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# No Hiding Rule\n\n## Critical Rule\n\n**NEVER hide linter errors, type checker warnings, or any code quality issues.**\n\nAll lint errors, type checker warnings, and code quality issues **MUST** be fully resolved. Never suppress, ignore, or bypass them.\n\n## What This Means\n\n### ‚ùå NEVER Do This\n\n```python\n# ‚ùå BAD - Suppressing type checker errors\n# type: ignore\ndef function_with_error():\n    pass\n\n# ‚ùå BAD - Ignoring linter warnings\n# noqa: F401\nfrom unused_module import something\n\n# ‚ùå BAD - Disabling specific checks\n# pylint: disable=unused-argument\ndef function(arg):  # arg is unused\n    pass\n\n# ‚ùå BAD - Using Any to bypass type checking\nfrom typing import Any\n\ndef process_data(data: Any) -> Any:  # Too permissive\n    pass\n\n# ‚ùå BAD - Commenting out problematic code\n# This code has errors but we'll fix it later\n# def broken_function():\n#     return undefined_variable\n```\n\n### ‚úÖ ALWAYS Do This\n\n```python\n# ‚úÖ GOOD - Fix the actual issue\ndef function_with_error() -> None:\n    \"\"\"Properly typed function.\"\"\"\n    pass\n\n# ‚úÖ GOOD - Remove unused imports\n# Just delete the import if it's not used\n\n# ‚úÖ GOOD - Fix unused arguments\ndef function(arg: str) -> None:\n    \"\"\"Use the argument or remove it.\"\"\"\n    print(arg)  # Actually use it\n\n# ‚úÖ GOOD - Use proper types\nfrom app.schemas.user import UserCreate, UserResponse\n\ndef process_data(data: UserCreate) -> UserResponse:\n    \"\"\"Properly typed function.\"\"\"\n    pass\n\n# ‚úÖ GOOD - Fix broken code immediately\ndef fixed_function() -> str:\n    \"\"\"Fixed function.\"\"\"\n    return \"proper_value\"\n```\n\n## Tools We Use\n\n### 1. Ruff (Linter)\n\n**Configuration:** `pyproject.toml`\n\n```toml\n[tool.ruff]\nline-length = 100\ntarget-version = \"py311\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"W\", \"I\", \"N\", \"UP\", \"B\", \"A\", \"C4\", \"DTZ\", \"T10\", \"EM\", \"ISC\", \"ICN\", \"PIE\", \"T20\", \"PYI\", \"PT\", \"Q\", \"RSE\", \"RET\", \"SIM\", \"TID\", \"TCH\", \"INT\", \"ARG\", \"PTH\", \"ERA\", \"PD\", \"PGH\", \"PL\", \"TRY\", \"NPY\", \"RUF\"]\nignore = []\n\n[tool.ruff.lint.per-file-ignores]\n\"__init__.py\" = [\"F401\"]\n```\n\n**Never ignore errors:**\n\n```python\n# ‚ùå BAD\nimport something  # noqa: F401\n\n# ‚úÖ GOOD - Fix the import or remove it\nfrom module import something  # Actually use it\n```\n\n### 2. Mypy (Type Checker)\n\n**Configuration:** `pyproject.toml`\n\n```toml\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\nno_implicit_optional = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_unreachable = true\nstrict_equality = true\n```\n\n**Never suppress type errors:**\n\n```python\n# ‚ùå BAD\ndef function() -> None:  # type: ignore\n    pass\n\n# ‚úÖ GOOD - Fix the type issue\ndef function() -> None:\n    \"\"\"Properly typed.\"\"\"\n    pass\n```\n\n### 3. Black (Formatter)\n\n**Never skip formatting:**\n\n```python\n# ‚ùå BAD\n# fmt: off\nbadly_formatted_code = {\n    \"key\": \"value\"\n}\n# fmt: on\n\n# ‚úÖ GOOD - Let Black format it\nwell_formatted_code = {\"key\": \"value\"}\n```\n\n## Common Scenarios\n\n### Unused Imports\n\n```python\n# ‚ùå BAD\nfrom app.models.user import User  # noqa: F401\n\n# ‚úÖ GOOD - Remove if unused, or use it\nfrom app.models.user import User\n\ndef process_user(user: User) -> None:\n    pass\n```\n\n### Unused Variables\n\n```python\n# ‚ùå BAD\ndef process_data(data: List[str]) -> None:\n    for item in data:  # item is unused\n        pass\n\n# ‚úÖ GOOD - Use the variable or use underscore\ndef process_data(data: List[str]) -> None:\n    for _item in data:  # Use underscore for intentionally unused\n        do_something()\n\n# ‚úÖ BETTER - Actually use it\ndef process_data(data: List[str]) -> None:\n    for item in data:\n        process_item(item)\n```\n\n### Type Errors\n\n```python\n# ‚ùå BAD\ndef get_user(user_id: int) -> dict:  # Too generic\n    return {\"id\": user_id}\n\n# ‚úÖ GOOD - Use proper types\nfrom app.schemas.user import UserResponse\n\ndef get_user(user_id: int) -> UserResponse:\n    return UserResponse(id=user_id, name=\"John\")\n```\n\n### Missing Type Hints\n\n```python\n# ‚ùå BAD\ndef process_data(data):  # No type hints\n    return data\n\n# ‚úÖ GOOD - Add type hints\nfrom typing import Dict, Any\n\ndef process_data(data: Dict[str, Any]) -> Dict[str, Any]:\n    return data\n```\n\n## Pre-commit Hooks\n\nEnsure pre-commit hooks run and **fail** if there are errors:\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.0.292\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]  # Fail on errors\n  \n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.1\n    hooks:\n      - id: mypy\n        args: [--strict]  # Strict mode, fail on errors\n```\n\n## CI/CD Integration\n\n**Never allow errors in CI:**\n\n```yaml\n# .github/workflows/ci.yml\n- name: Run linters\n  run: |\n    ruff check .\n    mypy app/\n    black --check .\n  # These should fail the build if there are errors\n```\n\n## Remember\n\n- **Fix, Don't Suppress** - Always fix the underlying issue\n- **No Type Ignores** - Never use `# type: ignore` without fixing\n- **No Linter Ignores** - Never use `# noqa` without fixing\n- **Strict Mode** - Use strict type checking\n- **Pre-commit** - Let hooks catch errors before commit\n- **CI/CD** - Fail builds on lint/type errors\n- **Code Quality** - Maintain high standards always",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "performance-guidelines",
          "title": "Performance Guidelines",
          "fileName": "performance-guidelines.mdc",
          "frontmatter": {
            "description": "Performance optimization guidelines for Python FastAPI applications",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Performance Guidelines\n\n## Philosophy\n\nPerformance directly impacts user experience and business metrics. Our optimization strategy focuses on:\n1. **Measure First** - Never optimize without data\n2. **Async First** - Use async/await for all I/O operations\n3. **Database Optimization** - Efficient queries and connection pooling\n4. **Caching Strategy** - Cache appropriately, invalidate properly\n5. **Resource Management** - Proper connection and resource handling\n\n## Async Best Practices\n\n### 1. Use Async for All I/O Operations\n\n```python\n# ‚ùå BAD - Blocking I/O\ndef fetch_user_data(user_id: int) -> dict:\n    response = requests.get(f\"https://api.example.com/users/{user_id}\")  # Blocking\n    return response.json()\n\n# ‚úÖ GOOD - Async I/O\nasync def fetch_user_data(user_id: int) -> dict:\n    async with httpx.AsyncClient() as client:\n        response = await client.get(f\"https://api.example.com/users/{user_id}\")\n        return response.json()\n```\n\n### 2. Parallel Operations\n\n```python\n# ‚ùå BAD - Sequential operations\nasync def get_user_data(user_id: int) -> dict:\n    user = await get_user(user_id)\n    posts = await get_user_posts(user_id)\n    comments = await get_user_comments(user_id)\n    return {\"user\": user, \"posts\": posts, \"comments\": comments}\n\n# ‚úÖ GOOD - Parallel operations\nasync def get_user_data(user_id: int) -> dict:\n    user, posts, comments = await asyncio.gather(\n        get_user(user_id),\n        get_user_posts(user_id),\n        get_user_comments(user_id),\n    )\n    return {\"user\": user, \"posts\": posts, \"comments\": comments}\n```\n\n### 3. Proper Async Context Managers\n\n```python\n# ‚ùå BAD - Not using context managers\nasync def process_data():\n    client = httpx.AsyncClient()\n    response = await client.get(\"https://api.example.com/data\")\n    # Connection not properly closed\n\n# ‚úÖ GOOD - Using context managers\nasync def process_data():\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\"https://api.example.com/data\")\n        return response.json()\n    # Connection automatically closed\n```\n\n## Database Optimization\n\n### 1. Connection Pooling\n\n```python\n# app/core/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    pool_size=20,  # Number of connections to maintain\n    max_overflow=10,  # Additional connections beyond pool_size\n    pool_pre_ping=True,  # Verify connections before using\n    pool_recycle=3600,  # Recycle connections after 1 hour\n)\n```\n\n### 2. Query Optimization\n\n```python\n# ‚ùå BAD - N+1 query problem\nasync def get_users_with_posts():\n    users = await session.execute(select(User))\n    result = []\n    for user in users.scalars():\n        posts = await session.execute(\n            select(Post).where(Post.user_id == user.id)\n        )\n        result.append({\"user\": user, \"posts\": posts.scalars().all()})\n\n# ‚úÖ GOOD - Eager loading\nfrom sqlalchemy.orm import selectinload\n\nasync def get_users_with_posts():\n    result = await session.execute(\n        select(User)\n        .options(selectinload(User.posts))\n    )\n    users = result.scalars().all()\n    return [{\"user\": user, \"posts\": user.posts} for user in users]\n```\n\n### 3. Batch Operations\n\n```python\n# ‚ùå BAD - Individual inserts\nasync def create_users(user_data_list: List[dict]):\n    for user_data in user_data_list:\n        user = User(**user_data)\n        session.add(user)\n        await session.commit()  # One commit per user\n\n# ‚úÖ GOOD - Batch insert\nasync def create_users(user_data_list: List[dict]):\n    users = [User(**user_data) for user_data in user_data_list]\n    session.add_all(users)\n    await session.commit()  # Single commit for all\n```\n\n### 4. Index Usage\n\n```python\n# app/models/database/user.py\nfrom sqlalchemy import Column, Integer, String, Index\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True)\n    email = Column(String, unique=True, index=True)  # Indexed for fast lookups\n    status = Column(String)\n    \n    # Composite index for common queries\n    __table_args__ = (\n        Index(\"idx_user_status_email\", \"status\", \"email\"),\n    )\n```\n\n## Caching Strategies\n\n### 1. Function Result Caching\n\n```python\n# app/utils/cache.py\nfrom functools import lru_cache\nfrom typing import Callable, TypeVar\nimport json\nfrom datetime import datetime, timedelta\n\nT = TypeVar(\"T\")\n\n\ndef cache_result(ttl: int = 300):\n    \"\"\"Cache function result with TTL.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        cache: dict = {}\n        \n        async def wrapper(*args, **kwargs) -> T:\n            cache_key = f\"{func.__name__}:{args}:{kwargs}\"\n            \n            if cache_key in cache:\n                value, expiry = cache[cache_key]\n                if datetime.utcnow() < expiry:\n                    return value\n            \n            result = await func(*args, **kwargs)\n            cache[cache_key] = (\n                result,\n                datetime.utcnow() + timedelta(seconds=ttl)\n            )\n            return result\n        \n        return wrapper\n    return decorator\n\n# Usage\n@cache_result(ttl=600)\nasync def get_user_profile(user_id: int) -> User:\n    \"\"\"Get user profile with 10-minute cache.\"\"\"\n    return await user_repository.get_by_id(user_id)\n```\n\n### 2. Redis Caching\n\n```python\n# app/core/cache.py\nfrom redis import asyncio as aioredis\nimport json\nfrom typing import Optional, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass CacheService:\n    \"\"\"Redis-based cache service.\"\"\"\n    \n    def __init__(self, redis_client: aioredis.Redis):\n        self.redis = redis_client\n    \n    async def get(self, key: str) -> Optional[dict]:\n        \"\"\"Get value from cache.\"\"\"\n        value = await self.redis.get(key)\n        if value:\n            return json.loads(value)\n        return None\n    \n    async def set(self, key: str, value: dict, ttl: int = 300) -> None:\n        \"\"\"Set value in cache with TTL.\"\"\"\n        await self.redis.setex(\n            key,\n            ttl,\n            json.dumps(value)\n        )\n    \n    async def delete(self, key: str) -> None:\n        \"\"\"Delete value from cache.\"\"\"\n        await self.redis.delete(key)\n\n# Usage in service\nclass UserService:\n    def __init__(self, db: AsyncSession, cache: CacheService):\n        self.db = db\n        self.cache = cache\n    \n    async def get_user_by_id(self, user_id: int) -> User:\n        \"\"\"Get user with caching.\"\"\"\n        cache_key = f\"user:{user_id}\"\n        \n        # Try cache first\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return User(**cached)\n        \n        # Fetch from database\n        user = await self.repository.get_by_id(user_id)\n        \n        # Cache result\n        if user:\n            await self.cache.set(\n                cache_key,\n                user.model_dump(),\n                ttl=600\n            )\n        \n        return user\n```\n\n## Background Tasks\n\n### 1. Offload Heavy Operations\n\n```python\n# app/tasks/email_tasks.py\nfrom app.core.celery_app import celery_app\n\n@celery_app.task(name=\"send_email\")\ndef send_email_task(email_to: str, subject: str, body: str) -> None:\n    \"\"\"Send email in background.\"\"\"\n    # Heavy email sending logic\n    send_email(email_to, subject, body)\n\n# Usage in API route\n@router.post(\"/users/{user_id}/notify\")\nasync def notify_user(user_id: int):\n    \"\"\"Notify user via email.\"\"\"\n    user = await user_service.get_user_by_id(user_id)\n    \n    # Offload to background task\n    send_email_task.delay(\n        email_to=user.email,\n        subject=\"Welcome!\",\n        body=\"Welcome to our platform!\"\n    )\n    \n    return {\"status\": \"notification_queued\"}\n```\n\n### 2. Batch Processing\n\n```python\n# app/tasks/batch_tasks.py\n@celery_app.task(name=\"process_batch\")\ndef process_batch_task(item_ids: List[int]) -> None:\n    \"\"\"Process items in batch.\"\"\"\n    for item_id in item_ids:\n        process_item(item_id)\n\n# Chunk large batches\ndef process_large_batch(item_ids: List[int], chunk_size: int = 100) -> None:\n    \"\"\"Process large batch in chunks.\"\"\"\n    for i in range(0, len(item_ids), chunk_size):\n        chunk = item_ids[i:i + chunk_size]\n        process_batch_task.delay(chunk)\n```\n\n## Response Optimization\n\n### 1. Response Streaming\n\n```python\nfrom fastapi.responses import StreamingResponse\nimport json\n\n@router.get(\"/users/export\")\nasync def export_users():\n    \"\"\"Stream large user export.\"\"\"\n    async def generate():\n        async for user in user_repository.get_all():\n            yield json.dumps(user.model_dump()) + \"\\n\"\n    \n    return StreamingResponse(\n        generate(),\n        media_type=\"application/jsonl\"\n    )\n```\n\n### 2. Pagination\n\n```python\n# app/schemas/pagination.py\nfrom pydantic import BaseModel\nfrom typing import Generic, TypeVar, List\n\nT = TypeVar(\"T\")\n\n\nclass PaginatedResponse(BaseModel, Generic[T]):\n    \"\"\"Paginated response model.\"\"\"\n    items: List[T]\n    total: int\n    page: int\n    page_size: int\n    pages: int\n\n# Usage\n@router.get(\"/users\", response_model=PaginatedResponse[UserResponse])\nasync def get_users(\n    page: int = Query(1, ge=1),\n    page_size: int = Query(20, ge=1, le=100),\n):\n    \"\"\"Get paginated users.\"\"\"\n    offset = (page - 1) * page_size\n    \n    users, total = await asyncio.gather(\n        user_repository.get_paginated(offset, page_size),\n        user_repository.count(),\n    )\n    \n    return PaginatedResponse(\n        items=[UserResponse.from_orm(u) for u in users],\n        total=total,\n        page=page,\n        page_size=page_size,\n        pages=(total + page_size - 1) // page_size,\n    )\n```\n\n## Performance Monitoring\n\n### 1. Request Timing Middleware\n\n```python\n# app/core/middleware.py\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass TimingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware to track request timing.\"\"\"\n    \n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n        response = await call_next(request)\n        duration = time.time() - start_time\n        \n        # Log slow requests\n        if duration > 1.0:\n            logger.warning(\n                \"Slow request detected\",\n                extra={\n                    \"path\": request.url.path,\n                    \"method\": request.method,\n                    \"duration\": duration,\n                }\n            )\n        \n        response.headers[\"X-Process-Time\"] = str(duration)\n        return response\n```\n\n### 2. Database Query Logging\n\n```python\n# Enable SQLAlchemy query logging in development\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=settings.DEBUG,  # Log queries in debug mode\n)\n```\n\n## Best Practices Checklist\n\n### Before Deploy\n- [ ] All I/O operations use async/await\n- [ ] Database queries are optimized (no N+1 problems)\n- [ ] Appropriate indexes are in place\n- [ ] Heavy operations are offloaded to background tasks\n- [ ] Caching is implemented for frequently accessed data\n- [ ] Connection pooling is properly configured\n- [ ] Response pagination is implemented for large datasets\n\n### Monitoring\n- [ ] Request timing is tracked\n- [ ] Slow queries are logged\n- [ ] Database connection pool metrics are monitored\n- [ ] Cache hit rates are tracked\n- [ ] Background task queue depth is monitored\n\n## Anti-Patterns to Avoid\n\n```python\n# ‚ùå Blocking I/O in async functions\nasync def fetch_data():\n    response = requests.get(\"https://api.example.com\")  # Blocking\n\n# ‚ùå N+1 query problems\nfor user in users:\n    posts = await get_posts(user.id)  # One query per user\n\n# ‚ùå Loading entire dataset\nall_users = await session.execute(select(User))  # Loads all users\n\n# ‚ùå No connection pooling\nengine = create_async_engine(url, pool_size=1)  # Too small\n\n# ‚ùå Synchronous operations in async context\ndef process_data():\n    time.sleep(5)  # Blocking sleep\n```\n\n## Remember\n\n- **Measure before optimizing** - Use profiling tools\n- **Async first** - All I/O should be async\n- **Database optimization** - Efficient queries and proper indexing\n- **Cache appropriately** - Don't cache everything, cache smartly\n- **Background tasks** - Offload heavy operations\n- **Monitor performance** - Track metrics and set up alerts",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "security-guidelines",
          "title": "Security Guidelines",
          "fileName": "security-guidelines.mdc",
          "frontmatter": {
            "description": "Security best practices for Python FastAPI applications",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Security Guidelines\n\n## Authentication\n\n### JWT Tokens\n\n```python\n# app/core/security.py\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against a hash.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hash a password.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    \n    to_encode.update({\"exp\": expire, \"iat\": datetime.utcnow()})\n    encoded_jwt = jwt.encode(\n        to_encode,\n        settings.SECRET_KEY,\n        algorithm=settings.ALGORITHM\n    )\n    return encoded_jwt\n```\n\n### Token Validation\n\n```python\n# app/api/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nfrom app.core.config import settings\nfrom app.core.database import get_db\nfrom app.models.domain.user import User\nfrom app.repositories.user_repository import UserRepository\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"api/v1/auth/login\")\n\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    db: AsyncSession = Depends(get_db),\n) -> User:\n    \"\"\"Get current authenticated user.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    try:\n        payload = jwt.decode(\n            token,\n            settings.SECRET_KEY,\n            algorithms=[settings.ALGORITHM]\n        )\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user_repo = UserRepository(db)\n    user = await user_repo.get_by_id(user_id)\n    \n    if user is None or not user.is_active:\n        raise credentials_exception\n    \n    return user\n```\n\n## Authorization\n\n### Role-Based Access Control (RBAC)\n\n```python\n# app/core/permissions.py\nfrom enum import Enum\nfrom fastapi import HTTPException, status\n\nfrom app.models.domain.user import User\n\n\nclass Role(str, Enum):\n    \"\"\"User roles.\"\"\"\n    ADMIN = \"admin\"\n    USER = \"user\"\n    MODERATOR = \"moderator\"\n\n\ndef require_role(required_role: Role):\n    \"\"\"Dependency to require specific role.\"\"\"\n    async def role_checker(current_user: User = Depends(get_current_user)) -> User:\n        if current_user.role != required_role:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Requires {required_role.value} role\"\n            )\n        return current_user\n    return role_checker\n\n# Usage\n@router.delete(\"/users/{user_id}\")\nasync def delete_user(\n    user_id: int,\n    current_user: User = Depends(require_role(Role.ADMIN)),\n):\n    \"\"\"Delete user - requires admin role.\"\"\"\n    pass\n```\n\n## Input Validation\n\n### Always Validate with Pydantic\n\n```python\n# ‚úÖ GOOD - Pydantic validation\nfrom pydantic import BaseModel, EmailStr, Field, validator\n\nclass UserCreate(BaseModel):\n    \"\"\"User creation schema with validation.\"\"\"\n    email: EmailStr  # Automatically validates email format\n    full_name: str = Field(..., min_length=1, max_length=255)\n    password: str = Field(..., min_length=8, max_length=100)\n    \n    @validator('password')\n    def validate_password_strength(cls, v):\n        \"\"\"Validate password meets security requirements.\"\"\"\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters')\n        if not any(c.isupper() for c in v):\n            raise ValueError('Password must contain uppercase letter')\n        if not any(c.islower() for c in v):\n            raise ValueError('Password must contain lowercase letter')\n        if not any(c.isdigit() for c in v):\n            raise ValueError('Password must contain digit')\n        return v\n\n# ‚ùå BAD - No validation\n@router.post(\"/users\")\nasync def create_user(email: str, password: str):  # No validation!\n    pass\n```\n\n## SQL Injection Prevention\n\n### Use ORM, Not Raw SQL\n\n```python\n# ‚ùå BAD - SQL injection risk\nquery = f\"SELECT * FROM users WHERE email = '{email}'\"  # Vulnerable!\nresult = await session.execute(text(query))\n\n# ‚úÖ GOOD - Use ORM with parameters\nresult = await session.execute(\n    select(User).where(User.email == email)  # Safe\n)\n\n# ‚úÖ ACCEPTABLE - Parameterized raw SQL if needed\nquery = text(\"SELECT * FROM users WHERE email = :email\")\nresult = await session.execute(query, {\"email\": email})  # Safe\n```\n\n## Secrets Management\n\n### Never Hardcode Secrets\n\n```python\n# ‚ùå BAD - Hardcoded secret\nSECRET_KEY = \"my-secret-key-12345\"  # Never do this!\n\n# ‚úÖ GOOD - Environment variables\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    SECRET_KEY: str\n    DATABASE_URL: str\n    REDIS_URL: str\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = True\n\nsettings = Settings()\n```\n\n### Use Secret Managers in Production\n\n```python\n# ‚úÖ GOOD - Use secret manager (AWS Secrets Manager, etc.)\nimport boto3\n\ndef get_secret(secret_name: str) -> str:\n    \"\"\"Get secret from AWS Secrets Manager.\"\"\"\n    client = boto3.client('secretsmanager')\n    response = client.get_secret_value(SecretId=secret_name)\n    return response['SecretString']\n```\n\n## CORS Configuration\n\n### Proper CORS Setup\n\n```python\n# app/main.py\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.ALLOWED_ORIGINS,  # List of allowed origins\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"*\"],\n)\n```\n\n## Rate Limiting\n\n### Implement Rate Limiting\n\n```python\n# app/core/rate_limit.py\nfrom collections import defaultdict\nfrom datetime import datetime, timedelta\nfrom fastapi import HTTPException, status, Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass RateLimitMiddleware(BaseHTTPMiddleware):\n    \"\"\"Rate limiting middleware.\"\"\"\n    \n    def __init__(self, app, calls: int = 100, period: int = 60):\n        super().__init__(app)\n        self.calls = calls\n        self.period = period\n        self.clients: dict[str, list[datetime]] = defaultdict(list)\n    \n    async def dispatch(self, request: Request, call_next):\n        client_ip = request.client.host\n        now = datetime.utcnow()\n        \n        # Clean old entries\n        self.clients[client_ip] = [\n            timestamp for timestamp in self.clients[client_ip]\n            if now - timestamp < timedelta(seconds=self.period)\n        ]\n        \n        # Check rate limit\n        if len(self.clients[client_ip]) >= self.calls:\n            raise HTTPException(\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n                detail=\"Rate limit exceeded\"\n            )\n        \n        # Add current request\n        self.clients[client_ip].append(now)\n        \n        response = await call_next(request)\n        return response\n```\n\n## Security Headers\n\n### Add Security Headers\n\n```python\n# app/core/middleware.py\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\n\nclass SecurityHeadersMiddleware(BaseHTTPMiddleware):\n    \"\"\"Add security headers to responses.\"\"\"\n    \n    async def dispatch(self, request: Request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        response.headers[\"X-Frame-Options\"] = \"DENY\"\n        response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n        response.headers[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains\"\n        return response\n```\n\n## Data Sanitization\n\n### Sanitize User Input\n\n```python\n# ‚úÖ GOOD - Sanitize HTML\nfrom html import escape\n\ndef sanitize_html(text: str) -> str:\n    \"\"\"Sanitize HTML input.\"\"\"\n    return escape(text)\n\n# ‚úÖ GOOD - Validate file uploads\nfrom fastapi import UploadFile\n\n@router.post(\"/upload\")\nasync def upload_file(file: UploadFile):\n    \"\"\"Upload file with validation.\"\"\"\n    # Check file type\n    allowed_types = [\"image/jpeg\", \"image/png\"]\n    if file.content_type not in allowed_types:\n        raise HTTPException(status_code=400, detail=\"Invalid file type\")\n    \n    # Check file size (10MB limit)\n    contents = await file.read()\n    if len(contents) > 10 * 1024 * 1024:\n        raise HTTPException(status_code=400, detail=\"File too large\")\n    \n    # Process file\n    pass\n```\n\n## Logging Security\n\n### Never Log Sensitive Data\n\n```python\n# ‚ùå BAD - Logging sensitive data\nlogger.info(f\"User login: {email}, password: {password}\")  # Never!\n\n# ‚úÖ GOOD - Log safely\nlogger.info(\n    \"User login attempt\",\n    extra={\n        \"email\": email,  # Email is usually OK\n        # Never log password, tokens, or secrets\n    }\n)\n\n# ‚ùå BAD - Logging full request body\nlogger.debug(f\"Request body: {request.body}\")  # May contain secrets\n\n# ‚úÖ GOOD - Log selectively\nlogger.debug(\n    \"API request\",\n    extra={\n        \"path\": request.url.path,\n        \"method\": request.method,\n        # Don't log body if it may contain secrets\n    }\n)\n```\n\n## Best Practices Checklist\n\n- [ ] All passwords are hashed (never plain text)\n- [ ] JWT tokens have expiration times\n- [ ] Input validation with Pydantic on all endpoints\n- [ ] SQL injection prevented (use ORM)\n- [ ] Secrets in environment variables, not code\n- [ ] CORS properly configured\n- [ ] Rate limiting implemented\n- [ ] Security headers added\n- [ ] Sensitive data not logged\n- [ ] File uploads validated\n- [ ] Authentication on protected endpoints\n- [ ] Authorization checks in place\n\n## Remember\n\n- **Never trust user input** - Always validate\n- **Never log secrets** - Passwords, tokens, API keys\n- **Use ORM** - Prevent SQL injection\n- **Hash passwords** - Never store plain text\n- **Secure tokens** - Use JWT with expiration\n- **Environment variables** - For all secrets\n- **Rate limiting** - Prevent abuse\n- **Security headers** - Add protection headers",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        },
        {
          "id": "testing",
          "title": "Testing",
          "fileName": "testing.mdc",
          "frontmatter": {
            "description": "Testing philosophy and patterns for Python FastAPI codebase",
            "globs": [
              "**/tests/**",
              "**/*test*.py",
              "**/*_test.py"
            ],
            "alwaysApply": true
          },
          "content": "# Testing Guidelines\n\n## Testing Philosophy\n\nOur testing strategy focuses on **testing logic and behavior, not implementation details**. We prioritize testing at the appropriate layer of abstraction to ensure maintainability and meaningful test coverage.\n\n### Core Principles\n\n1. **Test Business Logic in Services** - All business logic should reside in service functions and be thoroughly tested\n2. **Test Repositories Separately** - Data access layer should have isolated tests\n3. **Test API Routes with Integration Tests** - Test the full request/response cycle\n4. **Backend API Routes Test Integration** - Test the service layer through API endpoints\n5. **Focus on Behavior** - Test what the code does, not how it does it\n\n## Testing Stack\n\n- **Framework:** [pytest](https://pytest.org/)\n- **Async Support:** pytest-asyncio\n- **Coverage:** pytest-cov\n- **Mocking:** pytest-mock and unittest.mock\n- **HTTP Testing:** httpx (async HTTP client)\n- **Database Testing:** Test database with fixtures\n\n## What to Test\n\n### 1. Service Layer (`app/services/**`)\n\n**Priority: CRITICAL** - This is where all business logic lives\n\n```python\n# tests/services/test_user_service.py\nimport pytest\nfrom unittest.mock import AsyncMock, MagicMock\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.services.user_service import UserService\nfrom app.repositories.user_repository import UserRepository\nfrom app.schemas.user import UserCreate\nfrom app.core.exceptions import NotFoundError, ConflictError\nfrom app.models.domain.user import User\n\n\n@pytest.fixture\ndef mock_db():\n    \"\"\"Mock database session.\"\"\"\n    return AsyncMock(spec=AsyncSession)\n\n\n@pytest.fixture\ndef mock_repository(mock_db):\n    \"\"\"Mock user repository.\"\"\"\n    return AsyncMock(spec=UserRepository)\n\n\n@pytest.fixture\ndef user_service(mock_db, mock_repository):\n    \"\"\"User service instance.\"\"\"\n    service = UserService(mock_db)\n    service.repository = mock_repository\n    return service\n\n\n@pytest.mark.asyncio\nasync def test_get_user_by_id_success(user_service, mock_repository):\n    \"\"\"Test getting user by ID successfully.\"\"\"\n    # Arrange\n    user_id = 1\n    expected_user = User(\n        id=user_id,\n        email=\"test@example.com\",\n        full_name=\"Test User\",\n        is_active=True,\n    )\n    mock_repository.get_by_id.return_value = expected_user\n    \n    # Act\n    result = await user_service.get_user_by_id(user_id)\n    \n    # Assert\n    assert result == expected_user\n    mock_repository.get_by_id.assert_called_once_with(user_id)\n\n\n@pytest.mark.asyncio\nasync def test_get_user_by_id_not_found(user_service, mock_repository):\n    \"\"\"Test getting non-existent user raises NotFoundError.\"\"\"\n    # Arrange\n    user_id = 999\n    mock_repository.get_by_id.return_value = None\n    \n    # Act & Assert\n    with pytest.raises(NotFoundError, match=\"User not found\"):\n        await user_service.get_user_by_id(user_id)\n\n\n@pytest.mark.asyncio\nasync def test_create_user_success(user_service, mock_repository):\n    \"\"\"Test creating user successfully.\"\"\"\n    # Arrange\n    user_data = UserCreate(\n        email=\"new@example.com\",\n        full_name=\"New User\",\n        password=\"securepassword123\",\n    )\n    expected_user = User(\n        id=1,\n        email=user_data.email,\n        full_name=user_data.full_name,\n        is_active=True,\n    )\n    mock_repository.get_by_email.return_value = None\n    mock_repository.create.return_value = expected_user\n    \n    # Act\n    result = await user_service.create_user(user_data)\n    \n    # Assert\n    assert result == expected_user\n    mock_repository.get_by_email.assert_called_once_with(user_data.email)\n    mock_repository.create.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_create_user_email_exists(user_service, mock_repository):\n    \"\"\"Test creating user with existing email raises ConflictError.\"\"\"\n    # Arrange\n    user_data = UserCreate(\n        email=\"existing@example.com\",\n        full_name=\"New User\",\n        password=\"securepassword123\",\n    )\n    existing_user = User(id=1, email=user_data.email, full_name=\"Existing\")\n    mock_repository.get_by_email.return_value = existing_user\n    \n    # Act & Assert\n    with pytest.raises(ConflictError, match=\"already exists\"):\n        await user_service.create_user(user_data)\n```\n\n### 2. Repository Layer (`app/repositories/**`)\n\n**Priority: HIGH** - Data access must be reliable\n\n```python\n# tests/repositories/test_user_repository.py\nimport pytest\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom app.repositories.user_repository import UserRepository\nfrom app.models.database.user import User as UserModel\nfrom app.core.exceptions import ConflictError\n\n\n@pytest.mark.asyncio\nasync def test_get_by_id_success(db_session: AsyncSession):\n    \"\"\"Test getting user by ID from database.\"\"\"\n    # Arrange\n    repository = UserRepository(db_session)\n    user_model = UserModel(\n        email=\"test@example.com\",\n        full_name=\"Test User\",\n        hashed_password=\"hashed\",\n    )\n    db_session.add(user_model)\n    await db_session.commit()\n    await db_session.refresh(user_model)\n    \n    # Act\n    result = await repository.get_by_id(user_model.id)\n    \n    # Assert\n    assert result is not None\n    assert result.id == user_model.id\n    assert result.email == user_model.email\n\n\n@pytest.mark.asyncio\nasync def test_create_user_success(db_session: AsyncSession):\n    \"\"\"Test creating user in database.\"\"\"\n    # Arrange\n    repository = UserRepository(db_session)\n    user_data = {\n        \"email\": \"new@example.com\",\n        \"full_name\": \"New User\",\n        \"hashed_password\": \"hashed\",\n    }\n    \n    # Act\n    result = await repository.create(user_data)\n    \n    # Assert\n    assert result.id is not None\n    assert result.email == user_data[\"email\"]\n    \n    # Verify in database\n    db_result = await db_session.execute(\n        select(UserModel).where(UserModel.id == result.id)\n    )\n    db_user = db_result.scalar_one()\n    assert db_user.email == user_data[\"email\"]\n```\n\n### 3. API Routes (`app/api/**`)\n\n**Priority: HIGH** - API endpoints must work correctly\n\n```python\n# tests/api/v1/endpoints/test_users.py\nimport pytest\nfrom httpx import AsyncClient\nfrom fastapi import status\n\nfrom app.main import app\n\n\n@pytest.mark.asyncio\nasync def test_get_user_success(client: AsyncClient, test_user, auth_headers):\n    \"\"\"Test getting user via API.\"\"\"\n    # Act\n    response = await client.get(\n        f\"/api/v1/users/{test_user.id}\",\n        headers=auth_headers,\n    )\n    \n    # Assert\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"id\"] == test_user.id\n    assert data[\"email\"] == test_user.email\n\n\n@pytest.mark.asyncio\nasync def test_get_user_not_found(client: AsyncClient, auth_headers):\n    \"\"\"Test getting non-existent user returns 404.\"\"\"\n    # Act\n    response = await client.get(\n        \"/api/v1/users/99999\",\n        headers=auth_headers,\n    )\n    \n    # Assert\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    data = response.json()\n    assert \"error\" in data\n\n\n@pytest.mark.asyncio\nasync def test_create_user_success(client: AsyncClient, auth_headers):\n    \"\"\"Test creating user via API.\"\"\"\n    # Arrange\n    user_data = {\n        \"email\": \"newuser@example.com\",\n        \"full_name\": \"New User\",\n        \"password\": \"securepassword123\",\n    }\n    \n    # Act\n    response = await client.post(\n        \"/api/v1/users\",\n        json=user_data,\n        headers=auth_headers,\n    )\n    \n    # Assert\n    assert response.status_code == status.HTTP_201_CREATED\n    data = response.json()\n    assert data[\"email\"] == user_data[\"email\"]\n    assert \"id\" in data\n\n\n@pytest.mark.asyncio\nasync def test_create_user_unauthorized(client: AsyncClient):\n    \"\"\"Test creating user without authentication returns 401.\"\"\"\n    # Arrange\n    user_data = {\n        \"email\": \"newuser@example.com\",\n        \"full_name\": \"New User\",\n        \"password\": \"securepassword123\",\n    }\n    \n    # Act\n    response = await client.post(\n        \"/api/v1/users\",\n        json=user_data,\n    )\n    \n    # Assert\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\n### 4. Utility Functions (`app/utils/**`)\n\n**Priority: MEDIUM** - Pure functions and helpers\n\n```python\n# tests/utils/test_formatters.py\nimport pytest\nfrom datetime import datetime\n\nfrom app.utils.formatters import format_currency, format_date\n\n\ndef test_format_currency_usd():\n    \"\"\"Test formatting currency in USD.\"\"\"\n    result = format_currency(1234.56, \"USD\")\n    assert result == \"$1,234.56\"\n\n\ndef test_format_date():\n    \"\"\"Test formatting date.\"\"\"\n    date = datetime(2024, 1, 15, 10, 30, 0)\n    result = format_date(date)\n    assert result == \"2024-01-15\"\n```\n\n## What NOT to Test\n\n### 1. External Libraries\n\nDon't test third-party library functionality:\n\n```python\n# ‚ùå DON'T TEST - Testing SQLAlchemy itself\ndef test_sqlalchemy_query():\n    result = session.query(User).filter(User.id == 1).first()\n    # This tests SQLAlchemy, not our code\n\n# ‚úÖ DO TEST - Test our repository logic\nasync def test_repository_get_by_id():\n    user = await repository.get_by_id(1)\n    assert user is not None\n```\n\n### 2. Framework Code\n\nDon't test FastAPI framework functionality:\n\n```python\n# ‚ùå DON'T TEST - Testing FastAPI routing\ndef test_fastapi_router():\n    # Testing framework, not our code\n\n# ‚úÖ DO TEST - Test our route handlers\nasync def test_get_user_endpoint():\n    response = await client.get(\"/api/v1/users/1\")\n    assert response.status_code == 200\n```\n\n## Test Organization\n\n```\ntests/\n‚îú‚îÄ‚îÄ conftest.py              # Shared fixtures\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îî‚îÄ‚îÄ v1/\n‚îÇ       ‚îî‚îÄ‚îÄ endpoints/\n‚îÇ           ‚îú‚îÄ‚îÄ test_users.py\n‚îÇ           ‚îî‚îÄ‚îÄ test_auth.py\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ test_user_service.py\n‚îÇ   ‚îî‚îÄ‚îÄ test_item_service.py\n‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îú‚îÄ‚îÄ test_user_repository.py\n‚îÇ   ‚îî‚îÄ‚îÄ test_item_repository.py\n‚îî‚îÄ‚îÄ utils/\n    ‚îî‚îÄ‚îÄ test_formatters.py\n```\n\n## Test Fixtures\n\n```python\n# tests/conftest.py\nimport pytest\nimport asyncio\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\n\nfrom app.main import app\nfrom app.core.database import Base, get_db\nfrom app.models.database.user import User as UserModel\nfrom app.core.security import get_password_hash\n\n\n# Database fixtures\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest.fixture(scope=\"function\")\nasync def db_session():\n    \"\"\"Create test database session.\"\"\"\n    engine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    \n    async_session = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n    async with async_session() as session:\n        yield session\n        await session.rollback()\n    \n    await engine.dispose()\n\n\n@pytest.fixture\nasync def client(db_session: AsyncSession):\n    \"\"\"Create test HTTP client.\"\"\"\n    async def override_get_db():\n        yield db_session\n    \n    app.dependency_overrides[get_db] = override_get_db\n    \n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n    \n    app.dependency_overrides.clear()\n\n\n@pytest.fixture\nasync def test_user(db_session: AsyncSession):\n    \"\"\"Create test user.\"\"\"\n    user = UserModel(\n        email=\"test@example.com\",\n        full_name=\"Test User\",\n        hashed_password=get_password_hash(\"testpassword123\"),\n        is_active=True,\n    )\n    db_session.add(user)\n    await db_session.commit()\n    await db_session.refresh(user)\n    return user\n\n\n@pytest.fixture\nasync def auth_headers(client: AsyncClient, test_user):\n    \"\"\"Get authentication headers.\"\"\"\n    response = await client.post(\n        \"/api/v1/auth/login\",\n        data={\n            \"username\": test_user.email,\n            \"password\": \"testpassword123\",\n        },\n    )\n    token = response.json()[\"access_token\"]\n    return {\"Authorization\": f\"Bearer {token}\"}\n```\n\n## Testing Best Practices\n\n### 1. Test Behavior, Not Implementation\n\n```python\n# ‚ùå BAD - Testing implementation details\ndef test_service_calls_repository():\n    assert mock_repository.get_by_id.called\n\n# ‚úÖ GOOD - Testing behavior\nasync def test_get_user_returns_user():\n    user = await service.get_user_by_id(1)\n    assert user.id == 1\n```\n\n### 2. Use Descriptive Test Names\n\n```python\n# ‚ùå BAD\ndef test_user_creation():\n    pass\n\n# ‚úÖ GOOD\ndef test_create_user_with_valid_data_returns_user():\n    pass\n\ndef test_create_user_with_existing_email_raises_conflict_error():\n    pass\n```\n\n### 3. Arrange-Act-Assert Pattern\n\n```python\ndef test_example():\n    # Arrange\n    user_data = UserCreate(email=\"test@example.com\", ...)\n    \n    # Act\n    result = await service.create_user(user_data)\n    \n    # Assert\n    assert result.email == user_data.email\n```\n\n### 4. Isolate External Dependencies\n\n```python\n# Always mock external services\n@pytest.fixture\ndef mock_external_api():\n    with patch(\"app.services.external_api_client\") as mock:\n        yield mock\n```\n\n## Running Tests\n\n```bash\n# Run all tests\npytest\n\n# Run with coverage\npytest --cov=app --cov-report=html\n\n# Run specific test file\npytest tests/services/test_user_service.py\n\n# Run specific test\npytest tests/services/test_user_service.py::test_get_user_by_id_success\n\n# Run in watch mode (requires pytest-watch)\nptw\n```\n\n## Coverage Goals\n\n- **Services (`app/services/`)**: 100% coverage required\n- **Repositories (`app/repositories/`)**: 100% coverage required\n- **API Routes**: 90%+ coverage recommended\n- **Utility Functions**: 90%+ coverage recommended\n- **Overall**: Focus on critical business logic, not lines of code\n\n## Mocking Guidelines\n\n### 1. Mock at the Boundary\n\n```python\n# Mock external services, not internal modules\nfrom unittest.mock import patch\n\n@patch(\"app.services.external_api_client\")  # ‚úÖ Good\nasync def test_service():\n    pass\n\n@patch(\"app.services.internal_helper\")  # ‚ùå Avoid\nasync def test_service():\n    pass\n```\n\n### 2. Use Consistent Mock Patterns\n\n```python\n# Create reusable mock factories\ndef create_mock_user(overrides=None):\n    \"\"\"Create mock user.\"\"\"\n    defaults = {\n        \"id\": 1,\n        \"email\": \"test@example.com\",\n        \"full_name\": \"Test User\",\n    }\n    if overrides:\n        defaults.update(overrides)\n    return User(**defaults)\n```\n\n## Remember\n\n- **Test Behavior**: Focus on what the code does, not how\n- **Isolate Dependencies**: Mock external services and databases\n- **Fast Feedback**: Tests should run quickly to encourage TDD\n- **Clear Names**: Test names should describe what is being tested\n- **One Assertion**: Prefer one assertion per test when possible",
          "alwaysApply": true,
          "globs": [
            "**/tests/**",
            "**/*test*.py",
            "**/*_test.py"
          ]
        }
      ]
    },
    {
      "id": "solidity-foundry",
      "name": "Solidity + Foundry",
      "directory": "solidity + foundry",
      "icon": "icons/solidity.png",
      "summary": "Smart contract engineering with Foundry",
      "focus": "Security-first, gas efficiency, upgradeability",
      "readme": "# Cursor Rules for Solidity + Foundry Projects\n\nThis repository contains Cursor AI coding rules and guidelines for Solidity smart contract development using Foundry. These rules help maintain consistency, code quality, security, and best practices across the codebase when working with AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and architectural decisions.\n\n## Overview of Rules\n\n### üìã Core Framework & Language (`core-framework-&-language.mdc`)\nDefines the foundational technology stack:\n- **Language:** Solidity 0.8.20+\n- **Framework:** Foundry (Forge, Cast, Anvil, Chisel)\n- **Testing:** Foundry Test Suite\n- **Deployment:** Foundry Scripts\n- **Version Management:** Solidity version pragmas\n\n### üîí Security Guidelines (`security-guidelines.mdc`)\n**CRITICAL** - Security best practices for smart contracts:\n- **Common Vulnerabilities:** Reentrancy, overflow/underflow, access control\n- **Best Practices:** Checks-Effects-Interactions pattern, access control, input validation\n- **Audit Considerations:** Security patterns and anti-patterns\n- **Gas Optimization:** While maintaining security\n- **Upgradeability:** Proxy patterns and upgrade safety\n\n### üéØ Code Style Guidelines (`code-style-guidelines.mdc`)\nComprehensive Solidity code style guide:\n- **Formatting:** Solidity Style Guide compliance\n- **Naming:** camelCase for variables/functions, PascalCase for contracts\n- **Spacing:** 4-space indentation, consistent spacing rules\n- **Ordering:** Contract elements in standard order\n- **Comments:** NatSpec documentation standards\n- **NEVER abbreviate variables** - Always use full, descriptive names\n\n### üèóÔ∏è Key Architectural Patterns (`key-architecture-patterns.mdc`)\nCore architectural patterns for smart contracts:\n- **Contract Organization:** Separation of concerns, interfaces\n- **Access Control:** Ownable, Role-based access control\n- **Upgradeability:** Proxy patterns (UUPS, Transparent)\n- **Factory Patterns:** Contract factories and clones\n- **Library Patterns:** Reusable libraries\n- **Event Patterns:** Comprehensive event emission\n\n### üí¨ Commenting Guidelines (`commenting-guidelines.mdc`)\nNatSpec documentation standards:\n- **Format:** NatSpec (`///` and `/** */`) for all public/external functions\n- **Tags:** `@title`, `@author`, `@notice`, `@dev`, `@param`, `@return`, `@custom:`\n- **Focus:** Explain the \"why\" and \"intent\", not just the \"what\"\n- **When to Comment:** Public/external functions, complex logic, security considerations\n\n### üìù Logging Guidelines (`logging-guidelines.mdc`)\n**‚ö†Ô∏è IMPORTANT: Use events for logging, not console.log in production.**\n\nComprehensive event logging standards:\n- **Events:** Emit events for all important state changes\n- **Event Design:** Indexed parameters, clear naming\n- **Gas Considerations:** Event gas costs\n- **Best Practices:** When to emit events, what data to include\n\n### ‚úÖ No Hiding (`no-hiding.mdc`)\n**Critical Rule:** Never hide compiler warnings, linter errors, or security issues. All must be resolved.\n\n### üß™ Testing (`testing.mdc`)\nComprehensive testing philosophy with Foundry:\n- **Framework:** Foundry Test Suite (Forge)\n- **Coverage:** Aim for 100% coverage of critical paths\n- **Test Types:** Unit tests, integration tests, fuzz tests, invariant tests\n- **Test Organization:** Tests mirror contract structure\n- **Forking:** Mainnet fork testing for integration\n- **Gas Snapshots:** Track gas usage\n\n### üö® Error Handling Patterns (`error-handling-patterns.mdc`)\nComprehensive error management:\n- **Custom Errors:** Use custom errors (gas efficient)\n- **Require Statements:** When to use require vs custom errors\n- **Revert Conditions:** Clear error messages\n- **Error Propagation:** Handling errors in complex flows\n- **Gas Optimization:** Custom errors vs require strings\n\n### ‚ö° Performance Guidelines (`performance-guidelines.mdc`)\nGas optimization and performance:\n- **Gas Optimization:** Storage vs memory, loop optimization\n- **Storage Patterns:** Packing structs, storage layout\n- **Function Optimization:** Minimize external calls, batch operations\n- **Compiler Optimization:** Solidity compiler settings\n- **Gas Profiling:** Using Foundry's gas reporting\n\n### üîÄ Git Workflow (`git-workflow.mdc`)\nVersion control standards:\n- **Commit Format:** Conventional Commits\n- **Branch Naming:** Consistent conventions\n- **Pull Requests:** PR template and process\n- **Pre-commit Hooks:** Solidity linters, formatters\n\n### üëÄ Code Review (`code-review.mdc`)\nCode review checklist:\n- **Security:** Check for common vulnerabilities\n- **Gas Efficiency:** Review gas usage\n- **Tests:** Verify test coverage and quality\n- **Documentation:** Check NatSpec completeness\n- **Style:** Follows all guidelines\n\n### üì¶ Dependency Management (`dependency-management.mdc`)\nDependency handling:\n- **Foundry:** Using `foundry.toml` for configuration\n- **Git Submodules:** Managing dependencies via git\n- **Version Pinning:** Specific commit hashes\n- **Security:** Regular dependency audits\n\n### ‚öñÔ∏è Conflict Resolution (`conflict-resolution.mdc`)\nGuidance for resolving rule conflicts:\n- **Priority Hierarchy:** Rule precedence order\n- **Common Scenarios:** How to handle specific conflicts\n- **Decision Process:** Step-by-step conflict resolution\n- **Documentation:** When and how to document exceptions\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @security-guidelines.mdc Please review this function for security issues\n   ```\n\n### File Structure\n\n```\nvibe-coding-rules/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ solidity + foundry/\n    ‚îú‚îÄ‚îÄ code-review.mdc\n    ‚îú‚îÄ‚îÄ code-style-guidelines.mdc\n    ‚îú‚îÄ‚îÄ commenting-guidelines.mdc\n    ‚îú‚îÄ‚îÄ conflict-resolution.mdc\n    ‚îú‚îÄ‚îÄ core-framework-&-language.mdc\n    ‚îú‚îÄ‚îÄ dependency-management.mdc\n    ‚îú‚îÄ‚îÄ error-handling-patterns.mdc\n    ‚îú‚îÄ‚îÄ git-workflow.mdc\n    ‚îú‚îÄ‚îÄ key-architecture-patterns.mdc\n    ‚îú‚îÄ‚îÄ logging-guidelines.mdc\n    ‚îú‚îÄ‚îÄ no-hiding.mdc\n    ‚îú‚îÄ‚îÄ performance-guidelines.mdc\n    ‚îî‚îÄ‚îÄ security-guidelines.mdc\n    ‚îî‚îÄ‚îÄ testing.mdc\n```\n\n## Quick Reference\n\n### When Writing Contracts\n- ‚úÖ Follow Solidity Style Guide\n- ‚úÖ **NEVER abbreviate variables** - Always use descriptive names\n- ‚úÖ Use NatSpec comments for all public/external functions\n- ‚úÖ Never hide compiler warnings or linter errors\n- ‚úÖ Emit events for all important state changes\n- ‚úÖ Follow security best practices (checks-effects-interactions)\n\n### When Writing Tests\n- ‚úÖ Write comprehensive Foundry tests\n- ‚úÖ Use fuzz testing for input validation\n- ‚úÖ Test edge cases and error conditions\n- ‚úÖ Use gas snapshots to track optimization\n- ‚úÖ Fork mainnet for integration testing when needed\n\n### When Handling Errors\n- ‚úÖ Use custom errors (gas efficient)\n- ‚úÖ Provide clear error messages\n- ‚úÖ Validate all inputs\n- ‚úÖ Use require statements appropriately\n\n### When Optimizing Gas\n- ‚úÖ Profile before optimizing\n- ‚úÖ Use storage packing where possible\n- ‚úÖ Minimize external calls\n- ‚úÖ Use events instead of storage for logs\n- ‚úÖ Consider batch operations\n\n### When Managing Security\n- ‚úÖ Check for reentrancy vulnerabilities\n- ‚úÖ Implement proper access control\n- ‚úÖ Validate all inputs\n- ‚úÖ Use checks-effects-interactions pattern\n- ‚úÖ Consider upgradeability patterns carefully\n\n### When Committing Code\n- ‚úÖ Use Conventional Commits format\n- ‚úÖ Run pre-commit hooks (linters, formatters)\n- ‚úÖ Write clear commit messages\n- ‚úÖ Make atomic commits\n- ‚úÖ Never commit private keys or secrets\n\n### When Reviewing Code\n- ‚úÖ Check for security vulnerabilities\n- ‚úÖ Verify gas efficiency\n- ‚úÖ Ensure test coverage\n- ‚úÖ Review NatSpec documentation\n- ‚úÖ Verify adherence to all guidelines\n\n## Contributing\n\nWhen updating these rules:\n1. Keep guidelines clear and actionable\n2. Include examples where helpful\n3. Update this README if adding new rule files\n4. Ensure consistency across all rule files\n\n## Notes\n\n- These rules are specifically tailored for Solidity + Foundry projects\n- Rules marked with `alwaysApply: true` are enforced automatically\n- Security guidelines are critical - always review security implications\n- The \"no-hiding\" rule is critical - all compiler warnings and linter errors must be resolved\n- When rules conflict, refer to `conflict-resolution.mdc` for guidance\n- Gas optimization is important but never at the expense of security\n\n",
      "guides": [
        {
          "id": "code-review",
          "title": "Code Review",
          "fileName": "code-review.mdc",
          "frontmatter": {
            "description": "Code review checklist and best practices for Solidity Foundry projects",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Code Review Guidelines\n\n## Review Philosophy\n\nCode review for smart contracts is critical due to the immutable nature of deployed contracts. Focus on:\n1. **Security** - Preventing vulnerabilities and exploits\n2. **Gas Efficiency** - Optimizing gas usage\n3. **Code Quality** - Ensuring code meets standards\n4. **Correctness** - Verifying logic and edge cases\n5. **Maintainability** - Ensuring code is readable and maintainable\n\n## Review Checklist\n\n### Security (CRITICAL)\n\n- [ ] Are there any reentrancy vulnerabilities?\n- [ ] Is access control properly implemented?\n- [ ] Are inputs validated (zero address, zero amount, etc.)?\n- [ ] Are integer overflows/underflows handled (or using 0.8.0+)?\n- [ ] Are external calls handled safely?\n- [ ] Is the checks-effects-interactions pattern followed?\n- [ ] Are there any front-running vulnerabilities?\n- [ ] Are timestamps used safely (not for exact equality)?\n- [ ] Is randomness properly implemented (not predictable)?\n- [ ] Are there any DoS vulnerabilities (unbounded loops)?\n- [ ] Are events emitted for all important state changes?\n- [ ] Are custom errors used (gas efficient)?\n\n### Functionality\n\n- [ ] Does the code work as intended?\n- [ ] Are edge cases handled (zero values, max values, etc.)?\n- [ ] Are error cases handled properly?\n- [ ] Is the code complete (no TODOs or placeholders)?\n- [ ] Are there any obvious bugs or logic errors?\n- [ ] Are state transitions correct?\n\n### Code Quality\n\n- [ ] Does the code follow style guidelines (`forge fmt`)?\n- [ ] Are variable names descriptive (no abbreviations)?\n- [ ] Is the code readable and maintainable?\n- [ ] Are there any code duplication that should be refactored?\n- [ ] Is contract structure organized properly?\n- [ ] Are imports organized correctly?\n\n### Architecture\n\n- [ ] Does the code follow architectural patterns?\n- [ ] Are interfaces used appropriately?\n- [ ] Is separation of concerns maintained?\n- [ ] Are libraries used for reusable code?\n- [ ] Is the code properly organized (correct file/directory structure)?\n- [ ] Are upgradeability patterns secure (if applicable)?\n\n### Testing\n\n- [ ] Are there adequate tests?\n- [ ] Do tests cover edge cases?\n- [ ] Are fuzz tests included for input validation?\n- [ ] Are invariant tests included (if applicable)?\n- [ ] Do tests follow testing guidelines?\n- [ ] Is test coverage adequate (100% for critical paths)?\n- [ ] Are tests readable and maintainable?\n- [ ] Are attack vectors tested (reentrancy, overflow, etc.)?\n\n### Gas Efficiency\n\n- [ ] Are storage reads cached in loops?\n- [ ] Are structs packed efficiently?\n- [ ] Are immutable variables used where possible?\n- [ ] Are events used instead of storage for logs?\n- [ ] Is calldata used for external function parameters?\n- [ ] Are batch operations implemented where beneficial?\n- [ ] Are unnecessary operations avoided?\n- [ ] Is gas profiling performed?\n\n### Documentation\n\n- [ ] Is NatSpec documentation present for all public/external functions?\n- [ ] Are events documented?\n- [ ] Are custom errors documented?\n- [ ] Are complex algorithms explained?\n- [ ] Are security considerations documented?\n- [ ] Is the code self-documenting (clear variable names)?\n\n### Error Handling\n\n- [ ] Are custom errors used (gas efficient)?\n- [ ] Are error messages clear and informative?\n- [ ] Are errors handled appropriately?\n- [ ] Are require statements used correctly?\n\n## Review Process\n\n### For Authors\n\n1. **Self-Review First**\n   - Review your own code before requesting review\n   - Run `forge build` and `forge test`\n   - Check for compiler warnings\n   - Review security considerations\n   - Check gas usage\n\n2. **Prepare PR**\n   - Write clear PR description\n   - Reference related issues\n   - Include security considerations\n   - Add gas impact if optimizing\n   - Keep PRs focused and small\n\n3. **Respond to Feedback**\n   - Be open to feedback, especially security concerns\n   - Ask questions if unclear\n   - Make requested changes promptly\n   - Explain your reasoning if you disagree\n\n### For Reviewers\n\n1. **Security First**\n   - Prioritize security vulnerabilities\n   - Look for common attack vectors\n   - Consider edge cases\n   - Think like an attacker\n\n2. **Be Constructive**\n   - Provide specific, actionable feedback\n   - Explain the \"why\" behind suggestions\n   - Acknowledge good code\n   - Be respectful and professional\n\n3. **Review Promptly**\n   - Review within 24 hours if possible\n   - Don't let PRs sit for days\n   - Communicate if you need more time\n   - Security fixes should be reviewed immediately\n\n## Common Review Comments\n\n### Security Issues\n\n```solidity\n// ‚ùå ISSUE - Reentrancy vulnerability\nfunction withdraw() external {\n    (bool success, ) = msg.sender.call{value: balances[msg.sender]}(\"\");\n    require(success, \"Transfer failed\");\n    balances[msg.sender] = 0;  // State update after external call\n}\n\n// Comment: \"This is vulnerable to reentrancy. Use checks-effects-interactions pattern.\"\n\n// ‚úÖ SUGGESTION\nfunction withdraw() external nonReentrant {\n    uint256 amount = balances[msg.sender];\n    balances[msg.sender] = 0;  // Effects first\n    (bool success, ) = msg.sender.call{value: amount}(\"\");  // Interactions last\n    require(success, \"Transfer failed\");\n}\n```\n\n### Gas Optimization\n\n```solidity\n// ‚ùå ISSUE - Multiple storage reads in loop\nfunction processUsers() external {\n    for (uint256 i = 0; i < users.length; i++) {\n        balances[users[i]] += 1;  // Storage read + write per iteration\n    }\n}\n\n// Comment: \"Cache storage reads outside the loop to save gas.\"\n\n// ‚úÖ SUGGESTION\nfunction processUsers() external {\n    uint256 userCount = users.length;\n    for (uint256 i = 0; i < userCount; i++) {\n        address user = users[i];\n        balances[user] += 1;\n    }\n}\n```\n\n### Code Quality\n\n```solidity\n// ‚ùå ISSUE - Abbreviated variable names\nfunction transfer(address to, uint256 amt) external {\n    uint256 bal = balances[msg.sender];\n    // ...\n}\n\n// Comment: \"Please use full descriptive names: 'amount' instead of 'amt', 'balance' instead of 'bal'.\"\n\n// ‚úÖ SUGGESTION\nfunction transfer(address recipient, uint256 amount) external {\n    uint256 senderBalance = balances[msg.sender];\n    // ...\n}\n```\n\n### Documentation\n\n```solidity\n// ‚ùå ISSUE - Missing NatSpec\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n\n// Comment: \"Please add NatSpec documentation for this public function.\"\n\n// ‚úÖ SUGGESTION\n/// @notice Transfers tokens to the specified recipient\n/// @param to The address to transfer tokens to\n/// @param amount The amount of tokens to transfer\n/// @return success Returns true if transfer was successful\nfunction transfer(address to, uint256 amount) external returns (bool success) {\n    // ...\n}\n```\n\n## Security Review Focus Areas\n\n### 1. Reentrancy\n\n- Check all external calls\n- Verify checks-effects-interactions pattern\n- Look for state updates after external calls\n\n### 2. Access Control\n\n- Verify only authorized addresses can call functions\n- Check for missing access control modifiers\n- Verify ownership transfer logic\n\n### 3. Integer Overflow/Underflow\n\n- Check arithmetic operations\n- Verify using Solidity 0.8.0+ or SafeMath\n- Look for unchecked blocks\n\n### 4. Input Validation\n\n- Check for zero address validation\n- Verify zero amount checks\n- Look for bounds checking\n\n### 5. External Calls\n\n- Verify return values are checked\n- Check for proper error handling\n- Look for call vs transfer vs send usage\n\n## Gas Review Focus Areas\n\n### 1. Storage Operations\n\n- Check for unnecessary storage writes\n- Verify storage reads are cached\n- Look for struct packing opportunities\n\n### 2. Loops\n\n- Check for unbounded loops\n- Verify loop optimizations\n- Look for batch operations\n\n### 3. External Calls\n\n- Check for unnecessary external calls\n- Verify batch operations are used\n- Look for gas-efficient patterns\n\n## Testing Review\n\n### Test Coverage\n\n- Verify all public/external functions are tested\n- Check edge cases are covered\n- Verify error conditions are tested\n\n### Fuzz Testing\n\n- Check for fuzz tests on input validation\n- Verify fuzz tests cover edge cases\n- Look for comprehensive fuzz test coverage\n\n### Attack Vector Testing\n\n- Verify reentrancy attacks are tested\n- Check overflow/underflow tests\n- Verify access control tests\n\n## Approval Criteria\n\nA PR should be approved when:\n\n1. ‚úÖ All security concerns are addressed\n2. ‚úÖ All tests pass\n3. ‚úÖ Code follows style guidelines\n4. ‚úÖ NatSpec documentation is complete\n5. ‚úÖ Gas optimizations are reasonable\n6. ‚úÖ No compiler warnings\n7. ‚úÖ Edge cases are handled\n8. ‚úÖ Code is maintainable\n\n## Remember\n\n- **Security First** - Security is the highest priority\n- **Be Thorough** - Smart contracts are immutable\n- **Think Like an Attacker** - Consider attack vectors\n- **Gas Matters** - But not at expense of security\n- **Document Everything** - NatSpec for all public functions\n- **Test Comprehensively** - Cover all edge cases and attacks\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "code-style-guidelines",
          "title": "Code Style Guidelines",
          "fileName": "code-style-guidelines.mdc",
          "frontmatter": {
            "description": "Comprehensive code style guide for Solidity following Style Guide and modern best practices",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Code Style Guidelines\n\nYou MUST follow these coding guidelines when adding ANY code to the codebase.\n\n## 1. Code Formatting\n\n### Solidity Style Guide\n\nFollow the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html) for formatting conventions.\n\n### Indentation\n\n- **Spaces:** 4 spaces (never tabs)\n- **Consistent:** Use same indentation throughout\n\n```solidity\n// ‚úÖ GOOD - 4 spaces\ncontract MyContract {\n    function myFunction() external {\n        if (condition) {\n            doSomething();\n        }\n    }\n}\n\n// ‚ùå BAD - Tabs or inconsistent spacing\ncontract MyContract {\n\tfunction myFunction() external {\n\t\tif (condition) {\n\t\t\tdoSomething();\n\t\t}\n\t}\n}\n```\n\n### Line Length\n\n- **Maximum:** 120 characters (recommended)\n- **Exceptions:** Long strings, import statements\n\n```solidity\n// ‚úÖ GOOD - Within limit\nfunction transfer(address to, uint256 amount) external returns (bool) {\n    // ...\n}\n\n// ‚úÖ GOOD - Break long lines\nfunction complexFunction(\n    address recipient,\n    uint256 amount,\n    bytes calldata data\n) external returns (bool) {\n    // ...\n}\n```\n\n## 2. Naming Conventions\n\n### Contracts and Libraries\n\n- **Style:** `PascalCase`\n- **Descriptive:** Use full, descriptive names\n\n```solidity\n// ‚úÖ GOOD\ncontract TokenVesting {\n    // ...\n}\n\nlibrary SafeMath {\n    // ...\n}\n\n// ‚ùå BAD - Abbreviated\ncontract TV {\n    // ...\n}\n\n// ‚ùå BAD - Single letter\ncontract T {\n    // ...\n}\n```\n\n### Functions and Variables\n\n- **Style:** `camelCase`\n- **NEVER abbreviate variables** - Always use full, descriptive names\n- Single-letter variables are forbidden except for standard mathematical conventions (e.g., `i`, `j` in loops, `x`, `y` in mathematical contexts)\n\n```solidity\n// ‚ùå BAD - Abbreviated variables\nfunction transfer(address to, uint256 amt) external {\n    uint256 bal = balanceOf[msg.sender];\n    // ...\n}\n\n// ‚úÖ GOOD - Full descriptive names\nfunction transfer(address recipient, uint256 amount) external {\n    uint256 senderBalance = balanceOf[msg.sender];\n    // ...\n}\n\n// ‚ùå BAD - Single letter (except math/loops)\nfunction process(uint256 x) external {\n    uint256 y = x * 2;\n    // ...\n}\n\n// ‚úÖ GOOD - Descriptive names\nfunction process(uint256 inputValue) external {\n    uint256 doubledValue = inputValue * 2;\n    // ...\n}\n\n// ‚úÖ ACCEPTABLE - Loop indices\nfor (uint256 i = 0; i < array.length; i++) {\n    // ...\n}\n```\n\n### Constants\n\n- **Style:** `UPPER_SNAKE_CASE`\n\n```solidity\n// ‚úÖ GOOD\nuint256 public constant MAX_SUPPLY = 1_000_000_000;\nuint256 public constant DECIMALS = 18;\naddress public constant TREASURY = 0x1234...;\n\n// ‚ùå BAD\nuint256 public constant maxSupply = 1_000_000_000;\n```\n\n### Events\n\n- **Style:** `PascalCase` with past tense\n\n```solidity\n// ‚úÖ GOOD\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n// ‚ùå BAD\nevent transfer(address from, address to, uint256 value);\n```\n\n### Custom Errors\n\n- **Style:** `PascalCase`\n\n```solidity\n// ‚úÖ GOOD\nerror InsufficientBalance(uint256 required, uint256 available);\nerror Unauthorized(address account);\nerror InvalidAddress(address provided);\n\n// ‚ùå BAD\nerror insufficientBalance(uint256 required, uint256 available);\n```\n\n## 3. Contract Structure Order\n\nFollow this order for contract elements:\n\n1. **SPDX License Identifier**\n2. **Pragma**\n3. **Imports**\n4. **Interfaces**\n5. **Libraries**\n6. **Errors**\n7. **Events**\n8. **Structs**\n9. **Enums**\n10. **Constants**\n11. **State Variables**\n12. **Modifiers**\n13. **Constructor**\n14. **Receive Function** (if payable)\n15. **Fallback Function** (if exists)\n16. **External Functions**\n17. **Public Functions**\n18. **Internal Functions**\n19. **Private Functions**\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMyInterface {\n    // ...\n}\n\nlibrary MyLibrary {\n    // ...\n}\n\nerror InsufficientBalance(uint256 required, uint256 available);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nstruct UserData {\n    uint256 balance;\n    uint256 timestamp;\n}\n\nenum Status { Active, Inactive, Paused }\n\ncontract MyContract {\n    // Constants\n    uint256 public constant MAX_SUPPLY = 1_000_000_000;\n    \n    // State Variables\n    mapping(address => uint256) public balances;\n    \n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    // Constructor\n    constructor() {\n        // ...\n    }\n    \n    // External Functions\n    function externalFunction() external {\n        // ...\n    }\n    \n    // Public Functions\n    function publicFunction() public {\n        // ...\n    }\n    \n    // Internal Functions\n    function internalFunction() internal {\n        // ...\n    }\n    \n    // Private Functions\n    function privateFunction() private {\n        // ...\n    }\n}\n```\n\n## 4. Spacing\n\n### Operators\n\n```solidity\n// ‚úÖ GOOD - Spaces around operators\nuint256 result = a + b;\nbool isEqual = x == y;\n\n// ‚ùå BAD - No spaces\nuint256 result = a+b;\nbool isEqual = x==y;\n```\n\n### Function Parameters\n\n```solidity\n// ‚úÖ GOOD - Space after comma\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - No space after comma\nfunction transfer(address to,uint256 amount) external {\n    // ...\n}\n```\n\n### Braces\n\n```solidity\n// ‚úÖ GOOD - Opening brace on same line\nfunction myFunction() external {\n    // ...\n}\n\n// ‚úÖ ACCEPTABLE - Opening brace on new line (if team prefers)\nfunction myFunction() external\n{\n    // ...\n}\n```\n\n## 5. Imports\n\n### Import Order\n\n1. External dependencies (OpenZeppelin, etc.)\n2. Internal interfaces\n3. Internal libraries\n4. Internal contracts\n\n```solidity\n// External dependencies\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Internal interfaces\nimport \"./interfaces/IMyInterface.sol\";\n\n// Internal libraries\nimport \"./libraries/MyLibrary.sol\";\n\n// Internal contracts\nimport \"./BaseContract.sol\";\n```\n\n### Import Style\n\n```solidity\n// ‚úÖ GOOD - Specific imports\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// ‚ùå BAD - Wildcard imports (unless necessary)\nimport \"@openzeppelin/contracts/token/ERC20/*\";\n```\n\n## 6. Functions\n\n### Function Visibility\n\nAlways specify visibility explicitly:\n\n```solidity\n// ‚úÖ GOOD - Explicit visibility\nfunction publicFunction() public {\n    // ...\n}\n\nfunction externalFunction() external {\n    // ...\n}\n\nfunction internalFunction() internal {\n    // ...\n}\n\nfunction privateFunction() private {\n    // ...\n}\n\n// ‚ùå BAD - Missing visibility (defaults to public)\nfunction myFunction() {\n    // ...\n}\n```\n\n### Function Ordering\n\nOrder functions by visibility: external, public, internal, private\n\n```solidity\ncontract MyContract {\n    // External\n    function externalFunction() external {\n        // ...\n    }\n    \n    // Public\n    function publicFunction() public {\n        // ...\n    }\n    \n    // Internal\n    function internalFunction() internal {\n        // ...\n    }\n    \n    // Private\n    function privateFunction() private {\n        // ...\n    }\n}\n```\n\n### Function Parameters\n\n```solidity\n// ‚úÖ GOOD - Descriptive parameter names\nfunction transfer(address recipient, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - Abbreviated or single-letter parameters\nfunction transfer(address to, uint256 amt) external {\n    // ...\n}\n\n// ‚úÖ GOOD - Use calldata for external functions (gas efficient)\nfunction processData(bytes calldata data) external {\n    // ...\n}\n\n// ‚úÖ GOOD - Use memory for internal functions\nfunction processDataInternal(bytes memory data) internal {\n    // ...\n}\n```\n\n## 7. Variables\n\n### State Variables\n\n```solidity\n// ‚úÖ GOOD - Descriptive names, explicit visibility\nmapping(address => uint256) public balances;\nuint256 private totalSupply;\naddress public immutable owner;\n\n// ‚ùå BAD - Abbreviated names\nmapping(address => uint256) public bal;\nuint256 private ts;\n```\n\n### Local Variables\n\n```solidity\n// ‚úÖ GOOD - Descriptive names\nfunction calculateTotal(uint256[] memory amounts) external pure returns (uint256) {\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < amounts.length; i++) {\n        totalAmount += amounts[i];\n    }\n    return totalAmount;\n}\n\n// ‚ùå BAD - Abbreviated names\nfunction calculateTotal(uint256[] memory amts) external pure returns (uint256) {\n    uint256 tot = 0;\n    for (uint256 i = 0; i < amts.length; i++) {\n        tot += amts[i];\n    }\n    return tot;\n}\n```\n\n### Storage vs Memory\n\n```solidity\n// ‚úÖ GOOD - Use memory for temporary data\nfunction processArray(uint256[] memory data) external {\n    uint256[] memory processed = new uint256[](data.length);\n    // ...\n}\n\n// ‚úÖ GOOD - Use storage for persistent data\nfunction updateStorage() external {\n    balances[msg.sender] = 100;\n}\n\n// ‚ùå BAD - Unnecessary storage reads in loops\nfunction badExample() external {\n    for (uint256 i = 0; i < users.length; i++) {\n        uint256 balance = balances[users[i]];  // Storage read in loop\n        // ...\n    }\n}\n\n// ‚úÖ GOOD - Cache storage reads\nfunction goodExample() external {\n    uint256 userBalance = balances[msg.sender];  // Cache outside loop\n    for (uint256 i = 0; i < users.length; i++) {\n        // Use cached value\n    }\n}\n```\n\n## 8. Comments\n\n### Single-Line Comments\n\n```solidity\n// ‚úÖ GOOD - Single-line comments\n// This function transfers tokens to a recipient\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - Obvious comments\n// Increment counter\ncounter++;\n```\n\n### Multi-Line Comments\n\n```solidity\n// ‚úÖ GOOD - Multi-line comments for complex logic\n/*\n * This function implements a complex algorithm:\n * 1. First step\n * 2. Second step\n * 3. Final step\n */\nfunction complexFunction() external {\n    // ...\n}\n```\n\n### NatSpec Comments\n\nSee `commenting-guidelines.mdc` for comprehensive NatSpec standards.\n\n## 9. Numbers\n\n### Use Underscores for Readability\n\n```solidity\n// ‚úÖ GOOD - Underscores for large numbers\nuint256 public constant MAX_SUPPLY = 1_000_000_000;\nuint256 public constant PRICE = 0.001 ether;\n\n// ‚ùå BAD - Hard to read\nuint256 public constant MAX_SUPPLY = 1000000000;\n```\n\n### Hexadecimal\n\n```solidity\n// ‚úÖ GOOD - Lowercase hex\naddress public constant TREASURY = 0x1234567890123456789012345678901234567890;\n\n// ‚úÖ ACCEPTABLE - Uppercase hex (if consistent)\naddress public constant TREASURY = 0x1234567890123456789012345678901234567890;\n```\n\n## 10. Strings\n\n### String Literals\n\n```solidity\n// ‚úÖ GOOD - Double quotes\nstring memory message = \"Hello, World!\";\n\n// ‚ùå BAD - Single quotes (not valid in Solidity)\nstring memory message = 'Hello, World!';\n```\n\n## 11. Arrays\n\n### Array Declarations\n\n```solidity\n// ‚úÖ GOOD - Clear array declarations\nuint256[] public balances;\naddress[] private whitelist;\nuint256[10] public fixedArray;\n\n// ‚ùå BAD - Unclear\nuint256[]bal;\naddress[]wl;\n```\n\n## 12. Mappings\n\n### Mapping Declarations\n\n```solidity\n// ‚úÖ GOOD - Clear mapping declarations\nmapping(address => uint256) public balances;\nmapping(address => mapping(address => uint256)) public allowances;\n\n// ‚ùå BAD - Unclear\nmapping(address => uint256)bal;\n```\n\n## 13. Modifiers\n\n### Modifier Definitions\n\n```solidity\n// ‚úÖ GOOD - Descriptive modifier names\nmodifier onlyOwner() {\n    require(msg.sender == owner, \"Not owner\");\n    _;\n}\n\nmodifier nonReentrant() {\n    require(!locked, \"Reentrant call\");\n    locked = true;\n    _;\n    locked = false;\n}\n\n// ‚ùå BAD - Abbreviated names\nmodifier onlyOwn() {\n    // ...\n}\n```\n\n## 14. Events\n\n### Event Definitions\n\n```solidity\n// ‚úÖ GOOD - Indexed parameters for filtering\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n// ‚úÖ GOOD - Emit events for important state changes\nfunction transfer(address to, uint256 amount) external {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n}\n```\n\n## 15. Errors\n\n### Custom Error Definitions\n\n```solidity\n// ‚úÖ GOOD - Descriptive error names with parameters\nerror InsufficientBalance(uint256 required, uint256 available);\nerror Unauthorized(address account);\nerror InvalidAmount(uint256 amount);\n\n// ‚úÖ GOOD - Use custom errors (gas efficient)\nfunction withdraw(uint256 amount) external {\n    if (balances[msg.sender] < amount) {\n        revert InsufficientBalance(amount, balances[msg.sender]);\n    }\n    // ...\n}\n\n// ‚ùå BAD - String require (more gas)\nfunction withdraw(uint256 amount) external {\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    // ...\n}\n```\n\n## 16. Pre-commit Hooks\n\n**Configuration (`.pre-commit-config.yaml`):**\n\n```yaml\nrepos:\n  - repo: https://github.com/pre-commit/mirrors-prettier\n    rev: v3.0.0\n    hooks:\n      - id: prettier\n        files: \\.sol$\n  \n  - repo: local\n    hooks:\n      - id: forge-fmt\n        name: forge fmt\n        entry: forge fmt --check\n        language: system\n        pass_filenames: false\n        always_run: true\n```\n\n## Remember\n\n- **Follow Solidity Style Guide** - Official style guide\n- **Use forge fmt** - Automatic code formatting\n- **Descriptive Names** - Never abbreviate\n- **NatSpec Comments** - Document all public/external functions\n- **4 Space Indentation** - Consistent spacing\n- **120 Char Limit** - Maximum line length\n- **Gas Optimization** - Consider gas costs in style decisions\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "commenting-guidelines",
          "title": "Commenting Guidelines",
          "fileName": "commenting-guidelines.mdc",
          "frontmatter": {
            "description": "Commenting and documentation standards for Solidity smart contracts using NatSpec",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Commenting Guidelines\n\n## Philosophy\n\nComments should explain the **\"why\"** and **\"intent\"**, not the **\"what\"**. The code itself should be self-documenting through clear variable names, function names, and structure. Use NatSpec for all public/external interfaces.\n\n## NatSpec Documentation\n\nNatSpec (Natural Language Specification) is the standard for Solidity documentation. Use NatSpec for all public/external functions, contracts, and state variables.\n\n### NatSpec Tags\n\n- `@title` - Contract title\n- `@author` - Author name\n- `@notice` - User-facing description\n- `@dev` - Developer-facing description\n- `@param` - Parameter description\n- `@return` - Return value description\n- `@custom:` - Custom tags\n- `@inheritdoc` - Inherit documentation\n\n## When to Comment\n\n### ‚úÖ DO Comment\n\n1. **Public/External Functions** - All public/external functions must have NatSpec\n2. **Complex Logic** - Non-obvious algorithms or business rules\n3. **Security Considerations** - Security implications and assumptions\n4. **Gas Optimization** - Why a specific optimization was made\n5. **Business Rules** - Domain-specific logic that isn't obvious\n6. **Interfaces** - All interface functions\n7. **Events** - Important events should be documented\n\n### ‚ùå DON'T Comment\n\n1. **Obvious Code** - Code that is self-explanatory\n2. **Type Duplication** - Don't repeat what types already say\n3. **Implementation Details** - Focus on intent, not how it's done\n4. **Commented-Out Code** - Delete it, don't comment it out\n5. **Version Control Info** - Don't include git history\n\n## Contract Documentation\n\n### Contract-Level NatSpec\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Token Contract\n/// @author Your Name\n/// @notice ERC20 token implementation with minting and burning capabilities\n/// @dev This contract implements the ERC20 standard with additional features\ncontract Token {\n    // ...\n}\n```\n\n### Multi-Line NatSpec\n\n```solidity\n/**\n * @title Token Contract\n * @author Your Name\n * @notice ERC20 token implementation with minting and burning capabilities\n * @dev This contract implements the ERC20 standard with additional features\n *      including role-based access control and pausable functionality\n */\ncontract Token {\n    // ...\n}\n```\n\n## Function Documentation\n\n### Public/External Functions\n\nAll public/external functions must have NatSpec:\n\n```solidity\n/// @notice Transfers tokens from the caller's account to the specified recipient\n/// @dev This function implements the ERC20 transfer function with additional\n///      checks for paused state and zero address validation\n/// @param to The address to transfer tokens to\n/// @param amount The amount of tokens to transfer\n/// @return success Returns true if the transfer was successful\n/// @custom:security This function is protected by the nonReentrant modifier\nfunction transfer(address to, uint256 amount) external returns (bool success) {\n    // Implementation\n}\n```\n\n### Internal/Private Functions\n\nDocument complex internal/private functions:\n\n```solidity\n/// @dev Internal function to update balances after transfer\n/// @param from The address to transfer from\n/// @param to The address to transfer to\n/// @param amount The amount to transfer\nfunction _transfer(address from, address to, uint256 amount) internal {\n    // Implementation\n}\n```\n\n### Function Examples\n\n```solidity\n/// @notice Mints new tokens to the specified address\n/// @dev Only callable by addresses with the MINTER_ROLE\n/// @param to The address to mint tokens to\n/// @param amount The amount of tokens to mint\n/// @custom:example\n///     ```solidity\n///     token.mint(0x123..., 1000);\n///     // Mints 1000 tokens to address 0x123...\n///     ```\nfunction mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n    // Implementation\n}\n```\n\n## Parameter Documentation\n\n### @param Tag\n\n```solidity\n/// @notice Transfers tokens between addresses\n/// @param from The address to transfer tokens from\n/// @param to The address to transfer tokens to\n/// @param amount The amount of tokens to transfer (must be > 0)\nfunction transferFrom(address from, address to, uint256 amount) external {\n    // Implementation\n}\n```\n\n### Multiple Parameters\n\n```solidity\n/// @notice Approves spender to transfer tokens on behalf of owner\n/// @param owner The address that owns the tokens\n/// @param spender The address that will be approved to spend tokens\n/// @param amount The amount of tokens to approve (use type(uint256).max for unlimited)\n/// @return success Returns true if approval was successful\nfunction approve(address owner, address spender, uint256 amount) external returns (bool success) {\n    // Implementation\n}\n```\n\n## Return Value Documentation\n\n### @return Tag\n\n```solidity\n/// @notice Gets the balance of the specified address\n/// @param account The address to query the balance for\n/// @return balance The balance of the specified address\nfunction balanceOf(address account) external view returns (uint256 balance) {\n    return balances[account];\n}\n```\n\n### Multiple Return Values\n\n```solidity\n/// @notice Gets token information\n/// @return name The name of the token\n/// @return symbol The symbol of the token\n/// @return decimals The number of decimals\n/// @return totalSupply The total supply of tokens\nfunction getTokenInfo() external view returns (\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    uint256 totalSupply\n) {\n    return (name(), symbol(), decimals(), totalSupply());\n}\n```\n\n## Event Documentation\n\n### Event NatSpec\n\n```solidity\n/// @notice Emitted when tokens are transferred\n/// @param from The address tokens are transferred from (address(0) for minting)\n/// @param to The address tokens are transferred to (address(0) for burning)\n/// @param value The amount of tokens transferred\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n/// @notice Emitted when approval is set\n/// @param owner The address that approved the spending\n/// @param spender The address that was approved to spend\n/// @param value The amount of tokens approved\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n```\n\n## Error Documentation\n\n### Custom Error Documentation\n\n```solidity\n/// @notice Thrown when transfer amount exceeds available balance\n/// @param required The amount required for the operation\n/// @param available The amount currently available\nerror InsufficientBalance(uint256 required, uint256 available);\n\n/// @notice Thrown when an unauthorized address attempts an operation\n/// @param account The address that attempted the unauthorized operation\nerror Unauthorized(address account);\n```\n\n## State Variable Documentation\n\n### Public State Variables\n\n```solidity\n/// @notice The total supply of tokens\n/// @dev This value is updated when tokens are minted or burned\nuint256 public totalSupply;\n\n/// @notice Mapping of account balances\n/// @dev Maps account address to their token balance\nmapping(address => uint256) public balances;\n\n/// @notice The owner of the contract\n/// @dev Set in constructor and can be transferred via transferOwnership\naddress public immutable owner;\n```\n\n## Inline Comments\n\n### When to Use Inline Comments\n\n```solidity\n// ‚úÖ GOOD - Explains why, not what\n// Use unchecked here because i < length, so i++ cannot overflow\nunchecked {\n    i++;\n}\n\n// ‚úÖ GOOD - Explains security consideration\n// Check-effects-interactions pattern: update state before external call\nbalances[msg.sender] -= amount;\nbalances[to] += amount;\n(bool success, ) = to.call{value: amount}(\"\");\n\n// ‚úÖ GOOD - Explains business rule\n// Users created before 2020 are grandfathered into old fee structure\nif (userTimestamp < 1577836800) {  // Jan 1, 2020\n    fee = 0;\n}\n\n// ‚úÖ GOOD - Explains gas optimization\n// Cache storage read to avoid multiple SLOAD operations in loop\nuint256 cachedBalance = balances[msg.sender];\n\n// ‚ùå BAD - Obvious comment\n// Increment counter\ncounter++;\n\n// ‚ùå BAD - Commented-out code\n// function oldFunction() external {\n//     // old implementation\n// }\n```\n\n## Modifier Documentation\n\n### Modifier NatSpec\n\n```solidity\n/// @notice Modifier that restricts function access to the contract owner\n/// @dev Reverts with Unauthorized error if caller is not the owner\nmodifier onlyOwner() {\n    if (msg.sender != owner) {\n        revert Unauthorized(msg.sender);\n    }\n    _;\n}\n\n/// @notice Modifier that prevents reentrancy attacks\n/// @dev Uses a lock flag to prevent recursive calls\nmodifier nonReentrant() {\n    require(!locked, \"Reentrant call\");\n    locked = true;\n    _;\n    locked = false;\n}\n```\n\n## Library Documentation\n\n### Library NatSpec\n\n```solidity\n/// @title Math Library\n/// @notice Library for mathematical operations\n/// @dev Provides safe arithmetic operations\nlibrary Math {\n    /// @notice Returns the maximum of two numbers\n    /// @param a First number\n    /// @param b Second number\n    /// @return The maximum of a and b\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n```\n\n## Interface Documentation\n\n### Interface NatSpec\n\n```solidity\n/// @title ERC20 Token Interface\n/// @notice Standard interface for ERC20 tokens\ninterface IERC20 {\n    /// @notice Returns the total supply of tokens\n    /// @return The total supply\n    function totalSupply() external view returns (uint256);\n    \n    /// @notice Returns the balance of an account\n    /// @param account The address to query\n    /// @return The balance of the account\n    function balanceOf(address account) external view returns (uint256);\n    \n    /// @notice Transfers tokens to a recipient\n    /// @param to The recipient address\n    /// @param amount The amount to transfer\n    /// @return success True if transfer was successful\n    function transfer(address to, uint256 amount) external returns (bool success);\n}\n```\n\n## Security Documentation\n\n### Security Considerations\n\n```solidity\n/// @notice Withdraws tokens from the contract\n/// @dev Implements checks-effects-interactions pattern to prevent reentrancy\n/// @param amount The amount to withdraw\n/// @custom:security This function is protected by nonReentrant modifier\n/// @custom:security Uses checks-effects-interactions pattern\nfunction withdraw(uint256 amount) external nonReentrant {\n    // Checks\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    \n    // Effects\n    balances[msg.sender] -= amount;\n    \n    // Interactions\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n}\n```\n\n## Best Practices\n\n### 1. Be Concise but Complete\n\n```solidity\n// ‚úÖ GOOD - Concise but complete\n/// @notice Transfers tokens to recipient\n/// @param to Recipient address\n/// @param amount Amount to transfer\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - Too verbose\n/// @notice This function transfers tokens from the caller's account to the\n///         specified recipient address. It checks that the caller has\n///         sufficient balance and that the recipient is not the zero address.\n///         It then updates the balances and emits a Transfer event.\n/// @param to This is the address that will receive the tokens\n/// @param amount This is the number of tokens to transfer\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n```\n\n### 2. Use @dev for Implementation Details\n\n```solidity\n/// @notice Gets user balance\n/// @dev This function reads from storage, consider caching in loops\n/// @param user The user address\n/// @return The user's balance\nfunction getBalance(address user) external view returns (uint256) {\n    return balances[user];\n}\n```\n\n### 3. Document Edge Cases\n\n```solidity\n/// @notice Transfers tokens to recipient\n/// @param to Recipient address (must not be zero address)\n/// @param amount Amount to transfer (must be > 0)\n/// @dev Reverts if recipient is zero address or amount is zero\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n```\n\n## Remember\n\n- **NatSpec Required** - All public/external functions must have NatSpec\n- **Explain Why** - Focus on intent, not implementation\n- **Be Concise** - Don't repeat what code already says\n- **Security Notes** - Document security considerations\n- **Examples** - Include examples for complex functions\n- **Keep Updated** - Update docs when code changes\n- **No Commented Code** - Delete, don't comment out\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "conflict-resolution",
          "title": "Conflict Resolution",
          "fileName": "conflict-resolution.mdc",
          "frontmatter": {
            "description": "Guidance for resolving rule conflicts and handling exceptions in Solidity Foundry projects",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Conflict Resolution\n\n## Overview\n\nWhen coding guidelines conflict or when exceptions are needed, this document provides guidance on how to resolve conflicts and document exceptions. In smart contract development, security always takes precedence.\n\n## Priority Hierarchy\n\nWhen rules conflict, follow this priority order:\n\n1. **Security Guidelines** - Security always takes precedence over everything\n2. **No Hiding Rule** - Never suppress compiler warnings or errors\n3. **Core Framework & Language** - Solidity and Foundry requirements\n4. **Error Handling Patterns** - Consistent error handling\n5. **Code Style Guidelines** - Formatting and style\n6. **Performance Guidelines** - Gas optimization considerations\n7. **Commenting Guidelines** - Documentation standards\n\n## Common Conflict Scenarios\n\n### Scenario 1: Security vs Gas Optimization\n\n**Conflict:** Security pattern requires more gas than optimized version\n\n**Resolution:**\n- Security always wins\n- Optimize gas in other ways if possible\n- Document why security takes precedence\n\n**Example:**\n\n```solidity\n// Security requires checks-effects-interactions pattern\n// Gas optimization might suggest different order\n// Resolution: Security first, optimize elsewhere\n\n// ‚úÖ GOOD - Secure first, optimize elsewhere\nfunction withdraw() external nonReentrant {\n    uint256 amount = balances[msg.sender];  // Check\n    balances[msg.sender] = 0;  // Effects (state update first)\n    (bool success, ) = msg.sender.call{value: amount}(\"\");  // Interactions (external call last)\n    require(success, \"Transfer failed\");\n}\n\n// ‚ùå BAD - Gas optimization at expense of security\nfunction withdraw() external {\n    // External call before state update - vulnerable to reentrancy\n    (bool success, ) = msg.sender.call{value: balances[msg.sender]}(\"\");\n    balances[msg.sender] = 0;\n}\n```\n\n### Scenario 2: Gas Optimization vs Readability\n\n**Conflict:** Gas optimization makes code less readable\n\n**Resolution:**\n- Optimize when there's measurable gas savings\n- Add comments explaining the optimization\n- Consider if optimization is necessary\n\n**Example:**\n\n```solidity\n// Gas optimization requires complex code\n// Readability prefers simpler code\n// Resolution: Optimize, but document why\n\n// ‚úÖ GOOD - Optimized with explanation\n// Cache storage read to avoid multiple SLOAD operations (saves ~2100 gas per read)\nuint256 cachedBalance = balances[msg.sender];\nfor (uint256 i = 0; i < users.length; i++) {\n    // Use cached value instead of reading from storage\n    processUser(users[i], cachedBalance);\n}\n\n// ‚ùå BAD - Readable but inefficient\nfor (uint256 i = 0; i < users.length; i++) {\n    // Reading from storage in each iteration (expensive)\n    processUser(users[i], balances[msg.sender]);\n}\n```\n\n### Scenario 3: Code Style vs Gas Optimization\n\n**Conflict:** Style guide suggests one approach, gas optimization suggests another\n\n**Resolution:**\n- Prefer gas optimization for measurable savings\n- Document the deviation from style guide\n- Consider readability impact\n\n**Example:**\n\n```solidity\n// Style guide suggests descriptive names\n// Gas optimization suggests shorter names (minimal impact)\n// Resolution: Follow style guide (gas impact is minimal)\n\n// ‚úÖ GOOD - Descriptive names (style guide)\nfunction transfer(address recipient, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - Abbreviated names (not worth gas savings)\nfunction transfer(address to, uint256 amt) external {\n    // ...\n}\n```\n\n### Scenario 4: Documentation vs Gas\n\n**Conflict:** NatSpec documentation adds to bytecode size\n\n**Resolution:**\n- Documentation is required (doesn't affect runtime gas)\n- Bytecode size is less important than documentation\n- Document all public/external functions\n\n**Example:**\n\n```solidity\n// NatSpec adds to bytecode size\n// But documentation is required\n// Resolution: Always document\n\n// ‚úÖ GOOD - Documented (required)\n/// @notice Transfers tokens to recipient\n/// @param to Recipient address\n/// @param amount Amount to transfer\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n\n// ‚ùå BAD - No documentation (not acceptable)\nfunction transfer(address to, uint256 amount) external {\n    // ...\n}\n```\n\n### Scenario 5: Testing vs Development Speed\n\n**Conflict:** Comprehensive testing slows development\n\n**Resolution:**\n- Testing is critical for smart contracts\n- Don't skip tests for speed\n- Write tests alongside code\n\n**Example:**\n\n```solidity\n// Comprehensive testing takes time\n// But is essential for smart contracts\n// Resolution: Always test thoroughly\n\n// ‚úÖ GOOD - Comprehensive tests\nfunction test_Transfer_RevertsOnInsufficientBalance() public {\n    // Test edge case\n}\n\nfunction testFuzz_Transfer(uint256 amount) public {\n    // Fuzz test\n}\n\n// ‚ùå BAD - Skipping tests for speed\n// No tests - not acceptable\n```\n\n## Exception Documentation\n\nWhen deviating from guidelines, document the exception:\n\n```solidity\n// Exception: Gas optimization requires unchecked block\n// Rationale: i < length, so i++ cannot overflow (saves ~30 gas per iteration)\n// Risk: Low - overflow is impossible given loop condition\nunchecked {\n    i++;\n}\n```\n\n## Decision Process\n\nWhen facing a conflict:\n\n1. **Identify the Conflict**\n   - Which guidelines conflict?\n   - What are the trade-offs?\n\n2. **Apply Priority Hierarchy**\n   - Security first\n   - Then correctness\n   - Then optimization\n   - Then style\n\n3. **Document the Decision**\n   - Why was this approach chosen?\n   - What are the trade-offs?\n   - Are there alternatives?\n\n4. **Review with Team**\n   - Discuss significant conflicts\n   - Get consensus on approach\n   - Update guidelines if needed\n\n## Common Resolutions\n\n### Security vs Everything\n\n**Resolution:** Security always wins\n\n```solidity\n// Security requires nonReentrant modifier\n// Gas optimization might suggest removing it\n// Resolution: Keep modifier, optimize elsewhere\n```\n\n### Gas vs Readability\n\n**Resolution:** Optimize when measurable, document why\n\n```solidity\n// Gas optimization requires complex code\n// Resolution: Optimize with comments explaining why\n```\n\n### Style vs Convention\n\n**Resolution:** Follow project conventions, document exceptions\n\n```solidity\n// Style guide suggests one approach\n// Project convention uses another\n// Resolution: Follow project convention, document if needed\n```\n\n## Remember\n\n- **Security First** - Never compromise security\n- **Document Exceptions** - Explain why guidelines aren't followed\n- **Review Conflicts** - Discuss significant conflicts with team\n- **Update Guidelines** - If patterns emerge, update guidelines\n- **Consistency Matters** - Be consistent within project\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "core-framework-language",
          "title": "Core Framework & Language",
          "fileName": "core-framework-&-language.mdc",
          "frontmatter": {
            "description": "Core framework, language, and runtime specifications for Solidity Foundry projects",
            "globs": [
              "**/*.sol",
              "**/foundry.toml",
              "**/script/**",
              "**/test/**"
            ],
            "alwaysApply": true
          },
          "content": "# Core Framework & Language\n\n## Overview\n\nThis document defines the foundational technology stack and runtime environment for Solidity smart contract development using Foundry. All code must align with these specifications.\n\n## Language\n\n- **Language:** [Solidity](https://soliditylang.org/) 0.8.20+\n  - Used throughout the codebase for smart contract development\n  - Strict compiler settings enabled\n  - All contracts must use Solidity 0.8.20 or higher\n  - Leverage modern Solidity features (custom errors, unchecked blocks, etc.)\n\n## Framework\n\n- **Framework:** [Foundry](https://book.getfoundry.sh/)\n  - **Forge:** Build, test, and deploy tool\n  - **Cast:** CLI for interacting with EVM chains\n  - **Anvil:** Local Ethereum node\n  - **Chisel:** Solidity REPL\n  - Provides fast compilation, testing, and deployment\n\n## Solidity Version\n\nAlways specify the Solidity version pragma at the top of each contract file:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n```\n\n### Version Requirements\n\n- **Minimum:** 0.8.20\n- **Recommended:** Latest stable version (0.8.x)\n- **Rationale:** 0.8.20+ includes custom errors, improved gas optimization, and security features\n\n## Foundry Configuration\n\n### foundry.toml\n\n```toml\n[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\ntest = \"test\"\nscript = \"script\"\n\n# Solidity compiler settings\nsolc = \"0.8.20\"\noptimizer = true\noptimizer_runs = 200\nvia_ir = false\n\n# Test settings\nfuzz = { runs = 256 }\ninvariant = { runs = 256 }\n\n# Coverage\n[profile.default.coverage]\nexclude = [\"test\", \"script\"]\n\n# Gas reporting\ngas_reports = [\"*\"]\n\n# Remappings\nremappings = [\n    \"@openzeppelin/=lib/openzeppelin-contracts/\",\n    \"@forge-std/=lib/forge-std/src/\",\n]\n```\n\n## Project Structure\n\nStandard Foundry project structure:\n\n```\nproject-root/\n‚îú‚îÄ‚îÄ foundry.toml          # Foundry configuration\n‚îú‚îÄ‚îÄ .gitignore\n‚îú‚îÄ‚îÄ .github/\n‚îÇ   ‚îî‚îÄ‚îÄ workflows/\n‚îÇ       ‚îî‚îÄ‚îÄ ci.yml        # CI/CD workflows\n‚îú‚îÄ‚îÄ script/\n‚îÇ   ‚îî‚îÄ‚îÄ Deploy.s.sol      # Deployment scripts\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ contracts/        # Main contracts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MyContract.sol\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ interfaces/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ IMyContract.sol\n‚îÇ   ‚îú‚îÄ‚îÄ libraries/        # Reusable libraries\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Math.sol\n‚îÇ   ‚îî‚îÄ‚îÄ utils/            # Utility contracts\n‚îÇ       ‚îî‚îÄ‚îÄ Errors.sol\n‚îú‚îÄ‚îÄ test/\n‚îÇ   ‚îú‚îÄ‚îÄ MyContract.t.sol  # Test files\n‚îÇ   ‚îî‚îÄ‚îÄ mocks/            # Mock contracts\n‚îÇ       ‚îî‚îÄ‚îÄ MockERC20.sol\n‚îî‚îÄ‚îÄ lib/                  # Dependencies (git submodules)\n    ‚îú‚îÄ‚îÄ forge-std/\n    ‚îî‚îÄ‚îÄ openzeppelin-contracts/\n```\n\n## Compiler Settings\n\n### Optimization\n\n```toml\noptimizer = true\noptimizer_runs = 200  # Balance between gas and compilation time\nvia_ir = false        # Use IR-based codegen for complex contracts if needed\n```\n\n### Version Pragma\n\nAlways use caret (`^`) for version ranges to allow patch updates:\n\n```solidity\npragma solidity ^0.8.20;  // Allows 0.8.20, 0.8.21, etc., but not 0.9.0\n```\n\n## Core Dependencies\n\nEssential libraries for Solidity development:\n\n### OpenZeppelin Contracts\n\n```bash\nforge install OpenZeppelin/openzeppelin-contracts\n```\n\nCommon imports:\n- `@openzeppelin/contracts/access/Ownable.sol`\n- `@openzeppelin/contracts/token/ERC20/ERC20.sol`\n- `@openzeppelin/contracts/security/ReentrancyGuard.sol`\n- `@openzeppelin/contracts/utils/math/SafeMath.sol` (for <0.8.0)\n\n### Forge Standard Library\n\n```bash\nforge install foundry-rs/forge-std\n```\n\nProvides:\n- `forge-std/Test.sol` - Base test contract\n- `forge-std/Script.sol` - Base script contract\n- `forge-std/console.sol` - Console logging for tests\n\n## Environment Setup\n\n1. **Install Foundry**:\n\n   ```bash\n   curl -L https://foundry.paradigm.xyz | bash\n   foundryup\n   ```\n\n2. **Verify Installation**:\n\n   ```bash\n   forge --version\n   cast --version\n   anvil --version\n   ```\n\n3. **Initialize Project**:\n\n   ```bash\n   forge init my-project\n   cd my-project\n   ```\n\n4. **Install Dependencies**:\n\n   ```bash\n   forge install OpenZeppelin/openzeppelin-contracts\n   forge install foundry-rs/forge-std\n   ```\n\n## Development Workflow\n\n### Compile Contracts\n\n```bash\n# Compile all contracts\nforge build\n\n# Compile specific contract\nforge build --contracts src/MyContract.sol\n```\n\n### Run Tests\n\n```bash\n# Run all tests\nforge test\n\n# Run specific test\nforge test --match-test testFunctionName\n\n# Run with gas reporting\nforge test --gas-report\n\n# Run with verbosity\nforge test -vvv\n\n# Run fuzz tests\nforge test --fuzz-runs 1000\n```\n\n### Run Anvil (Local Node)\n\n```bash\n# Start local node\nanvil\n\n# Start with specific accounts\nanvil --accounts 10\n\n# Fork mainnet\nanvil --fork-url https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY\n```\n\n### Deploy Contracts\n\n```bash\n# Deploy using script\nforge script script/Deploy.s.sol --rpc-url <RPC_URL> --broadcast\n\n# Deploy and verify on Etherscan\nforge script script/Deploy.s.sol --rpc-url <RPC_URL> --broadcast --verify\n```\n\n## Type System\n\nSolidity is statically typed. Key requirements:\n\n- All variables must have explicit types\n- Use `memory` for temporary data, `storage` for persistent data\n- Use `calldata` for function parameters (gas efficient)\n- Avoid `storage` in loops when possible\n\n## Modern Solidity Features\n\n### Custom Errors (0.8.4+)\n\n```solidity\n// ‚úÖ GOOD - Gas efficient\nerror InsufficientBalance(uint256 required, uint256 available);\n\nfunction withdraw(uint256 amount) external {\n    if (balance < amount) {\n        revert InsufficientBalance(amount, balance);\n    }\n    // ...\n}\n```\n\n### Unchecked Blocks (0.8.0+)\n\n```solidity\n// ‚úÖ GOOD - Safe overflow handling\nfunction increment(uint256 x) external pure returns (uint256) {\n    unchecked {\n        return x + 1;  // Safe, won't overflow in practice\n    }\n}\n```\n\n### Immutable Variables\n\n```solidity\n// ‚úÖ GOOD - Gas efficient\ncontract MyContract {\n    address public immutable owner;\n    \n    constructor(address _owner) {\n        owner = _owner;\n    }\n}\n```\n\n## Remember\n\n- **Solidity 0.8.20+** - Use modern Solidity features\n- **Foundry** - Use Forge for building, testing, and deployment\n- **Type Safety** - All variables must be explicitly typed\n- **Gas Optimization** - Consider gas costs in design decisions\n- **Security First** - Security is paramount in smart contracts\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol",
            "**/foundry.toml",
            "**/script/**",
            "**/test/**"
          ]
        },
        {
          "id": "dependency-management",
          "title": "Dependency Management",
          "fileName": "dependency-management.mdc",
          "frontmatter": {
            "description": "Dependency management best practices for Solidity Foundry projects",
            "globs": [
              "**/foundry.toml",
              "**/lib/**"
            ],
            "alwaysApply": true
          },
          "content": "# Dependency Management\n\n## Overview\n\nFoundry uses git submodules for dependency management. This document outlines best practices for managing dependencies in Solidity projects.\n\n## Foundry Dependency System\n\n### Installing Dependencies\n\n```bash\n# Install OpenZeppelin Contracts\nforge install OpenZeppelin/openzeppelin-contracts\n\n# Install Forge Standard Library\nforge install foundry-rs/forge-std\n\n# Install specific version (commit hash)\nforge install OpenZeppelin/openzeppelin-contracts@v4.9.0\n```\n\n### Dependency Location\n\nDependencies are installed in the `lib/` directory as git submodules:\n\n```\nproject-root/\n‚îú‚îÄ‚îÄ lib/\n‚îÇ   ‚îú‚îÄ‚îÄ openzeppelin-contracts/\n‚îÇ   ‚îú‚îÄ‚îÄ forge-std/\n‚îÇ   ‚îî‚îÄ‚îÄ other-dependency/\n‚îú‚îÄ‚îÄ src/\n‚îî‚îÄ‚îÄ foundry.toml\n```\n\n## Remappings\n\n### Configuration\n\nDefine remappings in `foundry.toml`:\n\n```toml\n[profile.default]\nremappings = [\n    \"@openzeppelin/=lib/openzeppelin-contracts/\",\n    \"@forge-std/=lib/forge-std/src/\",\n    \"@chainlink/=lib/chainlink/contracts/src/\",\n]\n```\n\n### Usage in Contracts\n\n```solidity\n// ‚úÖ GOOD - Use remappings\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@forge-std/Test.sol\";\n```\n\n## Version Management\n\n### Pinning Versions\n\n**Always pin dependencies to specific versions:**\n\n```bash\n# Install specific version\nforge install OpenZeppelin/openzeppelin-contracts@v4.9.0\n\n# Or use commit hash for exact version\nforge install OpenZeppelin/openzeppelin-contracts@8b3b8c8\n```\n\n### foundry.toml Configuration\n\n```toml\n[profile.default]\n# Pin Solidity version\nsolc = \"0.8.20\"\n\n# Remappings\nremappings = [\n    \"@openzeppelin/=lib/openzeppelin-contracts/\",\n    \"@forge-std/=lib/forge-std/src/\",\n]\n```\n\n## Common Dependencies\n\n### 1. OpenZeppelin Contracts\n\n**Standard library for secure smart contracts:**\n\n```bash\nforge install OpenZeppelin/openzeppelin-contracts\n```\n\n**Common imports:**\n\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n```\n\n### 2. Forge Standard Library\n\n**Testing and scripting utilities:**\n\n```bash\nforge install foundry-rs/forge-std\n```\n\n**Common imports:**\n\n```solidity\nimport \"@forge-std/Test.sol\";\nimport \"@forge-std/Script.sol\";\nimport \"@forge-std/console.sol\";\n```\n\n### 3. Chainlink Contracts\n\n**For oracle and VRF functionality:**\n\n```bash\nforge install smartcontractkit/chainlink-brownie-contracts\n```\n\n### 4. Solmate\n\n**Gas-optimized alternatives:**\n\n```bash\nforge install transmissions11/solmate\n```\n\n## Dependency Best Practices\n\n### 1. Pin Versions\n\n```bash\n# ‚úÖ GOOD - Pin to specific version\nforge install OpenZeppelin/openzeppelin-contracts@v4.9.0\n\n# ‚ùå BAD - Install latest (can break)\nforge install OpenZeppelin/openzeppelin-contracts\n```\n\n### 2. Use Audited Libraries\n\n```solidity\n// ‚úÖ GOOD - Use audited libraries\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// ‚ùå BAD - Copy-paste unaudited code\n// Don't copy code from unverified sources\n```\n\n### 3. Minimize Dependencies\n\n```solidity\n// ‚úÖ GOOD - Only import what you need\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// ‚ùå BAD - Import entire library\nimport \"@openzeppelin/contracts/\";\n```\n\n### 4. Review Dependencies\n\nBefore adding a dependency:\n\n- [ ] Is it audited?\n- [ ] Is it maintained?\n- [ ] Does it fit your needs?\n- [ ] Are there security concerns?\n- [ ] Is it gas efficient?\n\n## Updating Dependencies\n\n### Update Process\n\n```bash\n# 1. Check current version\ncd lib/openzeppelin-contracts\ngit log --oneline -1\n\n# 2. Update to latest version\ncd ../..\nforge update OpenZeppelin/openzeppelin-contracts\n\n# 3. Test after update\nforge test\n\n# 4. Review changelog for breaking changes\n```\n\n### Breaking Changes\n\nWhen updating dependencies:\n\n1. **Review Changelog** - Check for breaking changes\n2. **Run Tests** - Ensure all tests pass\n3. **Check Gas** - Verify gas usage hasn't increased significantly\n4. **Security Review** - Review security implications\n\n## Git Submodules\n\n### Initializing Submodules\n\n```bash\n# Clone repository with submodules\ngit clone --recurse-submodules <repository-url>\n\n# Or initialize existing repository\ngit submodule update --init --recursive\n```\n\n### Updating Submodules\n\n```bash\n# Update all submodules\ngit submodule update --remote\n\n# Update specific submodule\ngit submodule update --remote lib/openzeppelin-contracts\n```\n\n### Committing Submodule Changes\n\n```bash\n# When dependency is updated, commit submodule reference\ngit add lib/openzeppelin-contracts\ngit commit -m \"chore(deps): update OpenZeppelin Contracts to v4.9.0\"\n```\n\n## Security Considerations\n\n### 1. Audit Dependencies\n\n```bash\n# ‚úÖ GOOD - Use audited libraries\n# OpenZeppelin Contracts are audited\n\n# ‚ùå BAD - Use unaudited code\n# Don't use unverified dependencies\n```\n\n### 2. Check for Vulnerabilities\n\n```bash\n# Review dependency security\n# Check for known vulnerabilities\n# Review audit reports\n```\n\n### 3. Minimize Attack Surface\n\n```solidity\n// ‚úÖ GOOD - Minimal dependencies\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// ‚ùå BAD - Too many dependencies\n// Each dependency adds potential attack surface\n```\n\n## foundry.toml Configuration\n\n### Complete Example\n\n```toml\n[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\ntest = \"test\"\nscript = \"script\"\n\n# Solidity version\nsolc = \"0.8.20\"\n\n# Optimizer\noptimizer = true\noptimizer_runs = 200\n\n# Remappings\nremappings = [\n    \"@openzeppelin/=lib/openzeppelin-contracts/\",\n    \"@forge-std/=lib/forge-std/src/\",\n]\n\n# Test settings\n[profile.default.test]\nfuzz = { runs = 256 }\ninvariant = { runs = 256 }\n\n# Coverage\n[profile.default.coverage]\nexclude = [\"test\", \"script\"]\n```\n\n## .gitignore\n\nEnsure dependencies are handled correctly:\n\n```gitignore\n# Foundry\nout/\ncache/\nbroadcast/\n\n# Dependencies (submodules are tracked, but build artifacts are not)\nlib/**/out/\nlib/**/cache/\n```\n\n## Best Practices Summary\n\n### ‚úÖ DO\n\n- Pin dependencies to specific versions\n- Use audited libraries (OpenZeppelin, etc.)\n- Review dependencies before adding\n- Test after updating dependencies\n- Document dependency choices\n- Keep dependencies up to date (with testing)\n\n### ‚ùå DON'T\n\n- Use unverified dependencies\n- Copy-paste code from unverified sources\n- Update dependencies without testing\n- Use too many dependencies\n- Ignore security considerations\n\n## Common Commands\n\n```bash\n# Install dependency\nforge install <org>/<repo>\n\n# Install specific version\nforge install <org>/<repo>@<version>\n\n# Update dependency\nforge update <org>/<repo>\n\n# Update all dependencies\nforge update\n\n# Remove dependency\nforge remove <org>/<repo>\n\n# List dependencies\nls lib/\n\n# Initialize submodules\ngit submodule update --init --recursive\n```\n\n## Remember\n\n- **Pin Versions** - Always pin to specific versions\n- **Use Audited Libraries** - Prefer OpenZeppelin and other audited code\n- **Minimize Dependencies** - Only add what you need\n- **Test Updates** - Always test after updating\n- **Security First** - Review security implications\n- **Document Choices** - Document why dependencies are chosen\n",
          "alwaysApply": true,
          "globs": [
            "**/foundry.toml",
            "**/lib/**"
          ]
        },
        {
          "id": "error-handling-patterns",
          "title": "Error Handling Patterns",
          "fileName": "error-handling-patterns.mdc",
          "frontmatter": {
            "description": "Error handling patterns and best practices for Solidity smart contracts",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Error Handling Patterns\n\n## Philosophy\n\nError handling in Solidity is critical for security, gas efficiency, and user experience. Our error handling strategy focuses on:\n1. **Gas Efficiency** - Use custom errors instead of require strings\n2. **Clarity** - Clear error messages for debugging\n3. **Security** - Proper validation and error propagation\n4. **User Experience** - Meaningful error information\n\n## Error Types\n\n### 1. Custom Errors (0.8.4+)\n\n**Preferred method** - Gas efficient and type-safe:\n\n```solidity\n// ‚úÖ GOOD - Custom errors\ncontract Token {\n    error InsufficientBalance(uint256 required, uint256 available);\n    error Unauthorized(address account);\n    error InvalidAddress(address provided);\n    error TransferFailed(address from, address to, uint256 amount);\n    \n    mapping(address => uint256) public balances;\n    \n    function transfer(address to, uint256 amount) external {\n        if (to == address(0)) {\n            revert InvalidAddress(to);\n        }\n        \n        uint256 senderBalance = balances[msg.sender];\n        if (senderBalance < amount) {\n            revert InsufficientBalance(amount, senderBalance);\n        }\n        \n        balances[msg.sender] = senderBalance - amount;\n        balances[to] += amount;\n    }\n}\n```\n\n### 2. Require Statements\n\nUse for simple conditions with descriptive messages:\n\n```solidity\n// ‚úÖ GOOD - Simple require with message\nfunction withdraw(uint256 amount) external {\n    require(amount > 0, \"Amount must be positive\");\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    \n    balances[msg.sender] -= amount;\n    // ...\n}\n\n// ‚ùå BAD - Generic error message\nfunction withdraw(uint256 amount) external {\n    require(balances[msg.sender] >= amount, \"Error\");\n    // ...\n}\n```\n\n### 3. Revert with Custom Errors\n\nUse revert with custom errors for complex conditions:\n\n```solidity\n// ‚úÖ GOOD - Revert with custom error\nfunction complexOperation(uint256 amount, address recipient) external {\n    if (amount == 0) {\n        revert InvalidAmount(amount);\n    }\n    \n    if (recipient == address(0)) {\n        revert InvalidAddress(recipient);\n    }\n    \n    uint256 balance = balances[msg.sender];\n    if (balance < amount) {\n        revert InsufficientBalance(amount, balance);\n    }\n    \n    // ... operation ...\n}\n```\n\n## Error Organization\n\n### Centralized Error Definitions\n\nDefine errors in a separate file or at contract level:\n\n```solidity\n// errors/CommonErrors.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Common errors used across contracts\nlibrary CommonErrors {\n    error InsufficientBalance(uint256 required, uint256 available);\n    error Unauthorized(address account);\n    error InvalidAddress(address provided);\n    error InvalidAmount(uint256 amount);\n    error TransferFailed(address from, address to, uint256 amount);\n    error ContractPaused();\n    error ContractNotInitialized();\n}\n\n// Usage\nimport \"./errors/CommonErrors.sol\";\n\ncontract Token {\n    using CommonErrors for *;\n    \n    function transfer(address to, uint256 amount) external {\n        if (balances[msg.sender] < amount) {\n            revert CommonErrors.InsufficientBalance(amount, balances[msg.sender]);\n        }\n        // ...\n    }\n}\n```\n\n### Contract-Specific Errors\n\nDefine errors at contract level for contract-specific errors:\n\n```solidity\ncontract Token {\n    // Contract-specific errors\n    error MaxSupplyExceeded(uint256 requested, uint256 max);\n    error MintingPaused();\n    error BurnAmountExceedsBalance(uint256 amount, uint256 balance);\n    \n    // Use common errors for generic cases\n    error InsufficientBalance(uint256 required, uint256 available);\n    \n    function mint(address to, uint256 amount) external {\n        if (paused) {\n            revert MintingPaused();\n        }\n        \n        uint256 newSupply = totalSupply() + amount;\n        if (newSupply > MAX_SUPPLY) {\n            revert MaxSupplyExceeded(newSupply, MAX_SUPPLY);\n        }\n        \n        // ... mint logic ...\n    }\n}\n```\n\n## Error Patterns\n\n### 1. Input Validation\n\nAlways validate inputs:\n\n```solidity\n// ‚úÖ GOOD - Comprehensive input validation\nfunction transfer(address to, uint256 amount) external {\n    // Validate recipient\n    if (to == address(0)) {\n        revert InvalidAddress(to);\n    }\n    \n    // Validate amount\n    if (amount == 0) {\n        revert InvalidAmount(amount);\n    }\n    \n    // Validate balance\n    uint256 balance = balances[msg.sender];\n    if (balance < amount) {\n        revert InsufficientBalance(amount, balance);\n    }\n    \n    // Execute transfer\n    balances[msg.sender] = balance - amount;\n    balances[to] += amount;\n}\n\n// ‚ùå BAD - Missing validation\nfunction transfer(address to, uint256 amount) external {\n    balances[msg.sender] -= amount;  // No validation!\n    balances[to] += amount;\n}\n```\n\n### 2. State Validation\n\nValidate contract state:\n\n```solidity\ncontract Token {\n    bool public paused;\n    \n    error ContractPaused();\n    \n    modifier whenNotPaused() {\n        if (paused) {\n            revert ContractPaused();\n        }\n        _;\n    }\n    \n    function transfer(address to, uint256 amount) external whenNotPaused {\n        // ... transfer logic ...\n    }\n}\n```\n\n### 3. Access Control Validation\n\nValidate permissions:\n\n```solidity\ncontract Token {\n    address public owner;\n    \n    error Unauthorized(address account);\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n    \n    function pause() external onlyOwner {\n        paused = true;\n    }\n}\n```\n\n### 4. External Call Validation\n\nValidate external call results:\n\n```solidity\ncontract Token {\n    error TransferFailed(address from, address to, uint256 amount);\n    \n    function transferTokens(address token, address to, uint256 amount) external {\n        bool success = IERC20(token).transfer(to, amount);\n        if (!success) {\n            revert TransferFailed(address(this), to, amount);\n        }\n    }\n    \n    function sendEther(address payable recipient, uint256 amount) external {\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert TransferFailed(address(this), recipient, amount);\n        }\n    }\n}\n```\n\n## Error Propagation\n\n### 1. Let Errors Bubble Up\n\nDon't catch errors unnecessarily:\n\n```solidity\n// ‚úÖ GOOD - Let errors propagate\nfunction batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {\n    require(recipients.length == amounts.length, \"Arrays length mismatch\");\n    \n    for (uint256 i = 0; i < recipients.length; i++) {\n        transfer(recipients[i], amounts[i]);  // Errors will propagate\n    }\n}\n\n// ‚ùå BAD - Unnecessary try-catch\nfunction batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {\n    for (uint256 i = 0; i < recipients.length; i++) {\n        try this.transfer(recipients[i], amounts[i]) {} catch {\n            // Swallowing errors is dangerous\n        }\n    }\n}\n```\n\n### 2. Use Try-Catch When Appropriate\n\nUse try-catch for external calls that might fail:\n\n```solidity\n// ‚úÖ GOOD - Try-catch for external calls\nfunction safeTransfer(address token, address to, uint256 amount) external {\n    try IERC20(token).transfer(to, amount) returns (bool success) {\n        if (!success) {\n            revert TransferFailed(address(this), to, amount);\n        }\n    } catch {\n        revert TransferFailed(address(this), to, amount);\n    }\n}\n```\n\n## Error Messages\n\n### Custom Error Parameters\n\nInclude relevant context in error parameters:\n\n```solidity\n// ‚úÖ GOOD - Informative error parameters\nerror InsufficientBalance(uint256 required, uint256 available);\nerror TransferFailed(address from, address to, uint256 amount);\nerror InvalidAmount(uint256 amount, uint256 min, uint256 max);\n\nfunction transfer(address to, uint256 amount) external {\n    uint256 balance = balances[msg.sender];\n    if (balance < amount) {\n        revert InsufficientBalance(amount, balance);  // Includes both values\n    }\n    // ...\n}\n\n// ‚ùå BAD - Missing context\nerror InsufficientBalance();\n\nfunction transfer(address to, uint256 amount) external {\n    if (balances[msg.sender] < amount) {\n        revert InsufficientBalance();  // No context\n    }\n    // ...\n}\n```\n\n### Require Messages\n\nUse descriptive require messages:\n\n```solidity\n// ‚úÖ GOOD - Descriptive messages\nfunction withdraw(uint256 amount) external {\n    require(amount > 0, \"Amount must be greater than zero\");\n    require(balances[msg.sender] >= amount, \"Insufficient balance for withdrawal\");\n    require(!paused, \"Contract is currently paused\");\n    // ...\n}\n\n// ‚ùå BAD - Generic or missing messages\nfunction withdraw(uint256 amount) external {\n    require(amount > 0);\n    require(balances[msg.sender] >= amount, \"Error\");\n    // ...\n}\n```\n\n## Gas Optimization\n\n### Custom Errors vs Require Strings\n\nCustom errors are more gas efficient:\n\n```solidity\n// ‚úÖ GOOD - Custom error (cheaper)\nerror InsufficientBalance(uint256 required, uint256 available);\n\nfunction transfer(address to, uint256 amount) external {\n    if (balances[msg.sender] < amount) {\n        revert InsufficientBalance(amount, balances[msg.sender]);\n    }\n    // ...\n}\n\n// ‚ùå BAD - Require string (more expensive)\nfunction transfer(address to, uint256 amount) external {\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    // ...\n}\n```\n\n**Gas Comparison:**\n- Custom error: ~24 gas\n- Require with string: ~100+ gas (depends on string length)\n\n## Error Handling Best Practices\n\n### 1. Fail Fast\n\nValidate early and fail fast:\n\n```solidity\n// ‚úÖ GOOD - Validate early\nfunction complexOperation(\n    address recipient,\n    uint256 amount,\n    bytes calldata data\n) external {\n    // Validate all inputs first\n    if (recipient == address(0)) revert InvalidAddress(recipient);\n    if (amount == 0) revert InvalidAmount(amount);\n    if (paused) revert ContractPaused();\n    \n    // Then perform operation\n    // ...\n}\n\n// ‚ùå BAD - Validate late\nfunction complexOperation(\n    address recipient,\n    uint256 amount,\n    bytes calldata data\n) external {\n    // Do some work first\n    uint256 result = calculateSomething();\n    \n    // Validate late (wasted gas)\n    if (recipient == address(0)) revert InvalidAddress(recipient);\n    // ...\n}\n```\n\n### 2. Use Modifiers for Common Checks\n\n```solidity\ncontract Token {\n    error Unauthorized(address account);\n    error ContractPaused();\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        if (paused) {\n            revert ContractPaused();\n        }\n        _;\n    }\n    \n    function transfer(address to, uint256 amount) external whenNotPaused {\n        // ...\n    }\n    \n    function pause() external onlyOwner {\n        paused = true;\n    }\n}\n```\n\n### 3. Provide Context in Errors\n\n```solidity\n// ‚úÖ GOOD - Contextual errors\nerror InsufficientBalance(uint256 required, uint256 available);\nerror MaxSupplyExceeded(uint256 requested, uint256 max);\n\nfunction mint(address to, uint256 amount) external {\n    uint256 newSupply = totalSupply() + amount;\n    if (newSupply > MAX_SUPPLY) {\n        revert MaxSupplyExceeded(newSupply, MAX_SUPPLY);\n    }\n    // ...\n}\n```\n\n## Testing Errors\n\n### Test Error Conditions\n\n```solidity\ncontract TokenTest is Test {\n    Token public token;\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function test_Transfer_RevertsOnInsufficientBalance() public {\n        uint256 amount = 1000;\n        \n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Token.InsufficientBalance.selector,\n                amount,\n                0\n            )\n        );\n        token.transfer(address(1), amount);\n    }\n    \n    function test_Transfer_RevertsOnZeroAddress() public {\n        vm.expectRevert(Token.InvalidAddress.selector);\n        token.transfer(address(0), 100);\n    }\n}\n```\n\n## Remember\n\n- **Use Custom Errors** - Gas efficient (0.8.4+)\n- **Validate Early** - Fail fast to save gas\n- **Provide Context** - Include relevant values in errors\n- **Use Modifiers** - For common checks\n- **Test Errors** - Verify error conditions\n- **Don't Swallow Errors** - Let them propagate\n- **Gas Efficiency** - Custom errors > require strings\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "git-workflow",
          "title": "Git Workflow",
          "fileName": "git-workflow.mdc",
          "frontmatter": {
            "description": "Git workflow, commit message conventions, and version control best practices for Solidity Foundry projects",
            "globs": [
              "**/.git/**",
              "**/.gitignore"
            ],
            "alwaysApply": true
          },
          "content": "# Git Workflow Guidelines\n\n## Commit Message Format\n\nFollow the [Conventional Commits](https://www.conventionalcommits.org/) specification for consistent commit messages.\n\n### Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- **`feat`**: A new feature\n- **`fix`**: A bug fix\n- **`docs`**: Documentation only changes\n- **`style`**: Code style changes (formatting, etc.)\n- **`refactor`**: Code refactoring without bug fixes or features\n- **`perf`**: Performance/gas improvements\n- **`test`**: Adding or updating tests\n- **`chore`**: Maintenance tasks, dependency updates\n- **`build`**: Build system or external dependencies\n- **`ci`**: CI/CD configuration changes\n- **`security`**: Security fixes or improvements\n\n### Examples\n\n```bash\n# Feature\nfeat(token): add minting functionality with role-based access control\n\n# Bug fix\nfix(vault): resolve reentrancy vulnerability in withdraw function\n\n# Security fix\nsecurity(token): fix integer overflow in transfer function\n\n# Gas optimization\nperf(token): optimize storage reads in batch transfer function\n\n# Breaking change\nfeat(token)!: change transfer function signature\n\nBREAKING CHANGE: Transfer function now requires additional parameter\n\n# Multiple changes\nfeat(token): add staking functionality\n\n- Add StakingContract\n- Implement stake/unstake functions\n- Add reward distribution mechanism\n```\n\n### Scope\n\nUse scope to indicate which part of the codebase is affected:\n\n- `token`: Token contracts\n- `vault`: Vault contracts\n- `access`: Access control contracts\n- `interfaces`: Interface definitions\n- `libraries`: Library contracts\n- `tests`: Test files\n- `scripts`: Deployment scripts\n- `deps`: Dependencies\n\n### Subject\n\n- Use imperative mood (\"add\" not \"added\" or \"adds\")\n- First line should be 50 characters or less\n- Don't end with a period\n- Be specific and descriptive\n\n### Body (Optional)\n\n- Explain the \"what\" and \"why\" vs \"how\"\n- Wrap at 72 characters\n- Can include multiple paragraphs\n- Include security considerations if applicable\n\n### Footer (Optional)\n\n- Reference issues: `Closes #123`, `Fixes #456`\n- Breaking changes: `BREAKING CHANGE: <description>`\n- Security: `SECURITY: <description>` for security fixes\n\n## Branch Naming\n\n### Format\n\n```\n<type>/<description>\n```\n\n### Types\n\n- `feature/`: New features\n- `fix/`: Bug fixes\n- `hotfix/`: Critical production fixes\n- `security/`: Security fixes\n- `refactor/`: Code refactoring\n- `docs/`: Documentation updates\n- `test/`: Test additions/updates\n- `perf/`: Performance/gas optimizations\n\n### Examples\n\n```bash\nfeature/token-staking\nfix/vault-reentrancy\nsecurity/token-overflow-fix\nhotfix/critical-transfer-bug\nrefactor/access-control\nperf/batch-transfer-optimization\n```\n\n## Commit Best Practices\n\n### ‚úÖ DO\n\n- Make atomic commits (one logical change per commit)\n- Write clear, descriptive commit messages\n- Commit frequently (small, incremental changes)\n- Test before committing (`forge test`)\n- Run pre-commit hooks before committing\n- Review your changes with `git diff` before committing\n- Include security considerations in commit messages\n\n### ‚ùå DON'T\n\n- Commit commented-out code\n- Commit debugging code or console.log statements\n- Commit with compiler warnings (see `no-hiding.mdc`)\n- Mix unrelated changes in one commit\n- Commit private keys or secrets\n- Force push to main/master branch\n- Commit without running tests\n- Commit contracts with known vulnerabilities\n\n## Workflow\n\n### 1. Create Feature Branch\n\n```bash\ngit checkout -b feature/my-new-feature\n```\n\n### 2. Make Changes\n\n- Write code following all guidelines\n- Ensure no compiler warnings (`forge build`)\n- Ensure code is formatted (`forge fmt`)\n- Test your changes (`forge test`)\n- Run gas snapshots if optimizing (`forge test --gas-report`)\n\n### 3. Stage Changes\n\n```bash\n# Review what you're committing\ngit status\ngit diff\n\n# Stage specific files\ngit add src/contracts/Token.sol\n\n# Or stage all changes\ngit add .\n```\n\n### 4. Run Pre-commit Hooks\n\n```bash\n# Pre-commit hooks should run automatically\n# But you can run manually:\npre-commit run --all-files\n\n# Or run Foundry checks manually\nforge fmt --check\nforge test\n```\n\n### 5. Commit\n\n```bash\ngit commit -m \"feat(token): add minting functionality\"\n```\n\n### 6. Push and Create PR\n\n```bash\ngit push origin feature/my-new-feature\n```\n\nThen create a Pull Request with:\n- Clear title matching commit message format\n- Description explaining the change\n- Security considerations if applicable\n- Gas impact if optimizing\n- Reference to related issues\n\n## Pull Request Guidelines\n\n### PR Title\n\nFollow the same format as commit messages:\n\n```\nfeat(token): add staking functionality\n```\n\n### PR Description Template\n\n```markdown\n## Description\nBrief description of what this PR does.\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Breaking change\n- [ ] Security fix\n- [ ] Performance improvement\n- [ ] Documentation update\n\n## Security Considerations\n- [ ] Security review completed\n- [ ] No known vulnerabilities\n- [ ] Access control properly implemented\n- [ ] Reentrancy protection in place\n- [ ] Input validation implemented\n\n## Testing\n- [ ] Tests pass locally (`forge test`)\n- [ ] Fuzz tests added/updated\n- [ ] Gas snapshots updated (`forge test --gas-report`)\n- [ ] Manual testing completed\n- [ ] Edge cases considered\n\n## Gas Impact\n- [ ] Gas usage measured\n- [ ] Optimization documented\n- [ ] Gas report included\n\n## Checklist\n- [ ] Code follows style guidelines (`forge fmt`)\n- [ ] No compiler warnings\n- [ ] NatSpec documentation added\n- [ ] Self-review completed\n- [ ] Tests added/updated\n- [ ] Documentation updated if needed\n```\n\n## Handling Conflicts\n\n### When Your Branch is Behind\n\n```bash\n# Fetch latest changes\ngit fetch origin\n\n# Rebase your branch on main\ngit checkout feature/my-feature\ngit rebase origin/main\n\n# Resolve conflicts if any\n# Then continue rebase\ngit rebase --continue\n\n# Force push (only on feature branches)\ngit push --force-with-lease origin feature/my-feature\n```\n\n## Git Ignore\n\nEnsure these are in `.gitignore`:\n\n```\n# Foundry\nout/\ncache/\nbroadcast/\n\n# Dependencies\nlib/\n\n# Environment\n.env\n.env.local\n.env*.local\n\n# IDEs\n.vscode/\n.idea/\n*.swp\n*.swo\n*.sublime-project\n*.sublime-workspace\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Temporary files\n*.tmp\n.cache/\n\n# Private keys (CRITICAL - never commit)\n*.key\n*.pem\n*.env\nsecrets/\n```\n\n## Pre-commit Hooks\n\n**Configuration (`.pre-commit-config.yaml`):**\n\n```yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: forge-fmt\n        name: forge fmt\n        entry: forge fmt --check\n        language: system\n        pass_filenames: false\n        always_run: true\n      \n      - id: forge-test\n        name: forge test\n        entry: forge test\n        language: system\n        pass_filenames: false\n        always_run: true\n      \n      - id: solhint\n        name: solhint\n        entry: solhint\n        language: system\n        types: [solidity]\n        pass_filenames: true\n```\n\n**Install hooks:**\n\n```bash\npre-commit install\n```\n\n## Common Commands\n\n```bash\n# Check status\ngit status\n\n# View changes\ngit diff\ngit diff --staged\n\n# View commit history\ngit log --oneline --graph\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Undo last commit (discard changes)\ngit reset --hard HEAD~1\n\n# Stash changes\ngit stash\ngit stash pop\n\n# View stashes\ngit stash list\n\n# Create branch from main\ngit checkout main\ngit pull origin main\ngit checkout -b feature/new-feature\n```\n\n## Security Considerations\n\n### Never Commit\n\n- Private keys\n- Mnemonic phrases\n- API keys\n- Environment files with secrets\n- Hardcoded addresses with private keys\n\n### Security Commit Messages\n\nFor security fixes, use the `security` type:\n\n```bash\nsecurity(token): fix reentrancy vulnerability in withdraw\n\nSECURITY: Fixed reentrancy attack vector by implementing\nchecks-effects-interactions pattern and ReentrancyGuard.\n```\n\n## Remember\n\n- **Small, frequent commits** are better than large, infrequent ones\n- **Clear commit messages** help future you and your team\n- **Test before committing** to avoid broken commits\n- **Run pre-commit hooks** to catch issues early\n- **Review your changes** with `git diff` before committing\n- **Never commit secrets** or private keys\n- **Follow conventional commits** for consistency\n- **Security first** - Always document security considerations\n",
          "alwaysApply": true,
          "globs": [
            "**/.git/**",
            "**/.gitignore"
          ]
        },
        {
          "id": "key-architecture-patterns",
          "title": "Key Architecture Patterns",
          "fileName": "key-architecture-patterns.mdc",
          "frontmatter": {
            "description": "Key architectural patterns and organizational principles for Solidity smart contracts",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Key Architectural Patterns\n\n## Overview\n\nThis document outlines the core architectural patterns used throughout Solidity smart contract development. These patterns ensure consistency, security, maintainability, and gas efficiency.\n\n## Contract Organization\n\n### Separation of Concerns\n\nOrganize contracts by responsibility:\n\n```\nsrc/\n‚îú‚îÄ‚îÄ contracts/\n‚îÇ   ‚îú‚îÄ‚îÄ core/              # Core business logic\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Token.sol\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Vault.sol\n‚îÇ   ‚îú‚îÄ‚îÄ access/            # Access control\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Ownable.sol\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Roles.sol\n‚îÇ   ‚îú‚îÄ‚îÄ interfaces/        # Interfaces\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IToken.sol\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IVault.sol\n‚îÇ   ‚îî‚îÄ‚îÄ utils/             # Utilities\n‚îÇ       ‚îî‚îÄ‚îÄ Errors.sol\n‚îú‚îÄ‚îÄ libraries/             # Reusable libraries\n‚îÇ   ‚îî‚îÄ‚îÄ Math.sol\n‚îî‚îÄ‚îÄ mocks/                 # Mock contracts for testing\n    ‚îî‚îÄ‚îÄ MockERC20.sol\n```\n\n### Interface Pattern\n\nDefine interfaces before implementations:\n\n```solidity\n// ‚úÖ GOOD - Interface first\n// interfaces/IToken.sol\ninterface IToken {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n// contracts/Token.sol\ncontract Token is IToken {\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        // Implementation\n    }\n    \n    function balanceOf(address account) external view override returns (uint256) {\n        // Implementation\n    }\n}\n```\n\n## Access Control Patterns\n\n### 1. Ownable Pattern\n\nSimple ownership pattern:\n\n```solidity\n// ‚úÖ GOOD - Using OpenZeppelin Ownable\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Token is Ownable {\n    function mint(address to, uint256 amount) external onlyOwner {\n        // Only owner can mint\n    }\n    \n    function transferOwnership(address newOwner) public override onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n}\n```\n\n### 2. Role-Based Access Control (RBAC)\n\nMore granular access control:\n\n```solidity\n// ‚úÖ GOOD - Using OpenZeppelin AccessControl\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Token is AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    \n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        // Only minters can mint\n    }\n    \n    function burn(uint256 amount) external onlyRole(BURNER_ROLE) {\n        // Only burners can burn\n    }\n}\n```\n\n### 3. Custom Access Control\n\nFor specific requirements:\n\n```solidity\n// ‚úÖ GOOD - Custom access control\ncontract Token {\n    address public owner;\n    mapping(address => bool) public authorized;\n    \n    error Unauthorized(address account);\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n    \n    modifier onlyAuthorized() {\n        if (!authorized[msg.sender] && msg.sender != owner) {\n            revert Unauthorized(msg.sender);\n        }\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function setAuthorized(address account, bool status) external onlyOwner {\n        authorized[account] = status;\n    }\n}\n```\n\n## Upgradeability Patterns\n\n### 1. UUPS (Universal Upgradeable Proxy Standard)\n\nGas-efficient upgradeable pattern:\n\n```solidity\n// ‚úÖ GOOD - UUPS Pattern\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract TokenV1 is UUPSUpgradeable, OwnableUpgradeable {\n    uint256 public value;\n    \n    function initialize() public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        value = 100;\n    }\n    \n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n    \n    function setValue(uint256 _value) external {\n        value = _value;\n    }\n}\n\ncontract TokenV2 is TokenV1 {\n    uint256 public newValue;\n    \n    function initializeV2() public reinitializer(2) {\n        newValue = 200;\n    }\n}\n```\n\n### 2. Transparent Proxy Pattern\n\nSimpler but less gas efficient:\n\n```solidity\n// ‚úÖ GOOD - Transparent Proxy Pattern\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// Implementation contract\ncontract TokenImplementation {\n    uint256 public value;\n    \n    function setValue(uint256 _value) external {\n        value = _value;\n    }\n}\n\n// Deploy proxy pointing to implementation\n// TransparentUpgradeableProxy(implementation, admin, data)\n```\n\n## Factory Patterns\n\n### 1. Factory Contract\n\nCreate multiple instances:\n\n```solidity\n// ‚úÖ GOOD - Factory pattern\ncontract TokenFactory {\n    Token[] public tokens;\n    \n    event TokenCreated(address indexed token, address indexed creator);\n    \n    function createToken(string memory name, string memory symbol) external returns (address) {\n        Token newToken = new Token(name, symbol);\n        tokens.push(newToken);\n        emit TokenCreated(address(newToken), msg.sender);\n        return address(newToken);\n    }\n    \n    function getTokenCount() external view returns (uint256) {\n        return tokens.length;\n    }\n}\n```\n\n### 2. Clone Factory (Minimal Proxy)\n\nGas-efficient cloning:\n\n```solidity\n// ‚úÖ GOOD - Clone factory using EIP-1167\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract TokenFactory {\n    address public immutable tokenImplementation;\n    \n    event TokenCloned(address indexed clone, address indexed creator);\n    \n    constructor(address _tokenImplementation) {\n        tokenImplementation = _tokenImplementation;\n    }\n    \n    function cloneToken() external returns (address) {\n        address clone = Clones.clone(tokenImplementation);\n        Token(clone).initialize(msg.sender);\n        emit TokenCloned(clone, msg.sender);\n        return clone;\n    }\n}\n```\n\n## Library Patterns\n\n### 1. Internal Libraries\n\nFor internal use:\n\n```solidity\n// ‚úÖ GOOD - Internal library\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\ncontract Token {\n    using Math for uint256;\n    \n    function getMax(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.max(b);\n    }\n}\n```\n\n### 2. External Libraries\n\nFor deployment and reuse:\n\n```solidity\n// ‚úÖ GOOD - External library\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\n        return a + b;\n    }\n}\n\ncontract Token {\n    function calculate(uint256 a, uint256 b) external pure returns (uint256) {\n        return SafeMath.add(a, b);\n    }\n}\n```\n\n## Event Patterns\n\n### 1. Comprehensive Event Emission\n\nEmit events for all important state changes:\n\n```solidity\n// ‚úÖ GOOD - Comprehensive events\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed from, uint256 amount);\n    \n    function transfer(address to, uint256 amount) external returns (bool) {\n        // ... transfer logic ...\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    \n    function mint(address to, uint256 amount) external {\n        // ... mint logic ...\n        emit Mint(to, amount);\n        emit Transfer(address(0), to, amount);\n    }\n}\n```\n\n### 2. Indexed Parameters\n\nUse indexed parameters for filtering:\n\n```solidity\n// ‚úÖ GOOD - Indexed parameters for filtering\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n// Can filter by: Transfer(from=address, to=address)\n```\n\n## Error Patterns\n\n### 1. Centralized Errors\n\nDefine errors in separate file:\n\n```solidity\n// errors/CommonErrors.sol\nlibrary CommonErrors {\n    error InsufficientBalance(uint256 required, uint256 available);\n    error Unauthorized(address account);\n    error InvalidAddress(address provided);\n}\n\n// contracts/Token.sol\nimport \"./errors/CommonErrors.sol\";\n\ncontract Token {\n    using CommonErrors for *;\n    \n    function transfer(address to, uint256 amount) external {\n        if (balances[msg.sender] < amount) {\n            revert CommonErrors.InsufficientBalance(amount, balances[msg.sender]);\n        }\n        // ...\n    }\n}\n```\n\n### 2. Contract-Specific Errors\n\nDefine errors at contract level:\n\n```solidity\n// ‚úÖ GOOD - Contract-specific errors\ncontract Token {\n    error MaxSupplyExceeded(uint256 requested, uint256 max);\n    error MintingPaused();\n    \n    function mint(address to, uint256 amount) external {\n        if (paused) {\n            revert MintingPaused();\n        }\n        // ...\n    }\n}\n```\n\n## Modifier Patterns\n\n### 1. Reusable Modifiers\n\nCreate reusable modifiers:\n\n```solidity\n// ‚úÖ GOOD - Reusable modifiers\ncontract Token {\n    modifier onlyWhenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n    \n    modifier onlyWhenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n    \n    function transfer(address to, uint256 amount) external onlyWhenNotPaused {\n        // ...\n    }\n    \n    function emergencyWithdraw() external onlyWhenPaused {\n        // ...\n    }\n}\n```\n\n### 2. Parameterized Modifiers\n\nModifiers with parameters:\n\n```solidity\n// ‚úÖ GOOD - Parameterized modifier\ncontract Token {\n    modifier onlyWhenBalanceAtLeast(uint256 amount) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        _;\n    }\n    \n    function withdraw(uint256 amount) external onlyWhenBalanceAtLeast(amount) {\n        // ...\n    }\n}\n```\n\n## Storage Patterns\n\n### 1. Storage Layout\n\nOrganize storage variables:\n\n```solidity\n// ‚úÖ GOOD - Organized storage layout\ncontract Token {\n    // Constants\n    uint256 public constant MAX_SUPPLY = 1_000_000_000;\n    \n    // Core state\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n    \n    // Configuration\n    bool public paused;\n    address public owner;\n    \n    // Packed structs\n    struct UserData {\n        uint128 balance;\n        uint64 timestamp;\n        bool active;\n    }\n    mapping(address => UserData) public userData;\n}\n```\n\n### 2. Storage Gaps\n\nFor upgradeable contracts:\n\n```solidity\n// ‚úÖ GOOD - Storage gaps for upgradeability\ncontract Token {\n    uint256 public value;\n    uint256[49] private __gap;  // Reserve storage slots for future upgrades\n}\n```\n\n## Best Practices\n\n### 1. Use Interfaces for Abstraction\n\n```solidity\n// ‚úÖ GOOD - Interface-based design\ninterface IVault {\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n}\n\ncontract Vault is IVault {\n    // Implementation\n}\n\ncontract VaultManager {\n    IVault public vault;\n    \n    constructor(IVault _vault) {\n        vault = _vault;\n    }\n    \n    function manageDeposit(uint256 amount) external {\n        vault.deposit(amount);\n    }\n}\n```\n\n### 2. Composition Over Inheritance\n\n```solidity\n// ‚úÖ GOOD - Composition\ncontract Token {\n    Ownable public ownable;\n    \n    constructor() {\n        ownable = new Ownable();\n    }\n    \n    modifier onlyOwner() {\n        require(ownable.owner() == msg.sender, \"Not owner\");\n        _;\n    }\n}\n```\n\n### 3. Minimal External Dependencies\n\n```solidity\n// ‚úÖ GOOD - Minimal dependencies\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Only import what you need\n```\n\n## Remember\n\n- **Separation of Concerns** - Organize by responsibility\n- **Interfaces First** - Define interfaces before implementations\n- **Access Control** - Implement proper access control\n- **Events** - Emit events for important state changes\n- **Errors** - Use custom errors for gas efficiency\n- **Modifiers** - Create reusable modifiers\n- **Storage Layout** - Organize storage variables efficiently\n- **Composition** - Prefer composition over inheritance when possible\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "logging-guidelines",
          "title": "Logging Guidelines",
          "fileName": "logging-guidelines.mdc",
          "frontmatter": {
            "description": "Event logging standards and best practices for Solidity smart contracts",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Logging Guidelines\n\n## Philosophy\n\nIn Solidity, **events are the primary mechanism for logging**. Events are gas-efficient, provide off-chain visibility, and are essential for indexing and monitoring. Use events for all important state changes and operations.\n\n## ‚ö†Ô∏è IMPORTANT\n\n**Use events for logging, not console.log in production contracts.**\n\n- `console.log` is for testing/debugging only\n- Events are for production logging\n- Events are cheaper than storage for logging\n\n## Event Basics\n\n### Event Declaration\n\n```solidity\n// ‚úÖ GOOD - Well-designed event\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n// ‚úÖ GOOD - Multiple indexed parameters\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n// ‚úÖ GOOD - Non-indexed parameters for data\nevent TokenMinted(address indexed to, uint256 amount, uint256 timestamp);\n```\n\n### Event Emission\n\n```solidity\n// ‚úÖ GOOD - Emit events for important state changes\nfunction transfer(address to, uint256 amount) external returns (bool) {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);  // Emit event\n    return true;\n}\n```\n\n## When to Emit Events\n\n### ‚úÖ DO Emit Events For\n\n1. **State Changes** - All important state modifications\n2. **Transfers** - Token transfers, ETH transfers\n3. **Approvals** - Token approvals, access grants\n4. **Administrative Actions** - Ownership changes, parameter updates\n5. **User Actions** - Deposits, withdrawals, stakes\n6. **Errors** - Important error conditions (via custom errors, not events)\n\n### ‚ùå DON'T Emit Events For\n\n1. **View Functions** - Pure read operations\n2. **Internal Operations** - Internal state changes (unless critical)\n3. **Redundant Information** - Information already in other events\n4. **Debugging** - Use console.log in tests, not events\n\n## Event Design\n\n### Indexed Parameters\n\nUse `indexed` for parameters you want to filter by:\n\n```solidity\n// ‚úÖ GOOD - Indexed parameters for filtering\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n// Can filter by: Transfer(from=address, to=address)\n// Cannot efficiently filter by value (not indexed)\n```\n\n**Rules for Indexed Parameters:**\n- Maximum 3 indexed parameters per event\n- Use indexed for addresses, IDs, and frequently queried values\n- Don't index large arrays or strings (gas inefficient)\n\n### Non-Indexed Parameters\n\nUse non-indexed for data that doesn't need filtering:\n\n```solidity\n// ‚úÖ GOOD - Non-indexed for data\nevent TokenMinted(\n    address indexed to,        // Indexed - filter by recipient\n    uint256 amount,             // Non-indexed - data\n    uint256 timestamp           // Non-indexed - data\n);\n```\n\n## Event Patterns\n\n### 1. Transfer Events\n\n```solidity\n// ‚úÖ GOOD - Standard transfer event\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction transfer(address to, uint256 amount) external returns (bool) {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n}\n\nfunction mint(address to, uint256 amount) external {\n    totalSupply += amount;\n    balances[to] += amount;\n    emit Transfer(address(0), to, amount);  // Minting: from = address(0)\n}\n\nfunction burn(uint256 amount) external {\n    balances[msg.sender] -= amount;\n    totalSupply -= amount;\n    emit Transfer(msg.sender, address(0), amount);  // Burning: to = address(0)\n}\n```\n\n### 2. Approval Events\n\n```solidity\n// ‚úÖ GOOD - Approval event\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\nfunction approve(address spender, uint256 amount) external returns (bool) {\n    allowances[msg.sender][spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n}\n```\n\n### 3. Administrative Events\n\n```solidity\n// ‚úÖ GOOD - Administrative events\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nevent Paused(address account);\nevent Unpaused(address account);\nevent ParameterUpdated(string parameter, uint256 oldValue, uint256 newValue);\n\nfunction transferOwnership(address newOwner) external onlyOwner {\n    address oldOwner = owner;\n    owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}\n\nfunction pause() external onlyOwner {\n    paused = true;\n    emit Paused(msg.sender);\n}\n```\n\n### 4. User Action Events\n\n```solidity\n// ‚úÖ GOOD - User action events\nevent Deposited(address indexed user, uint256 amount, uint256 timestamp);\nevent Withdrawn(address indexed user, uint256 amount, uint256 timestamp);\nevent Staked(address indexed user, uint256 amount, uint256 lockPeriod);\n\nfunction deposit() external payable {\n    deposits[msg.sender] += msg.value;\n    emit Deposited(msg.sender, msg.value, block.timestamp);\n}\n\nfunction withdraw(uint256 amount) external {\n    deposits[msg.sender] -= amount;\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n    emit Withdrawn(msg.sender, amount, block.timestamp);\n}\n```\n\n## Gas Considerations\n\n### Event Gas Costs\n\n- **LOG0:** 375 gas base\n- **LOG1:** 375 gas base + 375 per topic\n- **LOG2:** 375 gas base + 375 per topic\n- **LOG3:** 375 gas base + 375 per topic\n- **LOG4:** 375 gas base + 375 per topic\n- **Data:** 8 gas per byte\n\n**Example:**\n\n```solidity\n// Event with 2 indexed parameters + data\nevent Transfer(address indexed from, address indexed to, uint256 value);\n// Gas cost: ~375 (base) + 375*2 (topics) + 8*32 (data) = ~1,246 gas\n\n// Event with 3 indexed parameters\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n// Gas cost: ~375 (base) + 375*3 (topics) = ~1,500 gas\n```\n\n### Optimization Tips\n\n```solidity\n// ‚úÖ GOOD - Efficient event design\nevent Transfer(address indexed from, address indexed to, uint256 value);\n// Only indexes what's needed for filtering\n\n// ‚ùå BAD - Over-indexing\nevent Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed value  // Don't index if not needed for filtering\n);\n```\n\n## Event Documentation\n\n### NatSpec for Events\n\n```solidity\n/// @notice Emitted when tokens are transferred\n/// @param from The address tokens are transferred from (address(0) for minting)\n/// @param to The address tokens are transferred to (address(0) for burning)\n/// @param value The amount of tokens transferred\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n/// @notice Emitted when approval is set\n/// @param owner The address that approved the spending\n/// @param spender The address that was approved to spend\n/// @param value The amount of tokens approved\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n```\n\n## Best Practices\n\n### 1. Emit Events Before External Calls\n\n```solidity\n// ‚úÖ GOOD - Emit event before external call\nfunction withdraw(uint256 amount) external {\n    balances[msg.sender] -= amount;\n    emit Withdrawn(msg.sender, amount, block.timestamp);  // Emit first\n    (bool success, ) = msg.sender.call{value: amount}(\"\");  // External call after\n    require(success, \"Transfer failed\");\n}\n\n// ‚ùå BAD - Emit event after external call (if call fails, event not emitted)\nfunction withdraw(uint256 amount) external {\n    balances[msg.sender] -= amount;\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n    emit Withdrawn(msg.sender, amount, block.timestamp);  // After external call\n}\n```\n\n### 2. Include Relevant Context\n\n```solidity\n// ‚úÖ GOOD - Include relevant context\nevent TokenMinted(\n    address indexed to,\n    uint256 amount,\n    uint256 timestamp,\n    address indexed minter\n);\n\n// ‚ùå BAD - Missing context\nevent TokenMinted(address indexed to, uint256 amount);\n```\n\n### 3. Use Consistent Event Names\n\n```solidity\n// ‚úÖ GOOD - Consistent naming\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n// ‚ùå BAD - Inconsistent naming\nevent Transfer(address from, address to, uint256 value);\nevent Approve(address owner, address spender, uint256 value);  // Different verb\n```\n\n### 4. Emit Events for All State Changes\n\n```solidity\n// ‚úÖ GOOD - Emit event for state change\nfunction setFee(uint256 newFee) external onlyOwner {\n    uint256 oldFee = fee;\n    fee = newFee;\n    emit FeeUpdated(oldFee, newFee);\n}\n\n// ‚ùå BAD - Missing event\nfunction setFee(uint256 newFee) external onlyOwner {\n    fee = newFee;  // No event emitted\n}\n```\n\n## Console.log (Testing Only)\n\n### Use in Tests\n\n```solidity\n// ‚úÖ GOOD - Console.log in tests\nimport \"forge-std/console.sol\";\n\ncontract TokenTest is Test {\n    function test_Transfer() public {\n        Token token = new Token();\n        token.mint(address(this), 100);\n        \n        console.log(\"Balance before:\", token.balanceOf(address(this)));\n        token.transfer(address(1), 50);\n        console.log(\"Balance after:\", token.balanceOf(address(this)));\n    }\n}\n\n// ‚ùå BAD - Console.log in production contracts\ncontract Token {\n    function transfer(address to, uint256 amount) external {\n        console.log(\"Transferring:\", amount);  // Don't use in production\n        // ...\n    }\n}\n```\n\n## Remember\n\n- **Events for Production** - Use events, not console.log\n- **Emit for State Changes** - All important state changes\n- **Indexed Parameters** - Maximum 3, use for filtering\n- **Gas Efficient** - Events are cheaper than storage\n- **Document Events** - NatSpec for all events\n- **Consistent Naming** - Use consistent event names\n- **Include Context** - Provide relevant information in events\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "no-hiding",
          "title": "No Hiding",
          "fileName": "no-hiding.mdc",
          "frontmatter": {
            "description": "Critical rule - never hide compiler warnings, linter errors, or security issues",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# No Hiding Rule\n\n## Critical Rule\n\n**NEVER hide compiler warnings, linter errors, or security issues.**\n\nAll compiler warnings, linter errors, and security issues **MUST** be fully resolved. Never suppress, ignore, or bypass them.\n\n## What This Means\n\n### ‚ùå NEVER Do This\n\n```solidity\n// ‚ùå BAD - Suppressing compiler warnings\npragma solidity ^0.8.20;\n// solhint-disable-next-line no-unused-vars\nfunction unusedFunction() external {\n    // ...\n}\n\n// ‚ùå BAD - Ignoring linter warnings\nfunction transfer(address to, uint256 amount) external {\n    // solhint-disable-next-line\n    balances[to] += amount;  // Ignoring warning\n}\n\n// ‚ùå BAD - Using unchecked blocks to hide overflow checks\nfunction unsafeIncrement(uint256 x) external pure returns (uint256) {\n    unchecked {\n        return x + 1;  // Hiding potential overflow\n    }\n}\n\n// ‚ùå BAD - Commenting out problematic code\n// function brokenFunction() external {\n//     return undefinedVariable;  // Has errors but commented out\n// }\n\n// ‚ùå BAD - Using assembly to bypass checks\nfunction unsafeOperation() external {\n    assembly {\n        // Bypassing Solidity safety checks\n    }\n}\n```\n\n### ‚úÖ ALWAYS Do This\n\n```solidity\n// ‚úÖ GOOD - Fix the actual issue\nfunction transfer(address to, uint256 amount) external {\n    require(to != address(0), \"Invalid recipient\");\n    require(amount > 0, \"Amount must be positive\");\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}\n\n// ‚úÖ GOOD - Remove unused code\n// Just delete unused functions/variables\n\n// ‚úÖ GOOD - Fix overflow issues properly\nfunction safeIncrement(uint256 x) external pure returns (uint256) {\n    // Solidity 0.8.0+ automatically checks overflow\n    return x + 1;\n}\n\n// ‚úÖ GOOD - Use unchecked only when overflow is impossible\nfunction incrementInLoop(uint256 length) external pure returns (uint256) {\n    uint256 sum = 0;\n    for (uint256 i = 0; i < length;) {\n        sum += i;\n        unchecked {\n            i++;  // Safe: i < length, so i++ cannot overflow\n        }\n    }\n    return sum;\n}\n\n// ‚úÖ GOOD - Fix broken code immediately\nfunction fixedFunction() external pure returns (uint256) {\n    return 100;  // Fixed implementation\n}\n```\n\n## Tools We Use\n\n### 1. Solidity Compiler\n\n**Configuration:** `foundry.toml`\n\n```toml\n[profile.default]\nsolc = \"0.8.20\"\noptimizer = true\noptimizer_runs = 200\nvia_ir = false\n\n# Enable all warnings\n# Warnings should be treated as errors in CI\n```\n\n**Never ignore warnings:**\n\n```solidity\n// ‚ùå BAD\npragma solidity ^0.8.20;\n// pragma abicoder v2;  // Warning ignored\n\n// ‚úÖ GOOD - Fix the warning\npragma solidity ^0.8.20;\npragma abicoder v2;  // Explicitly enable if needed\n```\n\n### 2. Solhint / Slither\n\n**Configuration:** `.solhint.json`\n\n```json\n{\n  \"extends\": \"solhint:recommended\",\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-console\": \"error\",\n    \"compiler-version\": \"error\"\n  }\n}\n```\n\n**Never suppress linter errors:**\n\n```solidity\n// ‚ùå BAD\n// solhint-disable-next-line no-unused-vars\nfunction unusedFunction() external {\n    // ...\n}\n\n// ‚úÖ GOOD - Remove unused code or use it\nfunction usedFunction() external {\n    // Actually use the function\n}\n```\n\n### 3. Foundry\n\n**Never skip tests or ignore failures:**\n\n```bash\n# ‚ùå BAD - Ignoring test failures\nforge test || true\n\n# ‚úÖ GOOD - Fix failing tests\nforge test  # Must pass\n```\n\n## Common Scenarios\n\n### Unused Variables\n\n```solidity\n// ‚ùå BAD\nfunction process(uint256 amount) external {\n    uint256 unused = 100;  // Unused variable\n    // ...\n}\n\n// ‚úÖ GOOD - Remove if unused, or use it\nfunction process(uint256 amount) external {\n    uint256 threshold = 100;  // Actually use it\n    require(amount > threshold, \"Amount too low\");\n}\n\n// ‚úÖ GOOD - Use underscore for intentionally unused\nfunction process(uint256 amount) external {\n    uint256 _unused = 100;  // Intentionally unused\n    // ...\n}\n```\n\n### Compiler Warnings\n\n```solidity\n// ‚ùå BAD - Suppressing warning\npragma solidity ^0.8.20;\n// pragma experimental ABIEncoderV2;  // Warning suppressed\n\n// ‚úÖ GOOD - Fix the warning\npragma solidity ^0.8.20;\n// Use ABIEncoderV2 only if needed, otherwise remove\n```\n\n### Type Errors\n\n```solidity\n// ‚ùå BAD - Using assembly to bypass type checking\nfunction unsafeCast() external {\n    assembly {\n        let x := 0x1234\n        // Bypassing type checks\n    }\n}\n\n// ‚úÖ GOOD - Use proper types\nfunction safeCast() external pure returns (uint256) {\n    return uint256(0x1234);\n}\n```\n\n### Security Issues\n\n```solidity\n// ‚ùå BAD - Ignoring security warnings\nfunction withdraw() external {\n    // solhint-disable-next-line reentrancy\n    (bool success, ) = msg.sender.call{value: balances[msg.sender]}(\"\");\n    balances[msg.sender] = 0;\n}\n\n// ‚úÖ GOOD - Fix security issue\nfunction withdraw() external nonReentrant {\n    uint256 amount = balances[msg.sender];\n    balances[msg.sender] = 0;  // Effects first\n    (bool success, ) = msg.sender.call{value: amount}(\"\");  // Interactions last\n    require(success, \"Transfer failed\");\n}\n```\n\n## Pre-commit Hooks\n\nEnsure pre-commit hooks run and **fail** if there are errors:\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: forge-fmt\n        name: forge fmt\n        entry: forge fmt --check\n        language: system\n        pass_filenames: false\n        always_run: true\n        fail_fast: true\n      \n      - id: forge-build\n        name: forge build\n        entry: forge build\n        language: system\n        pass_filenames: false\n        always_run: true\n        fail_fast: true\n```\n\n## CI/CD Integration\n\n**Never allow errors in CI:**\n\n```yaml\n# .github/workflows/ci.yml\n- name: Build contracts\n  run: forge build\n  # Should fail if there are warnings/errors\n\n- name: Run tests\n  run: forge test\n  # Should fail if tests don't pass\n\n- name: Check formatting\n  run: forge fmt --check\n  # Should fail if code is not formatted\n```\n\n## Security Considerations\n\n### Never Suppress Security Warnings\n\n```solidity\n// ‚ùå BAD - Suppressing security warning\n// solhint-disable-next-line reentrancy\nfunction withdraw() external {\n    // Vulnerable code\n}\n\n// ‚úÖ GOOD - Fix security issue\nfunction withdraw() external nonReentrant {\n    // Secure implementation\n}\n```\n\n## Remember\n\n- **Fix, Don't Suppress** - Always fix the underlying issue\n- **No Suppression Comments** - Never use solhint-disable or similar\n- **Compiler Warnings** - Treat warnings as errors\n- **Security First** - Never suppress security warnings\n- **Pre-commit** - Let hooks catch errors before commit\n- **CI/CD** - Fail builds on warnings/errors\n- **Code Quality** - Maintain high standards always\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "performance-guidelines",
          "title": "Performance Guidelines",
          "fileName": "performance-guidelines.mdc",
          "frontmatter": {
            "description": "Gas optimization and performance best practices for Solidity smart contracts",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Performance Guidelines\n\n## Philosophy\n\nGas optimization is important but **never at the expense of security or code clarity**. Optimize gas usage while maintaining security, readability, and maintainability.\n\n## Gas Costs Overview\n\nUnderstanding gas costs helps optimize:\n\n- **Storage Operations:**\n  - SSTORE (write): 20,000 gas (first time), 5,000 gas (update), 2,900 gas (delete)\n  - SLOAD (read): 2,100 gas\n- **Memory Operations:**\n  - Memory expansion: 3 gas per word\n- **Calldata:**\n  - Calldata: 4 gas per byte (non-zero), 16 gas per byte (zero)\n- **External Calls:**\n  - CALL: 2,100 gas base + gas for execution\n- **Events:**\n  - LOG0: 375 gas base + 375 per topic + 8 per byte data\n\n## Storage Optimization\n\n### 1. Pack Structs\n\nPack struct members to fit in single storage slot:\n\n```solidity\n// ‚ùå BAD - Wastes storage slots\nstruct User {\n    uint128 balance;      // Slot 1 (uses 128 bits)\n    uint256 timestamp;    // Slot 2 (uses 256 bits)\n    bool active;          // Slot 3 (uses 8 bits)\n}\n// Total: 3 storage slots\n\n// ‚úÖ GOOD - Packed efficiently\nstruct User {\n    uint128 balance;      // Slot 1 (128 bits)\n    uint64 timestamp;     // Slot 1 (64 bits)\n    bool active;          // Slot 1 (8 bits)\n    // Total: 1 storage slot (256 bits)\n}\n// Total: 1 storage slot\n\n// ‚úÖ GOOD - Packed with uint256\nstruct User {\n    uint128 balance;      // Slot 1 (128 bits)\n    uint128 timestamp;    // Slot 1 (128 bits)\n    bool active;          // Slot 2 (8 bits)\n    address owner;        // Slot 2 (160 bits)\n    // Total: 2 storage slots\n}\n```\n\n### 2. Use Immutable Variables\n\nImmutable variables are stored in bytecode, not storage:\n\n```solidity\n// ‚úÖ GOOD - Immutable (stored in bytecode)\ncontract Token {\n    address public immutable owner;\n    uint256 public immutable maxSupply;\n    \n    constructor(address _owner, uint256 _maxSupply) {\n        owner = _owner;\n        maxSupply = _maxSupply;\n    }\n}\n\n// ‚ùå BAD - Storage variable\ncontract Token {\n    address public owner;\n    uint256 public maxSupply;\n    \n    constructor(address _owner, uint256 _maxSupply) {\n        owner = _owner;\n        maxSupply = _maxSupply;\n    }\n}\n```\n\n### 3. Cache Storage Reads\n\nCache storage reads in loops:\n\n```solidity\n// ‚ùå BAD - Multiple storage reads\nfunction processUsers() external {\n    for (uint256 i = 0; i < users.length; i++) {\n        balances[users[i]] += 1;  // Storage read + write per iteration\n    }\n}\n\n// ‚úÖ GOOD - Cache storage reads\nfunction processUsers() external {\n    uint256 userCount = users.length;  // Cache length\n    for (uint256 i = 0; i < userCount; i++) {\n        address user = users[i];  // Cache array read\n        balances[user] += 1;  // Single storage operation\n    }\n}\n\n// ‚úÖ GOOD - Cache complex storage reads\nfunction updateBalances() external {\n    uint256 senderBalance = balances[msg.sender];  // Cache read\n    uint256 recipientBalance = balances[recipient];  // Cache read\n    \n    senderBalance -= amount;\n    recipientBalance += amount;\n    \n    balances[msg.sender] = senderBalance;  // Single write\n    balances[recipient] = recipientBalance;  // Single write\n}\n```\n\n### 4. Use Events Instead of Storage for Logs\n\nEvents are cheaper than storage for logging:\n\n```solidity\n// ‚ùå BAD - Storage for logging\nmapping(address => uint256[]) public transferHistory;\n\nfunction transfer(address to, uint256 amount) external {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    transferHistory[msg.sender].push(amount);  // Expensive storage write\n}\n\n// ‚úÖ GOOD - Events for logging\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction transfer(address to, uint256 amount) external {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);  // Cheaper event\n}\n```\n\n## Memory Optimization\n\n### 1. Use Calldata for External Functions\n\nCalldata is cheaper than memory:\n\n```solidity\n// ‚úÖ GOOD - Calldata for external functions\nfunction processData(bytes calldata data) external {\n    // data is in calldata (cheaper)\n}\n\n// ‚ùå BAD - Memory for external functions\nfunction processData(bytes memory data) external {\n    // data copied to memory (more expensive)\n}\n\n// ‚úÖ GOOD - Memory for internal functions\nfunction processDataInternal(bytes memory data) internal {\n    // Memory is fine for internal functions\n}\n```\n\n### 2. Reuse Memory\n\nReuse memory arrays when possible:\n\n```solidity\n// ‚úÖ GOOD - Reuse memory\nfunction processBatch(uint256[] calldata input) external pure returns (uint256[] memory) {\n    uint256[] memory result = new uint256[](input.length);\n    for (uint256 i = 0; i < input.length; i++) {\n        result[i] = input[i] * 2;\n    }\n    return result;\n}\n```\n\n### 3. Avoid Unnecessary Memory Copies\n\n```solidity\n// ‚ùå BAD - Unnecessary copy\nfunction process(uint256[] memory data) external {\n    uint256[] memory copy = data;  // Unnecessary copy\n    // ...\n}\n\n// ‚úÖ GOOD - Use directly\nfunction process(uint256[] memory data) external {\n    // Use data directly\n    // ...\n}\n```\n\n## Loop Optimization\n\n### 1. Cache Array Length\n\n```solidity\n// ‚ùå BAD - Read length in each iteration\nfunction processArray(uint256[] memory array) external {\n    for (uint256 i = 0; i < array.length; i++) {  // Length read each iteration\n        // ...\n    }\n}\n\n// ‚úÖ GOOD - Cache length\nfunction processArray(uint256[] memory array) external {\n    uint256 length = array.length;  // Cache length\n    for (uint256 i = 0; i < length; i++) {\n        // ...\n    }\n}\n```\n\n### 2. Unchecked Arithmetic in Loops\n\nUse unchecked blocks when overflow is impossible:\n\n```solidity\n// ‚úÖ GOOD - Unchecked increment (safe in loops)\nfunction processArray(uint256[] memory array) external {\n    uint256 length = array.length;\n    for (uint256 i = 0; i < length;) {\n        // Process array[i]\n        unchecked {\n            i++;  // Safe: i < length, so i++ won't overflow\n        }\n    }\n}\n```\n\n### 3. Batch Operations\n\nBatch operations reduce external calls:\n\n```solidity\n// ‚ùå BAD - Multiple external calls\nfunction transferMultiple(address[] calldata recipients, uint256[] calldata amounts) external {\n    for (uint256 i = 0; i < recipients.length; i++) {\n        transfer(recipients[i], amounts[i]);  // External call per iteration\n    }\n}\n\n// ‚úÖ GOOD - Single function with batching\nfunction transferMultiple(address[] calldata recipients, uint256[] calldata amounts) external {\n    require(recipients.length == amounts.length, \"Arrays length mismatch\");\n    \n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < amounts.length; i++) {\n        totalAmount += amounts[i];\n    }\n    \n    require(balances[msg.sender] >= totalAmount, \"Insufficient balance\");\n    balances[msg.sender] -= totalAmount;\n    \n    for (uint256 i = 0; i < recipients.length; i++) {\n        balances[recipients[i]] += amounts[i];\n    }\n}\n```\n\n## Function Optimization\n\n### 1. Minimize External Calls\n\n```solidity\n// ‚ùå BAD - Multiple external calls\nfunction getTotalBalance(address[] calldata tokens) external view returns (uint256) {\n    uint256 total = 0;\n    for (uint256 i = 0; i < tokens.length; i++) {\n        total += IERC20(tokens[i]).balanceOf(address(this));  // External call per iteration\n    }\n    return total;\n}\n\n// ‚úÖ GOOD - Batch external calls if possible\n// Or cache results if called multiple times\n```\n\n### 2. Use View/Pure When Possible\n\n```solidity\n// ‚úÖ GOOD - Pure function (no storage access)\nfunction calculate(uint256 a, uint256 b) public pure returns (uint256) {\n    return a + b;\n}\n\n// ‚úÖ GOOD - View function (read-only)\nfunction getBalance(address account) public view returns (uint256) {\n    return balances[account];\n}\n```\n\n### 3. Short-Circuit Evaluation\n\n```solidity\n// ‚úÖ GOOD - Short-circuit evaluation\nfunction canTransfer(address from, address to, uint256 amount) external view returns (bool) {\n    return from != address(0) && \n           to != address(0) && \n           balances[from] >= amount;\n    // If first condition fails, rest not evaluated\n}\n```\n\n## Compiler Optimization\n\n### Foundry Configuration\n\n```toml\n[profile.default]\noptimizer = true\noptimizer_runs = 200  # Balance between gas and bytecode size\nvia_ir = false  # Use IR-based codegen for complex contracts if needed\n```\n\n### Optimizer Runs\n\n- **Low (100-200):** Smaller bytecode, slightly more gas\n- **Medium (200-1000):** Balance\n- **High (1000+):** More gas optimization, larger bytecode\n\n## Gas Profiling\n\n### Using Foundry Gas Reports\n\n```bash\n# Generate gas report\nforge test --gas-report\n\n# Snapshot gas in tests\nfunction test_Gas_Transfer() public {\n    snapStart(\"transfer\");\n    token.transfer(address(1), 100);\n    snapEnd();\n}\n```\n\n### Manual Gas Measurement\n\n```solidity\nfunction test_Gas() public {\n    uint256 gasBefore = gasleft();\n    token.transfer(address(1), 100);\n    uint256 gasUsed = gasBefore - gasleft();\n    console.log(\"Gas used:\", gasUsed);\n}\n```\n\n## Best Practices\n\n### 1. Profile Before Optimizing\n\n```solidity\n// Always measure gas before optimizing\n// Use forge test --gas-report\n// Optimize hotspots, not everything\n```\n\n### 2. Balance Gas vs Readability\n\n```solidity\n// ‚úÖ GOOD - Readable and efficient\nfunction transfer(address to, uint256 amount) external {\n    require(to != address(0), \"Invalid recipient\");\n    uint256 senderBalance = balances[msg.sender];\n    require(senderBalance >= amount, \"Insufficient balance\");\n    \n    balances[msg.sender] = senderBalance - amount;\n    balances[to] += amount;\n}\n\n// ‚ùå BAD - Over-optimized, hard to read\nfunction transfer(address to, uint256 amount) external {\n    unchecked {\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n}\n```\n\n### 3. Use Libraries for Reusable Code\n\n```solidity\n// ‚úÖ GOOD - Library for reusable code\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n\ncontract Token {\n    using Math for uint256;\n    \n    function getMax(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.max(b);\n    }\n}\n```\n\n### 4. Avoid Unnecessary Operations\n\n```solidity\n// ‚ùå BAD - Unnecessary operation\nfunction getBalance(address account) external view returns (uint256) {\n    return balances[account] + 0;  // Unnecessary addition\n}\n\n// ‚úÖ GOOD - Direct return\nfunction getBalance(address account) external view returns (uint256) {\n    return balances[account];\n}\n```\n\n## Gas Optimization Checklist\n\nBefore deploying, consider:\n\n- [ ] Structs packed efficiently\n- [ ] Immutable variables used where possible\n- [ ] Storage reads cached in loops\n- [ ] Events used instead of storage for logs\n- [ ] Calldata used for external function parameters\n- [ ] Array lengths cached\n- [ ] Unchecked blocks used where safe\n- [ ] Batch operations implemented\n- [ ] External calls minimized\n- [ ] View/pure functions used appropriately\n- [ ] Compiler optimizer enabled\n- [ ] Gas profiling performed\n\n## Remember\n\n- **Profile First** - Measure before optimizing\n- **Security First** - Never optimize at expense of security\n- **Readability Matters** - Don't over-optimize\n- **Cache Storage** - Especially in loops\n- **Pack Structs** - Reduce storage slots\n- **Use Immutable** - For constants\n- **Events Over Storage** - For logging\n- **Batch Operations** - Reduce external calls\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "security-guidelines",
          "title": "Security Guidelines",
          "fileName": "security-guidelines.mdc",
          "frontmatter": {
            "description": "Security best practices and vulnerability prevention for Solidity smart contracts",
            "globs": [
              "**/*.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Security Guidelines\n\n## Critical Importance\n\n**Security is the highest priority in smart contract development.** A single vulnerability can result in the loss of all funds. Always prioritize security over gas optimization or convenience.\n\n## Common Vulnerabilities\n\n### 1. Reentrancy Attacks\n\n**The Problem:** External calls can call back into your contract before state updates complete.\n\n**The Solution:** Use Checks-Effects-Interactions pattern and ReentrancyGuard.\n\n```solidity\n// ‚ùå BAD - Vulnerable to reentrancy\ncontract Vulnerable {\n    mapping(address => uint256) public balances;\n    \n    function withdraw() external {\n        uint256 amount = balances[msg.sender];\n        (bool success, ) = msg.sender.call{value: amount}(\"\");  // External call before state update\n        require(success, \"Transfer failed\");\n        balances[msg.sender] = 0;  // State update after external call\n    }\n}\n\n// ‚úÖ GOOD - Checks-Effects-Interactions pattern\ncontract Secure {\n    mapping(address => uint256) public balances;\n    bool private locked;\n    \n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    function withdraw() external nonReentrant {\n        uint256 amount = balances[msg.sender];  // CHECK\n        require(amount > 0, \"No balance\");\n        \n        balances[msg.sender] = 0;  // EFFECTS (state update first)\n        \n        (bool success, ) = msg.sender.call{value: amount}(\"\");  // INTERACTIONS (external call last)\n        require(success, \"Transfer failed\");\n    }\n}\n\n// ‚úÖ GOOD - Using OpenZeppelin ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureWithGuard is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n    \n    function withdraw() external nonReentrant {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"No balance\");\n        \n        balances[msg.sender] = 0;  // Effects\n        \n        (bool success, ) = msg.sender.call{value: amount}(\"\");  // Interactions\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 2. Access Control\n\n**The Problem:** Functions can be called by unauthorized users.\n\n**The Solution:** Implement proper access control.\n\n```solidity\n// ‚ùå BAD - No access control\ncontract Vulnerable {\n    address public admin;\n    \n    function setAdmin(address newAdmin) external {\n        admin = newAdmin;  // Anyone can call this!\n    }\n}\n\n// ‚úÖ GOOD - Using Ownable\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Secure is Ownable {\n    function setAdmin(address newAdmin) external onlyOwner {\n        // Only owner can call\n    }\n}\n\n// ‚úÖ GOOD - Custom access control\ncontract SecureCustom {\n    address public owner;\n    mapping(address => bool) public authorized;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    modifier onlyAuthorized() {\n        require(authorized[msg.sender], \"Not authorized\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function setAuthorized(address account, bool status) external onlyOwner {\n        authorized[account] = status;\n    }\n}\n```\n\n### 3. Integer Overflow/Underflow\n\n**The Problem:** Arithmetic operations can overflow/underflow (pre-0.8.0).\n\n**The Solution:** Use Solidity 0.8.0+ (automatic checks) or SafeMath.\n\n```solidity\n// ‚úÖ GOOD - Solidity 0.8.0+ automatically checks overflow\npragma solidity ^0.8.20;\n\ncontract Secure {\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\n        return a + b;  // Automatically reverts on overflow\n    }\n}\n\n// ‚úÖ GOOD - For pre-0.8.0, use SafeMath\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SecureLegacy {\n    using SafeMath for uint256;\n    \n    function add(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.add(b);  // SafeMath prevents overflow\n    }\n}\n\n// ‚úÖ GOOD - Unchecked blocks when overflow is impossible\nfunction increment(uint256 x) external pure returns (uint256) {\n    unchecked {\n        return x + 1;  // Safe: x + 1 won't overflow in practice\n    }\n}\n```\n\n### 4. Front-Running\n\n**The Problem:** Transactions can be front-run by miners or bots.\n\n**The Solution:** Use commit-reveal schemes or access lists.\n\n```solidity\n// ‚úÖ GOOD - Commit-reveal scheme\ncontract SecureAuction {\n    mapping(address => bytes32) public commitments;\n    mapping(address => uint256) public revealedBids;\n    bool public biddingEnded;\n    \n    function commitBid(bytes32 commitment) external {\n        require(!biddingEnded, \"Bidding ended\");\n        commitments[msg.sender] = commitment;\n    }\n    \n    function revealBid(uint256 bid, bytes32 salt) external {\n        require(biddingEnded, \"Bidding not ended\");\n        require(\n            keccak256(abi.encodePacked(bid, salt, msg.sender)) == commitments[msg.sender],\n            \"Invalid commitment\"\n        );\n        revealedBids[msg.sender] = bid;\n    }\n}\n```\n\n### 5. Denial of Service (DoS)\n\n**The Problem:** Loops can consume all gas or fail if array grows too large.\n\n**The Solution:** Limit array sizes, use pagination, or avoid loops.\n\n```solidity\n// ‚ùå BAD - DoS vulnerability\ncontract Vulnerable {\n    address[] public users;\n    \n    function distributeRewards() external {\n        for (uint256 i = 0; i < users.length; i++) {\n            // If users array is too large, this will fail\n            transferReward(users[i]);\n        }\n    }\n}\n\n// ‚úÖ GOOD - Limit array size or use pagination\ncontract Secure {\n    address[] public users;\n    uint256 public constant MAX_USERS = 100;\n    \n    function addUser(address user) external {\n        require(users.length < MAX_USERS, \"Too many users\");\n        users.push(user);\n    }\n    \n    function distributeRewards(uint256 startIndex, uint256 endIndex) external {\n        require(endIndex <= users.length, \"Invalid range\");\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            transferReward(users[i]);\n        }\n    }\n}\n```\n\n### 6. Unchecked External Calls\n\n**The Problem:** External calls can fail silently or consume all gas.\n\n**The Solution:** Always check return values and use low-level calls carefully.\n\n```solidity\n// ‚ùå BAD - Unchecked external call\ncontract Vulnerable {\n    function transferTokens(address token, address to, uint256 amount) external {\n        IERC20(token).transfer(to, amount);  // May fail silently\n    }\n}\n\n// ‚úÖ GOOD - Check return value\ncontract Secure {\n    function transferTokens(address token, address to, uint256 amount) external {\n        bool success = IERC20(token).transfer(to, amount);\n        require(success, \"Transfer failed\");\n    }\n}\n\n// ‚úÖ GOOD - Low-level call with proper handling\nfunction sendEther(address payable recipient, uint256 amount) external {\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Ether transfer failed\");\n}\n\n// ‚úÖ GOOD - Using SafeERC20\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SecureWithSafeERC20 {\n    using SafeERC20 for IERC20;\n    \n    function transferTokens(address token, address to, uint256 amount) external {\n        IERC20(token).safeTransfer(to, amount);  // Reverts on failure\n    }\n}\n```\n\n### 7. Timestamp Dependence\n\n**The Problem:** Block timestamps can be manipulated by miners.\n\n**The Solution:** Avoid strict equality checks, use ranges.\n\n```solidity\n// ‚ùå BAD - Exact timestamp check\ncontract Vulnerable {\n    function canWithdraw() external view returns (bool) {\n        return block.timestamp == 1000;  // Miners can manipulate\n    }\n}\n\n// ‚úÖ GOOD - Range-based checks\ncontract Secure {\n    uint256 public constant LOCK_DURATION = 30 days;\n    uint256 public lockTime;\n    \n    function canWithdraw() external view returns (bool) {\n        return block.timestamp >= lockTime + LOCK_DURATION;\n    }\n}\n```\n\n### 8. Random Number Generation\n\n**The Problem:** Block variables are predictable.\n\n**The Solution:** Use Chainlink VRF or commit-reveal schemes.\n\n```solidity\n// ‚ùå BAD - Predictable randomness\ncontract Vulnerable {\n    function random() external view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\n    }\n}\n\n// ‚úÖ GOOD - Using Chainlink VRF\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract Secure is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    \n    function requestRandomness() external returns (bytes32 requestId) {\n        return requestRandomness(keyHash, fee);\n    }\n}\n```\n\n### 9. Gas Limit DoS\n\n**The Problem:** Loops can consume all gas.\n\n**The Solution:** Limit loop iterations, use pagination.\n\n```solidity\n// ‚ùå BAD - Unbounded loop\ncontract Vulnerable {\n    function processAll() external {\n        for (uint256 i = 0; i < items.length; i++) {\n            processItem(items[i]);  // May consume all gas\n        }\n    }\n}\n\n// ‚úÖ GOOD - Bounded processing\ncontract Secure {\n    uint256 public constant MAX_BATCH_SIZE = 50;\n    \n    function processBatch(uint256 startIndex, uint256 endIndex) external {\n        require(endIndex - startIndex <= MAX_BATCH_SIZE, \"Batch too large\");\n        require(endIndex <= items.length, \"Invalid range\");\n        \n        for (uint256 i = startIndex; i < endIndex; i++) {\n            processItem(items[i]);\n        }\n    }\n}\n```\n\n### 10. Signature Replay Attacks\n\n**The Problem:** Signatures can be reused across chains or contracts.\n\n**The Solution:** Include chain ID and contract address in signature.\n\n```solidity\n// ‚úÖ GOOD - Include chain ID and contract address\ncontract Secure {\n    function verifySignature(\n        address signer,\n        bytes32 messageHash,\n        bytes memory signature,\n        uint256 nonce\n    ) external view returns (bool) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(abi.encode(messageHash, nonce, address(this), block.chainid))\n            )\n        );\n        return recover(hash, signature) == signer;\n    }\n    \n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(\"MyContract\"),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n}\n```\n\n## Security Best Practices\n\n### 1. Input Validation\n\nAlways validate inputs:\n\n```solidity\n// ‚úÖ GOOD - Validate all inputs\nfunction transfer(address to, uint256 amount) external {\n    require(to != address(0), \"Invalid recipient\");\n    require(amount > 0, \"Amount must be positive\");\n    require(balances[msg.sender] >= amount, \"Insufficient balance\");\n    \n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}\n```\n\n### 2. Use Safe Libraries\n\nPrefer battle-tested libraries:\n\n```solidity\n// ‚úÖ GOOD - Use OpenZeppelin\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n```\n\n### 3. Minimize External Calls\n\nReduce attack surface:\n\n```solidity\n// ‚úÖ GOOD - Minimize external calls\nfunction batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {\n    require(recipients.length == amounts.length, \"Arrays length mismatch\");\n    \n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < amounts.length; i++) {\n        totalAmount += amounts[i];\n    }\n    \n    require(balances[msg.sender] >= totalAmount, \"Insufficient balance\");\n    balances[msg.sender] -= totalAmount;\n    \n    for (uint256 i = 0; i < recipients.length; i++) {\n        balances[recipients[i]] += amounts[i];\n    }\n}\n```\n\n### 4. Events for Important Actions\n\nEmit events for all important state changes:\n\n```solidity\n// ‚úÖ GOOD - Emit events\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction transfer(address to, uint256 amount) external {\n    // ... transfer logic ...\n    emit Transfer(msg.sender, to, amount);\n}\n```\n\n### 5. Use Custom Errors\n\nGas-efficient error handling:\n\n```solidity\n// ‚úÖ GOOD - Custom errors\nerror InsufficientBalance(uint256 required, uint256 available);\nerror InvalidAddress(address provided);\n\nfunction withdraw(uint256 amount) external {\n    if (balances[msg.sender] < amount) {\n        revert InsufficientBalance(amount, balances[msg.sender]);\n    }\n    // ...\n}\n```\n\n## Security Checklist\n\nBefore deploying, verify:\n\n- [ ] All external calls use Checks-Effects-Interactions pattern\n- [ ] ReentrancyGuard used where needed\n- [ ] Access control implemented correctly\n- [ ] Input validation on all user inputs\n- [ ] Integer overflow/underflow handled (or using 0.8.0+)\n- [ ] Unbounded loops avoided or limited\n- [ ] Timestamp dependence minimized\n- [ ] Random number generation secure\n- [ ] Events emitted for important actions\n- [ ] Custom errors used instead of require strings\n- [ ] External dependencies audited\n- [ ] Code reviewed by multiple developers\n- [ ] Tests cover edge cases and attack vectors\n- [ ] Gas limits considered\n- [ ] Upgradeability patterns secure (if applicable)\n\n## Remember\n\n- **Security First** - Never compromise security for gas or convenience\n- **Test Thoroughly** - Test all attack vectors\n- **Use Audited Libraries** - Prefer OpenZeppelin and other audited code\n- **Code Review** - Always have code reviewed\n- **Stay Updated** - Keep dependencies updated\n- **Audit Before Mainnet** - Professional audit for production contracts\n",
          "alwaysApply": true,
          "globs": [
            "**/*.sol"
          ]
        },
        {
          "id": "testing",
          "title": "Testing",
          "fileName": "testing.mdc",
          "frontmatter": {
            "description": "Testing philosophy and patterns for Solidity Foundry codebase",
            "globs": [
              "**/test/**",
              "**/*.t.sol"
            ],
            "alwaysApply": true
          },
          "content": "# Testing Guidelines\n\n## Testing Philosophy\n\nOur testing strategy focuses on **comprehensive coverage of all contract functionality, edge cases, and attack vectors**. We prioritize testing at multiple levels to ensure security, correctness, and gas efficiency.\n\n### Core Principles\n\n1. **Test All Public/External Functions** - Every public/external function must have tests\n2. **Test Edge Cases** - Boundary conditions, zero values, maximum values\n3. **Test Attack Vectors** - Reentrancy, overflow, access control, etc.\n4. **Test Gas Efficiency** - Track gas usage with snapshots\n5. **Fuzz Testing** - Use Foundry's fuzzing for input validation\n6. **Invariant Testing** - Test system invariants that should always hold\n7. **Fork Testing** - Test against mainnet state when needed\n\n## Testing Stack\n\n- **Framework:** [Foundry Test Suite](https://book.getfoundry.sh/forge/tests) (Forge)\n- **Base Contract:** `forge-std/Test.sol`\n- **Fuzzing:** Built-in fuzz testing\n- **Invariant Testing:** Foundry invariant testing\n- **Forking:** Mainnet/testnet fork testing\n- **Gas Reporting:** Built-in gas snapshots\n\n## Test Structure\n\n### Basic Test File\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/MyContract.sol\";\n\ncontract MyContractTest is Test {\n    MyContract public myContract;\n    address public user = address(1);\n    address public owner = address(2);\n    \n    function setUp() public {\n        myContract = new MyContract();\n    }\n    \n    function test_BasicFunctionality() public {\n        // Arrange\n        uint256 expectedValue = 100;\n        \n        // Act\n        myContract.setValue(expectedValue);\n        \n        // Assert\n        assertEq(myContract.getValue(), expectedValue);\n    }\n}\n```\n\n### Test Organization\n\nTests should mirror contract structure:\n\n```\ntest/\n‚îú‚îÄ‚îÄ MyContract.t.sol          # Main contract tests\n‚îú‚îÄ‚îÄ MyContractFuzz.t.sol      # Fuzz tests\n‚îú‚îÄ‚îÄ MyContractInvariant.t.sol  # Invariant tests\n‚îî‚îÄ‚îÄ mocks/\n    ‚îî‚îÄ‚îÄ MockERC20.sol          # Mock contracts\n```\n\n## Test Types\n\n### 1. Unit Tests\n\nTest individual functions in isolation:\n\n```solidity\ncontract TokenTest is Test {\n    Token public token;\n    address public user = address(1);\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function test_Transfer() public {\n        // Arrange\n        uint256 amount = 100;\n        address recipient = address(2);\n        \n        // Act\n        token.transfer(recipient, amount);\n        \n        // Assert\n        assertEq(token.balanceOf(recipient), amount);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n    \n    function test_Transfer_InsufficientBalance() public {\n        // Arrange\n        uint256 amount = 1000;\n        address recipient = address(2);\n        \n        // Act & Assert\n        vm.expectRevert(Token.InsufficientBalance.selector);\n        token.transfer(recipient, amount);\n    }\n}\n```\n\n### 2. Integration Tests\n\nTest interactions between contracts:\n\n```solidity\ncontract IntegrationTest is Test {\n    Token public token;\n    StakingContract public staking;\n    \n    function setUp() public {\n        token = new Token();\n        staking = new StakingContract(address(token));\n    }\n    \n    function test_StakeTokens() public {\n        // Arrange\n        uint256 amount = 1000;\n        token.mint(address(this), amount);\n        token.approve(address(staking), amount);\n        \n        // Act\n        staking.stake(amount);\n        \n        // Assert\n        assertEq(staking.stakedBalance(address(this)), amount);\n        assertEq(token.balanceOf(address(staking)), amount);\n    }\n}\n```\n\n### 3. Fuzz Tests\n\nTest with random inputs:\n\n```solidity\ncontract TokenFuzzTest is Test {\n    Token public token;\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function testFuzz_Transfer(uint256 amount, address recipient) public {\n        // Arrange - Bound inputs\n        amount = bound(amount, 1, type(uint256).max);\n        recipient = address(uint160(uint256(keccak256(abi.encodePacked(recipient)))));\n        vm.assume(recipient != address(0));\n        \n        // Mint tokens\n        token.mint(address(this), amount);\n        \n        // Act\n        token.transfer(recipient, amount);\n        \n        // Assert\n        assertEq(token.balanceOf(recipient), amount);\n    }\n    \n    function testFuzz_Transfer_RevertsOnInsufficientBalance(uint256 balance, uint256 amount) public {\n        // Arrange\n        balance = bound(balance, 0, type(uint256).max - 1);\n        amount = bound(amount, balance + 1, type(uint256).max);\n        \n        token.mint(address(this), balance);\n        \n        // Act & Assert\n        vm.expectRevert(Token.InsufficientBalance.selector);\n        token.transfer(address(1), amount);\n    }\n}\n```\n\n### 4. Invariant Tests\n\nTest system invariants:\n\n```solidity\ncontract TokenInvariantTest is Test {\n    Token public token;\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function invariant_TotalSupplyEqualsSumOfBalances() public {\n        uint256 totalSupply = token.totalSupply();\n        uint256 sumOfBalances = 0;\n        \n        // Sum all balances (simplified - in practice, track known addresses)\n        // This is a simplified example\n        assertEq(totalSupply, sumOfBalances);\n    }\n    \n    function invariant_NoNegativeBalances() public view {\n        // This should always hold - balances can't be negative\n        // Test with various addresses\n    }\n}\n```\n\n### 5. Fork Tests\n\nTest against mainnet state:\n\n```solidity\ncontract ForkTest is Test {\n    IERC20 public dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    \n    function setUp() public {\n        vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"));\n    }\n    \n    function test_Fork_DaiBalance() public {\n        address holder = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n        uint256 balance = dai.balanceOf(holder);\n        assertGt(balance, 0);\n    }\n}\n```\n\n## Test Helpers\n\n### Cheatcodes\n\nFoundry provides cheatcodes via `vm`:\n\n```solidity\ncontract CheatcodeExamples is Test {\n    function test_TimeManipulation() public {\n        // Warp time\n        vm.warp(block.timestamp + 1 days);\n        \n        // Roll block number\n        vm.roll(block.number + 100);\n        \n        // Set block timestamp\n        vm.timestamp(1640995200);\n    }\n    \n    function test_AddressManipulation() public {\n        // Prank (impersonate address)\n        vm.prank(address(1));\n        // Next call will be from address(1)\n        \n        // Start prank (persistent)\n        vm.startPrank(address(1));\n        // All calls will be from address(1)\n        vm.stopPrank();\n        \n        // Deal (give ETH)\n        vm.deal(address(1), 100 ether);\n        \n        // Label addresses for better traces\n        vm.label(address(1), \"User\");\n    }\n    \n    function test_ExpectRevert() public {\n        // Expect specific error\n        vm.expectRevert(Token.InsufficientBalance.selector);\n        token.transfer(address(1), 1000);\n        \n        // Expect revert with message\n        vm.expectRevert(\"Insufficient balance\");\n        token.transfer(address(1), 1000);\n        \n        // Expect revert with custom error\n        vm.expectRevert(\n            abi.encodeWithSelector(Token.InsufficientBalance.selector, 1000, 100)\n        );\n        token.transfer(address(1), 1000);\n    }\n    \n    function test_ExpectEmit() public {\n        // Expect event emission\n        vm.expectEmit(true, true, false, true);\n        emit Transfer(address(this), address(1), 100);\n        token.transfer(address(1), 100);\n    }\n    \n    function test_RecordLogs() public {\n        // Record logs\n        vm.recordLogs();\n        token.transfer(address(1), 100);\n        Vm.Log[] memory logs = vm.getRecordedLogs();\n        \n        // Assert log\n        assertEq(logs.length, 1);\n    }\n}\n```\n\n### Fixtures\n\nCreate reusable test fixtures:\n\n```solidity\ncontract TestFixtures is Test {\n    Token public token;\n    address public owner;\n    address public user1;\n    address public user2;\n    \n    function setUp() public {\n        owner = address(this);\n        user1 = address(1);\n        user2 = address(2);\n        \n        token = new Token();\n        token.mint(owner, 10000);\n    }\n    \n    function _mintTokens(address to, uint256 amount) internal {\n        token.mint(to, amount);\n    }\n    \n    function _transferTokens(address from, address to, uint256 amount) internal {\n        vm.prank(from);\n        token.transfer(to, amount);\n    }\n}\n```\n\n## Assertions\n\n### Standard Assertions\n\n```solidity\n// Equality\nassertEq(actual, expected);\nassertEq(actual, expected, \"Custom error message\");\n\n// Inequality\nassertNotEq(actual, expected);\n\n// Greater/Less than\nassertGt(a, b);  // a > b\nassertGe(a, b);  // a >= b\nassertLt(a, b);  // a < b\nassertLe(a, b);  // a <= b\n\n// Boolean\nassertTrue(condition);\nassertFalse(condition);\n\n// Approximate equality (for floating point)\nassertApproxEqAbs(actual, expected, maxDelta);\nassertApproxEqRel(actual, expected, maxPercentDelta);\n\n// Array equality\nassertEq(actualArray, expectedArray);\n\n// String equality\nassertEq(actualString, expectedString);\n```\n\n## Gas Testing\n\n### Gas Snapshots\n\nTrack gas usage:\n\n```solidity\ncontract GasTest is Test {\n    Token public token;\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function test_Gas_Transfer() public {\n        token.mint(address(this), 1000);\n        \n        // Snapshot gas before\n        uint256 gasBefore = gasleft();\n        token.transfer(address(1), 100);\n        uint256 gasUsed = gasBefore - gasleft();\n        \n        // Or use Foundry's snapshot\n        snapStart(\"transfer\");\n        token.transfer(address(1), 100);\n        snapEnd();\n    }\n}\n```\n\n### Gas Reporting\n\nRun tests with gas reporting:\n\n```bash\nforge test --gas-report\n```\n\n## Test Coverage\n\n### Coverage Goals\n\n- **Critical Functions:** 100% coverage\n- **Public/External Functions:** 100% coverage\n- **Edge Cases:** All boundary conditions tested\n- **Error Paths:** All revert conditions tested\n\n### View Coverage\n\n```bash\nforge coverage\n```\n\n## Best Practices\n\n### 1. Descriptive Test Names\n\n```solidity\n// ‚úÖ GOOD - Descriptive names\nfunction test_Transfer_RevertsWhenInsufficientBalance() public {\n    // ...\n}\n\nfunction test_Transfer_UpdatesBalancesCorrectly() public {\n    // ...\n}\n\n// ‚ùå BAD - Vague names\nfunction test1() public {\n    // ...\n}\n\nfunction testTransfer() public {\n    // ...\n}\n```\n\n### 2. Arrange-Act-Assert Pattern\n\n```solidity\nfunction test_Transfer() public {\n    // Arrange\n    uint256 amount = 100;\n    address recipient = address(1);\n    token.mint(address(this), amount);\n    \n    // Act\n    token.transfer(recipient, amount);\n    \n    // Assert\n    assertEq(token.balanceOf(recipient), amount);\n    assertEq(token.balanceOf(address(this)), 0);\n}\n```\n\n### 3. Test Edge Cases\n\n```solidity\nfunction test_Transfer_ZeroAmount() public {\n    token.transfer(address(1), 0);\n    assertEq(token.balanceOf(address(1)), 0);\n}\n\nfunction test_Transfer_MaxAmount() public {\n    uint256 maxAmount = type(uint256).max;\n    token.mint(address(this), maxAmount);\n    token.transfer(address(1), maxAmount);\n    assertEq(token.balanceOf(address(1)), maxAmount);\n}\n\nfunction test_Transfer_ToZeroAddress() public {\n    vm.expectRevert(Token.InvalidAddress.selector);\n    token.transfer(address(0), 100);\n}\n```\n\n### 4. Test Attack Vectors\n\n```solidity\nfunction test_ReentrancyAttack() public {\n    // Test reentrancy protection\n    ReentrancyAttacker attacker = new ReentrancyAttacker();\n    vm.expectRevert(ReentrancyGuard.ReentrantCall.selector);\n    attacker.attack();\n}\n\nfunction test_OverflowAttack() public {\n    // Test overflow protection (if using <0.8.0)\n    // In 0.8.0+, this is automatic\n}\n```\n\n### 5. Use Mocks\n\n```solidity\ncontract MockERC20 is ERC20 {\n    constructor() ERC20(\"Mock\", \"MOCK\") {}\n    \n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n```\n\n## Running Tests\n\n### Basic Commands\n\n```bash\n# Run all tests\nforge test\n\n# Run specific test\nforge test --match-test test_Transfer\n\n# Run with verbosity\nforge test -vvv\n\n# Run with gas reporting\nforge test --gas-report\n\n# Run fuzz tests\nforge test --fuzz-runs 1000\n\n# Run invariant tests\nforge test --match-contract InvariantTest\n\n# Run fork tests\nforge test --fork-url $MAINNET_RPC_URL\n```\n\n### CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Test\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: foundry-rs/foundry-toolchain@v1\n      - run: forge test\n      - run: forge coverage\n```\n\n## Remember\n\n- **Test Everything** - All public/external functions\n- **Test Edge Cases** - Zero, max, boundary values\n- **Test Attacks** - Reentrancy, overflow, access control\n- **Use Fuzzing** - Foundry's built-in fuzzing\n- **Track Gas** - Use gas snapshots\n- **Descriptive Names** - Clear test function names\n- **Arrange-Act-Assert** - Clear test structure\n- **Coverage** - Aim for 100% on critical paths\n",
          "alwaysApply": true,
          "globs": [
            "**/test/**",
            "**/*.t.sol"
          ]
        }
      ]
    },
    {
      "id": "typescript-react-nextjs",
      "name": "TypeScript-React + Nextjs",
      "directory": "Typescript-React + Nextjs",
      "icon": "icons/nextjs.png",
      "summary": "Full-stack web development with Next.js",
      "focus": "React patterns, accessibility, performance",
      "readme": "# Cursor Rules for TypeScript React Next.js Projects\n\nThis repository contains Cursor AI coding rules and guidelines for TypeScript, React, and Next.js projects. These rules help maintain consistency, code quality, and best practices across the codebase when working with AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and architectural decisions.\n\n## Overview of Rules\n\n### üìã Core Framework & Language (`core-framework-&-language.mdc`)\n\nDefines the foundational technology stack:\n\n- **Framework:** Next.js (Pages Router)\n- **Language:** TypeScript\n- **Runtime:** Node.js\n\n### üé® Frontend (`frontend.mdc`)\n\nFrontend technology stack and libraries:\n\n- **UI Library:** Chakra UI\n- **Styling:** CSS Modules, Chakra UI style props, Emotion\n- **State Management:** Zustand\n- **Data Fetching:** Standard `fetch` API with custom utilities\n- **Form Handling:** React Hook Form\n- **Drag & Drop:** React DnD\n- **Calendar:** React Calendar\n\n### üîß Backend (`backend.mdc`)\n\nBackend architecture and services:\n\n- **API Routes:** Next.js API Routes (`src/pages/api/`)\n- **Backend as a Service:** Supabase (Auth, Database, Storage)\n- **API Validation:** Yup schemas\n- **API Authentication:** Custom HOFs (`withAuthentication`, `withApiKeyAuth`, etc.)\n\n### üèóÔ∏è Key Architectural Patterns (`key-architecture-patterns.mdc`)\n\nCore architectural patterns used in the codebase:\n\n- **Service Layer:** Business logic in `src/services/`\n- **Utility Functions:** Reusable functions in `src/utils/`\n- **Modular Components:** Feature-specific components in `src/components/modules/`\n- **Registry Pattern:** Dynamic component/executor management\n\n### üí¨ Commenting Guidelines (`commenting-guidelines.mdc`)\n\nComprehensive JSDoc commenting standards:\n\n- **Format:** JSDoc (`/** ... */`) for multi-line comments\n- **Focus:** Explain the \"why\" and \"intent\", not the \"what\" (types handle that)\n- **When to Comment:** Public APIs, complex logic, non-obvious decisions, workarounds\n- **Key Tags:** `@param`, `@returns`, `@throws`, `@deprecated`, `@example`, `@see`\n- **What NOT to Comment:** Obvious code, type duplication, version control info, commented-out code\n\n### üìù Logging Guidelines (`logging-guidelines.mdc`)\n\n**‚ö†Ô∏è IMPORTANT: Only add logs when asked for. By default, do NOT add logs.**\n\nComprehensive logging standards:\n\n- **Server-Side:** Use `getServerLogger(moduleName)` for API routes, server components, middleware\n- **Client-Side:** Use `getClientLogger(componentName)` for client components, hooks, event handlers\n- **Log Levels:** `error`, `warn`, `info`, `http`, `debug`\n- **Best Practices:** Include context, avoid sensitive data, use appropriate levels, structured metadata on server\n- **Performance:** Client-side logging should be minimal; only `error` logs are sent to server by default\n\n### üéØ Styling Guidelines (`styling-guidelines.mdc`)\n\nComprehensive code style guide covering 30+ categories:\n\n- **Types & References:** Use `const`/`let`, avoid `var`\n- **Objects & Arrays:** Literal syntax, spread operators, method shorthand\n- **Functions:** Named expressions, arrow functions, default parameters\n- **Modules:** ES6 imports/exports, no wildcard imports\n- **Naming:** camelCase for variables/functions, PascalCase for classes/components\n- **Whitespace:** 2-space indentation, consistent spacing rules\n- **Comments:** JSDoc for multi-line, `//` for single-line\n- **Testing:** Write tests, aim for 100% coverage\n\n### ‚úÖ No Hiding (`no-hiding.mdc`)\n\n**Critical Rule:** Never hide lint errors. All lint errors must be fully resolved.\n\n### üß™ Testing (`testing.mdc`)\n\nComprehensive testing philosophy focusing on logic and behavior:\n\n- **Service Layer Testing:** 100% coverage required for business logic\n- **HOF Testing:** Authentication and middleware must be bulletproof\n- **No UI Tests:** Frontend tested manually, backend tested automatically\n- **Test Organization:** Tests live alongside code in `__tests__` directories\n- **Framework:** Jest with TypeScript support\n\n### üö® Error Handling Patterns (`error-handling-patterns.mdc`)\n\nComprehensive error management strategies:\n\n- **Custom Error Classes:** Domain-specific errors with proper status codes\n- **API Error Handling:** Consistent error responses with security in mind\n- **React Error Boundaries:** Graceful UI error recovery\n- **Error Recovery:** Retry logic, fallbacks, and circuit breakers\n- **Monitoring:** Structured logging with context\n\n### ‚ö° Performance Guidelines (`performance-guidelines.mdc`)\n\nReact and Next.js optimization techniques:\n\n- **React Patterns:** memo, useMemo, useCallback best practices\n- **State Optimization:** Selective Zustand subscriptions\n- **List Virtualization:** Handling large datasets efficiently\n- **Code Splitting:** Dynamic imports and lazy loading\n- **Bundle Optimization:** Tree shaking and size monitoring\n- **Data Fetching:** SWR patterns and optimistic updates\n\n### üóÑÔ∏è State Management Patterns (`state-management-patterns.mdc`)\n\nZustand best practices and patterns:\n\n- **Store Organization:** Single responsibility, focused stores\n- **Performance:** Selective subscriptions and computed selectors\n- **TypeScript:** Fully typed stores with predictable state\n- **Advanced Patterns:** Middleware, persistence, async actions\n- **Testing:** Store testing strategies\n\n### üîÄ Git Workflow (`git-workflow.mdc`)\n\nVersion control and commit message standards:\n\n- **Commit Format:** Conventional Commits specification\n- **Branch Naming:** Consistent naming conventions\n- **Pull Requests:** PR guidelines and templates\n- **Workflow:** Feature branch workflow and conflict resolution\n\n### üëÄ Code Review (`code-review.mdc`)\n\nCode review checklist and best practices:\n\n- **Review Checklist:** Functionality, quality, architecture, security\n- **Review Process:** Guidelines for authors and reviewers\n- **Feedback:** How to provide constructive feedback\n- **Conflict Resolution:** Handling disagreements during review\n\n### ‚ôø Accessibility Guidelines (`accessibility-guidelines.mdc`)\n\nAccessibility (a11y) standards for inclusive design:\n\n- **WCAG Compliance:** Level AA target\n- **Semantic HTML:** Proper element usage\n- **ARIA Attributes:** When and how to use ARIA\n- **Keyboard Navigation:** Full keyboard accessibility\n- **Testing:** Manual and automated a11y testing\n\n### ‚öñÔ∏è Conflict Resolution (`conflict-resolution.mdc`)\n\nGuidance for resolving rule conflicts:\n\n- **Priority Hierarchy:** Rule precedence order\n- **Common Scenarios:** How to handle specific conflicts\n- **Decision Process:** Step-by-step conflict resolution\n- **Documentation:** When and how to document exceptions\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @commenting-guidelines.mdc Please add JSDoc comments to this function\n   ```\n\n### File Structure\n\n```\nvibe-coding-rules/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ Typescript-React-Nextjs/\n    ‚îú‚îÄ‚îÄ accessibility-guidelines.mdc\n    ‚îú‚îÄ‚îÄ backend.mdc\n    ‚îú‚îÄ‚îÄ code-review.mdc\n    ‚îú‚îÄ‚îÄ commenting-guidelines.mdc\n    ‚îú‚îÄ‚îÄ conflict-resolution.mdc\n    ‚îú‚îÄ‚îÄ core-framework-&-language.mdc\n    ‚îú‚îÄ‚îÄ error-handling-patterns.mdc\n    ‚îú‚îÄ‚îÄ frontend.mdc\n    ‚îú‚îÄ‚îÄ git-workflow.mdc\n    ‚îú‚îÄ‚îÄ key-architecture-patterns.mdc\n    ‚îú‚îÄ‚îÄ logging-guidelines.mdc\n    ‚îú‚îÄ‚îÄ no-hiding.mdc\n    ‚îú‚îÄ‚îÄ performance-guidelines.mdc\n    ‚îú‚îÄ‚îÄ state-management-patterns.mdc\n    ‚îú‚îÄ‚îÄ styling-guidelines.mdc\n    ‚îú‚îÄ‚îÄ typescript-code-style-guide.mdc\n    ‚îî‚îÄ‚îÄ testing.mdc\n```\n\n## Quick Reference\n\n### When Writing Code\n\n- ‚úÖ Follow styling guidelines (camelCase, 2-space indentation, semicolons, etc.)\n- ‚úÖ **NEVER abbreviate variables** - Always use full, descriptive names\n- ‚úÖ Use TypeScript's type system fully - never use `any`, prefer `unknown` and narrow\n- ‚úÖ Provide explicit return types for exported functions\n- ‚úÖ Use JSDoc comments for public APIs and complex logic\n- ‚úÖ Never hide lint errors - fix them completely\n- ‚úÖ Use appropriate logging (only when requested)\n- ‚úÖ Follow architectural patterns (Service Layer, Registry Pattern, etc.)\n- ‚úÖ Use type guards for runtime type checking\n- ‚úÖ Leverage discriminated unions for complex state management\n\n### When Adding Features\n\n- ‚úÖ Use Next.js API Routes for backend endpoints\n- ‚úÖ Use Chakra UI for frontend components\n- ‚úÖ Use Zustand for global state management\n- ‚úÖ Use React Hook Form for forms\n- ‚úÖ Validate API requests with Yup schemas\n- ‚úÖ Use Supabase for authentication and database\n\n### When Testing\n\n- ‚úÖ Write tests for service layer (100% coverage required)\n- ‚úÖ Test HOFs and authentication separately\n- ‚úÖ Manual testing for frontend, automated for backend\n- ‚úÖ Focus on behavior, not implementation\n- ‚úÖ Mock at the boundary, not internally\n\n### When Handling Errors\n\n- ‚úÖ Use custom error classes with proper status codes\n- ‚úÖ Never expose sensitive information in errors\n- ‚úÖ Implement error boundaries for React components\n- ‚úÖ Add retry logic for transient failures\n- ‚úÖ Log errors with context for debugging\n\n### When Optimizing Performance\n\n- ‚úÖ Measure before optimizing\n- ‚úÖ Use React.memo, useMemo, useCallback appropriately\n- ‚úÖ Implement selective Zustand subscriptions\n- ‚úÖ Virtualize long lists\n- ‚úÖ Code split and lazy load heavy components\n- ‚úÖ Monitor bundle size\n\n### When Managing State\n\n- ‚úÖ Use Zustand for global application state\n- ‚úÖ Keep local state for UI-only concerns\n- ‚úÖ Create focused, single-responsibility stores\n- ‚úÖ Use selectors for computed values\n- ‚úÖ Implement optimistic updates for better UX\n\n### When Committing Code\n\n- ‚úÖ Use Conventional Commits format\n- ‚úÖ Write clear, descriptive commit messages\n- ‚úÖ Make atomic commits (one logical change)\n- ‚úÖ Test before committing\n- ‚úÖ Never commit secrets or sensitive data\n\n### When Reviewing Code\n\n- ‚úÖ Check functionality and edge cases\n- ‚úÖ Verify adherence to all guidelines\n- ‚úÖ Look for security issues\n- ‚úÖ Provide constructive feedback\n- ‚úÖ Approve when standards are met\n\n### When Building UI\n\n- ‚úÖ Use semantic HTML elements\n- ‚úÖ Ensure keyboard navigation works\n- ‚úÖ Provide proper ARIA labels\n- ‚úÖ Test with screen readers\n- ‚úÖ Meet WCAG AA standards\n\n## Contributing\n\nWhen updating these rules:\n\n1. Keep guidelines clear and actionable\n2. Include examples where helpful\n3. Update this README if adding new rule files\n4. Ensure consistency across all rule files\n\n## Notes\n\n- These rules are specifically tailored for TypeScript + React + Next.js projects\n- Rules marked with `alwaysApply: true` are enforced automatically\n- The logging guidelines emphasize minimal logging by default - only log when explicitly requested\n- The \"no-hiding\" rule is critical - all lint errors must be resolved, never suppressed\n- When rules conflict, refer to `conflict-resolution.mdc` for guidance\n- React Testing Library is available but only for testing hooks, not component rendering\n",
      "guides": [
        {
          "id": "accessibility-guidelines",
          "title": "Accessibility Guidelines",
          "fileName": "accessibility-guidelines.mdc",
          "frontmatter": {
            "description": "Accessibility (a11y) guidelines and best practices for inclusive web applications",
            "globs": [
              "**/*.tsx",
              "**/components/**"
            ],
            "alwaysApply": true
          },
          "content": "# Accessibility Guidelines\n\n## Philosophy\n\nAccessibility ensures that our application is usable by everyone, including people with disabilities. This includes visual, auditory, motor, and cognitive impairments. Accessibility is not optional‚Äîit's a requirement for inclusive design.\n\n## Core Principles\n\n1. **Perceivable**: Information must be presentable in ways users can perceive\n2. **Operable**: Interface components must be operable\n3. **Understandable**: Information and UI operation must be understandable\n4. **Robust**: Content must be robust enough for assistive technologies\n\n## Chakra UI Accessibility\n\nChakra UI provides excellent accessibility out of the box, but we must use it correctly:\n\n### ‚úÖ DO\n\n```typescript\n// ‚úÖ Proper semantic HTML with Chakra\n<Button aria-label=\"Close dialog\">√ó</Button>\n<Input aria-describedby=\"email-error\" />\n<Alert role=\"alert\">Error message</Alert>\n\n// ‚úÖ Proper heading hierarchy\n<Heading as=\"h1\">Main Title</Heading>\n<Heading as=\"h2\">Section Title</Heading>\n\n// ‚úÖ Accessible form labels\n<FormControl>\n  <FormLabel htmlFor=\"email\">Email Address</FormLabel>\n  <Input id=\"email\" type=\"email\" />\n  <FormErrorMessage>Error message</FormErrorMessage>\n</FormControl>\n```\n\n### ‚ùå DON'T\n\n```typescript\n// ‚ùå Missing labels\n<Input placeholder=\"Enter email\" /> // Screen readers can't read placeholder\n\n// ‚ùå Wrong heading levels\n<Heading as=\"h3\">Main Title</Heading> // Should be h1\n\n// ‚ùå Decorative icons without labels\n<IconButton icon={<CloseIcon />} /> // Missing aria-label\n```\n\n## Semantic HTML\n\nUse proper HTML elements for their intended purpose:\n\n```typescript\n// ‚úÖ GOOD - Semantic elements\n<nav>\n  <Link href=\"/\">Home</Link>\n</nav>\n\n<main>\n  <article>\n    <h1>Article Title</h1>\n    <p>Content</p>\n  </article>\n</main>\n\n<footer>\n  <p>Copyright</p>\n</footer>\n\n// ‚ùå BAD - Div soup\n<div onClick={handleClick}>Click me</div>\n<div className=\"header\">Title</div>\n```\n\n## ARIA Attributes\n\nUse ARIA attributes when semantic HTML isn't sufficient:\n\n### Common ARIA Patterns\n\n```typescript\n// ‚úÖ Button that looks like a link\n<Button as=\"a\" href=\"/page\" role=\"link\">\n  Go to page\n</Button>\n\n// ‚úÖ Loading state\n<Button isLoading aria-busy={isLoading}>\n  Submit\n</Button>\n\n// ‚úÖ Error state\n<Input\n  aria-invalid={hasError}\n  aria-describedby={hasError ? \"error-id\" : undefined}\n/>\n\n// ‚úÖ Modal/Dialog\n<Modal isOpen={isOpen} onClose={onClose}>\n  <ModalOverlay />\n  <ModalContent role=\"dialog\" aria-labelledby=\"modal-title\">\n    <ModalHeader id=\"modal-title\">Title</ModalHeader>\n    <ModalBody>Content</ModalBody>\n  </ModalContent>\n</Modal>\n```\n\n### ARIA Labels\n\n```typescript\n// ‚úÖ Icon buttons need labels\n<IconButton\n  icon={<CloseIcon />}\n  aria-label=\"Close dialog\"\n/>\n\n// ‚úÖ Decorative images\n<Image\n  src=\"/decorative.jpg\"\n  alt=\"\" // Empty for decorative images\n  role=\"presentation\"\n/>\n\n// ‚úÖ Informative images\n<Image\n  src=\"/chart.jpg\"\n  alt=\"Sales increased 25% from Q1 to Q2\"\n/>\n```\n\n## Keyboard Navigation\n\nAll interactive elements must be keyboard accessible:\n\n```typescript\n// ‚úÖ Proper keyboard support\n<Button\n  onClick={handleClick}\n  onKeyDown={(e) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      handleClick();\n    }\n  }}\n>\n  Click me\n</Button>\n\n// ‚úÖ Focus management\nconst initialFocusRef = useRef<HTMLInputElement>(null);\n\n<Modal initialFocusRef={initialFocusRef}>\n  <ModalContent>\n    <Input ref={initialFocusRef} />\n  </ModalContent>\n</Modal>\n\n// ‚úÖ Skip links\n<Link\n  href=\"#main-content\"\n  position=\"absolute\"\n  left=\"-9999px\"\n  _focus={{ left: 0 }}\n>\n  Skip to main content\n</Link>\n```\n\n## Focus Management\n\n### Visible Focus Indicators\n\n```typescript\n// ‚úÖ Chakra UI provides focus styles by default\n<Button>Click me</Button> // Has visible focus ring\n\n// ‚úÖ Custom focus styles if needed\n<Box\n  _focus={{\n    outline: '2px solid',\n    outlineColor: 'blue.500',\n    outlineOffset: '2px',\n  }}\n>\n  Focusable element\n</Box>\n```\n\n### Focus Trapping\n\n```typescript\n// ‚úÖ Modal traps focus\n<Modal isOpen={isOpen}>\n  <ModalContent>\n    {/* Focus stays within modal */}\n  </ModalContent>\n</Modal>\n```\n\n### Focus Order\n\n- Logical tab order (top to bottom, left to right)\n- Skip links for main content\n- Focus visible on all interactive elements\n\n## Color Contrast\n\n### Text Contrast\n\n- **Normal text**: Minimum 4.5:1 contrast ratio\n- **Large text** (18pt+): Minimum 3:1 contrast ratio\n- **UI components**: Minimum 3:1 contrast ratio\n\n```typescript\n// ‚úÖ Good contrast\n<Text color=\"gray.800\" bg=\"white\">Readable text</Text>\n\n// ‚ùå Poor contrast\n<Text color=\"gray.300\" bg=\"white\">Hard to read</Text>\n```\n\n### Don't Rely on Color Alone\n\n```typescript\n// ‚ùå BAD - Color only\n<Text color=\"red\">Error: Invalid email</Text>\n\n// ‚úÖ GOOD - Color + icon/text\n<HStack>\n  <AlertIcon color=\"red.500\" />\n  <Text>Error: Invalid email</Text>\n</HStack>\n```\n\n## Forms\n\n### Proper Form Structure\n\n```typescript\n// ‚úÖ Accessible form\n<FormControl isInvalid={hasError}>\n  <FormLabel htmlFor=\"email\">Email Address</FormLabel>\n  <Input\n    id=\"email\"\n    type=\"email\"\n    aria-describedby={hasError ? \"email-error\" : \"email-help\"}\n    aria-invalid={hasError}\n  />\n  {hasError ? (\n    <FormErrorMessage id=\"email-error\">\n      Please enter a valid email address\n    </FormErrorMessage>\n  ) : (\n    <FormHelperText id=\"email-help\">\n      We'll never share your email\n    </FormHelperText>\n  )}\n</FormControl>\n```\n\n### Required Fields\n\n```typescript\n// ‚úÖ Clear required indication\n<FormLabel>\n  Email Address <Text as=\"span\" color=\"red.500\" aria-label=\"required\">*</Text>\n</FormLabel>\n<Input required aria-required=\"true\" />\n```\n\n## Images and Media\n\n### Alt Text Guidelines\n\n```typescript\n// ‚úÖ Descriptive alt text\n<Image\n  src=\"/user-profile.jpg\"\n  alt=\"Sarah Johnson, software engineer, smiling\"\n/>\n\n// ‚úÖ Decorative images\n<Image\n  src=\"/decorative-pattern.jpg\"\n  alt=\"\"\n  role=\"presentation\"\n/>\n\n// ‚úÖ Complex images (charts, graphs)\n<Image\n  src=\"/sales-chart.jpg\"\n  alt=\"Line chart showing sales increased from $50k in January to $75k in March\"\n/>\n```\n\n### Video and Audio\n\n```typescript\n// ‚úÖ Video with captions\n<video controls>\n  <source src=\"video.mp4\" type=\"video/mp4\" />\n  <track kind=\"captions\" src=\"captions.vtt\" />\n</video>\n\n// ‚úÖ Audio with transcripts\n<audio controls>\n  <source src=\"audio.mp3\" type=\"audio/mpeg\" />\n</audio>\n<a href=\"/transcript.txt\">View transcript</a>\n```\n\n## Dynamic Content\n\n### Live Regions\n\n```typescript\n// ‚úÖ Announce dynamic updates\n<Box role=\"status\" aria-live=\"polite\" aria-atomic=\"true\">\n  {statusMessage}\n</Box>\n\n// ‚úÖ Alert for important updates\n<Alert status=\"success\" role=\"alert\">\n  Profile updated successfully\n</Alert>\n```\n\n### Loading States\n\n```typescript\n// ‚úÖ Loading state with announcement\n<Box role=\"status\" aria-live=\"polite\">\n  {isLoading ? 'Loading...' : 'Content loaded'}\n</Box>\n\n// ‚úÖ Skeleton loaders\n<Skeleton height=\"20px\" />\n```\n\n## Testing Accessibility\n\n### Manual Testing\n\n1. **Keyboard Navigation**\n   - Tab through all interactive elements\n   - Ensure logical focus order\n   - Verify all actions work with keyboard\n\n2. **Screen Reader Testing**\n   - Use NVDA (Windows) or VoiceOver (Mac)\n   - Navigate through the page\n   - Verify all content is announced\n\n3. **Color Contrast**\n   - Use browser DevTools or contrast checker\n   - Verify all text meets WCAG AA standards\n\n### Automated Testing\n\n```typescript\n// Use @axe-core/react for automated a11y testing\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\nexpect.extend(toHaveNoViolations);\n\ntest('should not have accessibility violations', async () => {\n  const { container } = render(<MyComponent />);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n```\n\n## Common Patterns\n\n### Accessible Dropdown Menu\n\n```typescript\n<Menu>\n  <MenuButton as={Button} rightIcon={<ChevronDownIcon />}>\n    Actions\n  </MenuButton>\n  <MenuList>\n    <MenuItem>Edit</MenuItem>\n    <MenuItem>Delete</MenuItem>\n  </MenuList>\n</Menu>\n```\n\n### Accessible Modal\n\n```typescript\n<Modal isOpen={isOpen} onClose={onClose}>\n  <ModalOverlay />\n  <ModalContent>\n    <ModalHeader>Modal Title</ModalHeader>\n    <ModalCloseButton />\n    <ModalBody>\n      Content\n    </ModalBody>\n    <ModalFooter>\n      <Button onClick={onClose}>Close</Button>\n    </ModalFooter>\n  </ModalContent>\n</Modal>\n```\n\n### Accessible Tabs\n\n```typescript\n<Tabs>\n  <TabList>\n    <Tab>Tab 1</Tab>\n    <Tab>Tab 2</Tab>\n  </TabList>\n  <TabPanels>\n    <TabPanel>Content 1</TabPanel>\n    <TabPanel>Content 2</TabPanel>\n  </TabPanels>\n</Tabs>\n```\n\n## WCAG Compliance\n\nAim for **WCAG 2.1 Level AA** compliance:\n\n- **Level A**: Minimum requirements\n- **Level AA**: Standard compliance (our target)\n- **Level AAA**: Enhanced compliance (aspirational)\n\n## Resources\n\n- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)\n- [Chakra UI Accessibility](https://chakra-ui.com/docs/getting-started/accessibility)\n- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)\n- [WAVE Browser Extension](https://wave.webaim.org/extension/)\n\n## Remember\n\n- **Accessibility is not optional** - it's a requirement\n- **Test with keyboard and screen readers**\n- **Don't rely on color alone**\n- **Use semantic HTML first, ARIA when needed**\n- **Chakra UI helps, but you must use it correctly**\n",
          "alwaysApply": true,
          "globs": [
            "**/*.tsx",
            "**/components/**"
          ]
        },
        {
          "id": "backend",
          "title": "Backend",
          "fileName": "backend.mdc",
          "frontmatter": {
            "description": "Backend architecture, API patterns, and service integrations",
            "globs": [
              "**/api/**",
              "**/services/**",
              "**/schemas/**",
              "**/utils/api/**",
              "**/utils/auth/**"
            ],
            "alwaysApply": true
          },
          "content": "# Backend / API Architecture\n\n## Overview\n\nThis document defines the backend architecture, API patterns, and external service integrations used in the application.\n\n## API Routes\n\n**Framework:** [Next.js API Routes](https://nextjs.org/docs/pages/building-your-application/routing/api-routes)\n\n**Location:** `src/pages/api/` directory\n\n**Pattern:** Thin route handlers that delegate to services\n\n**Example:**\n\n```typescript\n// src/pages/api/users/[id].ts\nimport { withAuthentication } from '@/utils/api/withAuthentication';\nimport { withErrorHandler } from '@/utils/api/errorHandler';\nimport { getUserProfile } from '@/services/userService';\n\nexport default withAuthentication(\n  withErrorHandler(async (req, res) => {\n    if (req.method !== 'GET') {\n      return res.status(405).json({ error: 'Method not allowed' });\n    }\n\n    const user = await getUserProfile(req.query.id as string);\n    res.status(200).json({ data: user });\n  })\n);\n```\n\n## Backend as a Service (BaaS)\n\n**Service:** [Supabase](https://supabase.com/)\n\n### Authentication\n\n- **Service:** Supabase Auth\n- Handles user login, signup, password reset\n- Provides JWT tokens for API authentication\n- Session management built-in\n\n**Usage:**\n\n```typescript\nimport { supabase } from '@/lib/supabase';\n\n// Sign up\nconst { data, error } = await supabase.auth.signUp({\n  email: 'user@example.com',\n  password: 'password'\n});\n\n// Sign in\nconst { data, error } = await supabase.auth.signInWithPassword({\n  email: 'user@example.com',\n  password: 'password'\n});\n```\n\n### Database\n\n- **Type:** PostgreSQL database\n- **Storage:** Application data (users, characters, tweets, workflows, etc.)\n- **Schema:** Defined in `database_sql/` directory\n- **Client:** Supabase client library for queries\n\n**Usage:**\n\n```typescript\nimport { supabase } from '@/lib/supabase';\n\n// Query data\nconst { data, error } = await supabase\n  .from('users')\n  .select('*')\n  .eq('status', 'active')\n  .single();\n```\n\n### Storage\n\n- **Purpose:** File storage (e.g., character profile pictures)\n- **Buckets:** Organized by purpose (e.g., `character-pfp` bucket)\n- **Access:** Controlled via Supabase storage policies\n\n**Usage:**\n\n```typescript\nimport { supabase } from '@/lib/supabase';\n\n// Upload file\nconst { data, error } = await supabase.storage\n  .from('character-pfp')\n  .upload('path/to/file.jpg', file);\n\n// Get public URL\nconst { data } = supabase.storage\n  .from('character-pfp')\n  .getPublicUrl('path/to/file.jpg');\n```\n\n## API Validation\n\n**Library:** [Yup](https://github.com/jquense/yup)\n\n**Location:** `src/schemas/` directory\n\n**Pattern:** Schema definitions validated via Higher-Order Functions (HOFs)\n\n**HOFs Available:**\n\n- `withBodyValidation` - Validates request body\n- `withQueryValidation` - Validates query parameters\n- `withAuthenticatedValidation` - Combines auth + body validation\n- `withAuthenticatedQueryValidation` - Combines auth + query validation\n\n**Example:**\n\n```typescript\n// src/schemas/userSchema.ts\nimport * as yup from 'yup';\n\nexport const createUserSchema = yup.object({\n  email: yup.string().email().required(),\n  name: yup.string().min(2).required(),\n  age: yup.number().positive().integer()\n});\n\n// src/pages/api/users/create.ts\nimport { withAuthenticatedValidation } from '@/utils/api/withAuthenticatedValidation';\nimport { createUserSchema } from '@/schemas/userSchema';\nimport { createUser } from '@/services/userService';\n\nexport default withAuthenticatedValidation(\n  createUserSchema,\n  async (req, res) => {\n    // req.body is already validated and typed\n    const user = await createUser(req.body);\n    res.status(201).json({ data: user });\n  }\n);\n```\n\n## API Authentication\n\n**Pattern:** Custom Higher-Order Functions (HOFs)\n\n**Location:** `src/utils/api/` and `src/utils/auth/`\n\n**Available HOFs:**\n\n1. **`withAuthentication`** - Validates JWT token and attaches user to request\n2. **`withApiKeyAuth`** - Validates API key authentication\n3. **`withAuthenticatedValidation`** - Combines authentication + body validation\n4. **`withAuthenticatedQueryValidation`** - Combines authentication + query validation\n\n**Example:**\n\n```typescript\n// src/utils/api/withAuthentication.ts\nexport function withAuthentication(\n  handler: (req: AuthenticatedRequest, res: NextApiResponse) => Promise<void>\n) {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    const token = extractToken(req);\n    const user = await validateToken(token);\n    \n    if (!user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    (req as AuthenticatedRequest).user = user;\n    return handler(req as AuthenticatedRequest, res);\n  };\n}\n```\n\n## Best Practices\n\n1. **Thin Route Handlers:** Keep API routes thin, delegate to services\n2. **Always Validate:** Use HOFs for validation and authentication\n3. **Error Handling:** Use `withErrorHandler` for consistent error responses\n4. **Service Layer:** All business logic in services, not routes\n5. **Type Safety:** Use TypeScript types from schemas for validated data\n6. **Security:** Never expose sensitive data in error messages or logs\n7. **Consistent Responses:** Use consistent response format (`{ data: ... }` or `{ error: ... }`)\n",
          "alwaysApply": true,
          "globs": [
            "**/api/**",
            "**/services/**",
            "**/schemas/**",
            "**/utils/api/**",
            "**/utils/auth/**"
          ]
        },
        {
          "id": "code-review",
          "title": "Code Review",
          "fileName": "code-review.mdc",
          "frontmatter": {
            "description": "Code review checklist and best practices for maintaining code quality",
            "globs": [
              "**/.github/**",
              "**/pull_request_template.md"
            ],
            "alwaysApply": true
          },
          "content": "# Code Review Guidelines\n\n## Purpose\n\nCode reviews ensure:\n- **Code Quality**: Maintains standards and best practices\n- **Knowledge Sharing**: Team members learn from each other\n- **Bug Prevention**: Catch issues before they reach production\n- **Consistency**: Uniform codebase across the project\n\n## Review Checklist\n\n### Functionality\n\n- [ ] Code works as intended and meets requirements\n- [ ] Edge cases are handled appropriately\n- [ ] Error handling is implemented correctly\n- [ ] No obvious bugs or logic errors\n\n### Code Quality\n\n- [ ] Follows all style guidelines (`styling-guidelines.mdc`)\n- [ ] No lint errors (see `no-hiding.mdc`)\n- [ ] TypeScript types are properly defined (no `any` types)\n- [ ] Code is readable and maintainable\n- [ ] Variable names are descriptive (no abbreviations)\n\n### Architecture\n\n- [ ] Follows architectural patterns (`key-architecture-patterns.mdc`)\n- [ ] Business logic is in services, not API routes\n- [ ] Proper separation of concerns\n- [ ] No unnecessary dependencies or complexity\n\n### Testing\n\n- [ ] Service layer has tests (100% coverage required)\n- [ ] HOFs have tests (100% coverage required)\n- [ ] Edge cases are tested\n- [ ] Tests are meaningful and test behavior, not implementation\n\n### Security\n\n- [ ] No sensitive data exposed in errors or logs\n- [ ] Authentication/authorization properly implemented\n- [ ] Input validation is present\n- [ ] No SQL injection or XSS vulnerabilities\n\n### Performance\n\n- [ ] No unnecessary re-renders (React components)\n- [ ] Proper use of `useMemo`, `useCallback`, `React.memo`\n- [ ] Efficient data fetching patterns\n- [ ] Bundle size considerations\n\n### Documentation\n\n- [ ] JSDoc comments for public APIs\n- [ ] Complex logic is explained\n- [ ] README updated if needed\n- [ ] Comments explain \"why\", not \"what\"\n\n## Review Process\n\n### For Authors\n\n**Before Requesting Review:**\n\n1. **Self-Review**\n   - Review your own code first\n   - Run linter and fix all errors\n   - Ensure tests pass\n   - Check that you've followed all guidelines\n\n2. **Prepare PR**\n   - Write clear PR title and description\n   - Link related issues\n   - Add screenshots for UI changes\n   - Keep PR size reasonable (< 400 lines ideally)\n\n3. **Request Review**\n   - Tag appropriate reviewers\n   - Provide context if needed\n   - Be available for questions\n\n**During Review:**\n\n- Be open to feedback\n- Ask questions if feedback is unclear\n- Discuss trade-offs if you disagree\n- Make requested changes promptly\n\n### For Reviewers\n\n**Review Approach:**\n\n1. **Understand Context**\n   - Read the PR description\n   - Understand the requirements\n   - Check related issues\n\n2. **Review Code**\n   - Start with high-level architecture\n   - Check for bugs and edge cases\n   - Verify adherence to guidelines\n   - Look for security issues\n\n3. **Provide Feedback**\n   - Be constructive and respectful\n   - Explain the \"why\" behind suggestions\n   - Prioritize important issues\n   - Approve when satisfied\n\n**Feedback Guidelines:**\n\n- ‚úÖ **Be Specific**: Point to exact lines and explain issues\n- ‚úÖ **Be Constructive**: Suggest improvements, not just problems\n- ‚úÖ **Be Respectful**: Remember the author is a person\n- ‚úÖ **Be Timely**: Respond within 24 hours if possible\n- ‚ùå **Don't Nitpick**: Focus on important issues\n- ‚ùå **Don't Be Vague**: \"This could be better\" isn't helpful\n- ‚ùå **Don't Block on Style**: Use automated tools for style\n\n## Common Review Comments\n\n### Architecture Issues\n\n```typescript\n// ‚ùå Business logic in API route\nexport default async function handler(req, res) {\n  const processed = data.map(item => transform(item));\n  // ...\n}\n\n// ‚úÖ Business logic in service\nexport default async function handler(req, res) {\n  const processed = await processData(data);\n  // ...\n}\n```\n\n### Type Safety\n\n```typescript\n// ‚ùå Using 'any'\nfunction process(data: any) { }\n\n// ‚úÖ Proper types\nfunction process<T extends ProcessableData>(data: T) { }\n```\n\n### Error Handling\n\n```typescript\n// ‚ùå Silent failure\ntry {\n  await operation();\n} catch (error) {\n  // Ignored\n}\n\n// ‚úÖ Proper error handling\ntry {\n  await operation();\n} catch (error) {\n  logger.error('Operation failed', { error });\n  throw new ApplicationError('Operation failed', 500);\n}\n```\n\n### Performance\n\n```typescript\n// ‚ùå Unnecessary re-renders\nfunction Component() {\n  const store = useStore();\n  return <div>{store.user.name}</div>;\n}\n\n// ‚úÖ Selective subscription\nfunction Component() {\n  const userName = useStore(state => state.user.name);\n  return <div>{userName}</div>;\n}\n```\n\n## Review Response Types\n\n### Approve ‚úÖ\n\nUse when:\n- Code meets all standards\n- No blocking issues\n- Ready to merge\n\n### Request Changes üîÑ\n\nUse when:\n- Critical issues need fixing\n- Security concerns\n- Architecture problems\n- Missing tests\n\n### Comment üí¨\n\nUse when:\n- Suggestions for improvement\n- Questions about implementation\n- Non-blocking concerns\n- Future improvements\n\n## Conflict Resolution\n\n### When Disagreement Occurs\n\n1. **Discuss**: Have a conversation about the trade-offs\n2. **Reference Guidelines**: Point to specific rules or patterns\n3. **Seek Consensus**: Involve team lead if needed\n4. **Document Decision**: Update guidelines if pattern emerges\n\n### Escalation\n\nIf you can't reach agreement:\n- Discuss with team lead\n- Review project guidelines together\n- Update guidelines if needed\n- Make decision and move forward\n\n## Automated Checks\n\nBefore requesting review, ensure:\n\n- [ ] All tests pass\n- [ ] No lint errors\n- [ ] TypeScript compiles without errors\n- [ ] Build succeeds\n- [ ] No security vulnerabilities\n\n## Review Best Practices\n\n### DO\n\n- Review promptly (within 24 hours)\n- Focus on important issues first\n- Explain your reasoning\n- Be open to discussion\n- Approve when satisfied\n\n### DON'T\n\n- Block on personal preferences\n- Request changes for minor style issues\n- Be dismissive of questions\n- Approve without reviewing\n- Make changes directly (unless agreed)\n\n## Remember\n\n- **Code review is a conversation**, not a gate\n- **Everyone makes mistakes** - be kind\n- **Learning opportunity** for both author and reviewer\n- **Quality over speed** - but don't block unnecessarily\n- **Consistency matters** - follow the guidelines\n\n## Quick Reference\n\n**Must Fix Before Merge:**\n- Lint errors\n- TypeScript errors\n- Failing tests\n- Security issues\n- Architecture violations\n\n**Nice to Have:**\n- Code style improvements\n- Performance optimizations\n- Additional tests\n- Documentation updates\n",
          "alwaysApply": true,
          "globs": [
            "**/.github/**",
            "**/pull_request_template.md"
          ]
        },
        {
          "id": "commenting-guidelines",
          "title": "Commenting Guidelines",
          "fileName": "commenting-guidelines.mdc",
          "frontmatter": {
            "description": "JSDoc commenting standards focusing on explaining intent and complex logic, not obvious code",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# Codebase Commenting Guidelines\n\n## Philosophy\n\nOur primary goal for commenting is **clarity and maintainability**. In a TypeScript codebase, types already provide significant information about the *what*. Therefore, our comments should focus on the **why**, the **intent**, and the **complexities** that aren't immediately obvious from the code and types alone.\n\nWe use **JSDoc** as the standard format. This provides structure, integrates well with TypeScript's language server for enhanced IntelliSense, and offers a consistent format for both human developers and AI systems interacting with our code.\n\nComments should add value. Avoid redundant comments that merely restate the obvious or duplicate type information. Prioritize commenting public APIs, complex logic, and non-intuitive decisions.\n\n## Core Standard: JSDoc\n\nAll multi-line comments explaining functions, classes, types, components, hooks, or complex blocks should use the JSDoc format (`/** ... */`).\n\n## When to Comment\n\nFocus commenting efforts where they provide the most value:\n\n1.  **Public APIs / Exports:**\n    *   **Functions/Methods:** Explain purpose, parameters, return values, and any potential side effects or errors.\n    *   **React Components:** Describe the component's purpose, its props, and any significant state or behavior. Use `@param` for props.\n    *   **Custom Hooks:** Explain what the hook does, its parameters, and what it returns.\n    *   **Utility Functions/Classes:** Document any exported helpers or classes intended for reuse.\n    *   **Types/Interfaces:** Explain the purpose of complex or broadly used custom types if the name isn't self-explanatory.\n\n2.  **Complex Logic:**\n    *   If an algorithm, calculation, or piece of business logic is intricate or non-obvious, add comments explaining the approach and the reasoning behind it. Focus on the *why*.\n\n3.  **Non-Obvious Decisions & Trade-offs:**\n    *   If a particular implementation choice was made for specific reasons (performance, browser compatibility, workaround for a library bug), document it. This provides crucial context for future maintainers.\n\n4.  **Important Constants or Configuration:**\n    *   If the purpose of a constant isn't immediately clear from its name and value, add a brief explanation.\n\n5.  **Workarounds and `TODO`s:**\n    *   Use `// HACK:` or `// WORKAROUND:` for temporary fixes, explaining *why* the workaround is necessary and potentially linking to an issue tracker.\n    *   Use `// TODO:` for planned improvements or missing features, ideally with context or an issue link.\n\n6.  **Type Clarifications (Sparingly):**\n    *   In rare cases where TypeScript's inference might be ambiguous or a type needs further semantic meaning, a JSDoc `@type` tag or explanation can help. *However, prefer refining the TypeScript types themselves first.*\n\n## How to Comment with JSDoc (Essential Tags)\n\nUse clear, concise English. Start block comments with a brief summary sentence.\n\n```typescript\n/**\n * [Summary sentence explaining the overall purpose.]\n *\n * [Optional: More detailed explanation, rationale, or context.]\n *\n * @param {Type} name - [Description of the parameter's purpose and expected value.]\n * @param {Type} [optionalName] - [Description for optional parameter. Use brackets.]\n * @param {Type} [nameWithDefault='default'] - [Description for parameter with default.]\n * @param {object} options - Description of the options object.\n * @param {string} options.id - Description of the 'id' property within options.\n * @param {number} [options.count] - Description of optional 'count' property.\n * @returns {ReturnType} - [Description of what the function returns and why/when.]\n * @throws {ErrorType} - [Description of when/why this error might be thrown.]\n * @deprecated [Reason for deprecation and/or alternative to use.]\n * @see {Link/Reference} - [Link to related functions, documentation, or issue tracker.]\n * @example\n * ```typescript\n * // Example usage demonstrates how to call it.\n * const result = myFunction(inputValue);\n * console.log(result);\n * ```\n */\n function myFunction(name: string, options: { id: string; count?: number }): ReturnType {\n   // ...implementation\n }\n\n/**\n * Represents a user profile within the application.\n * Used across various UI components and API interactions.\n */\nexport type UserProfile = {\n  /** Unique identifier for the user. */\n  id: string;\n  /** User's display name. May not be unique. */\n  name: string;\n  /** Optional email address. */\n  email?: string;\n};\n\n/**\n * Renders the main application layout, including header and footer.\n *\n * @param {object} props - Component properties.\n * @param {React.ReactNode} props.children - Content to be rendered within the layout.\n * @returns {JSX.Element} The main application layout structure.\n */\nexport const MainLayout = ({ children }: { children: React.ReactNode }): JSX.Element => {\n  // ...implementation\n};\n```\n\n**Key JSDoc Tags to Use:**\n\n*   **Description:** Always provide a clear summary. Add more detail if necessary.\n*   **`@param {Type} name - Description`**: Essential for functions/methods/hooks. Explain the *role* of the parameter. TypeScript handles the type, JSDoc explains the *purpose*.\n*   **`@returns {Type} - Description`**: Explain *what* is being returned and under what conditions, especially if it's complex or conditional.\n*   **`@props {object} - Description`** (Often implicit via `@param` in functional components): Used for documenting component props object. Individual props can be documented using `@param {Type} props.propName - Description`.\n*   **`@type {Type}`**: Use primarily for documenting constants or variables where type inference needs clarification (less common with explicit TS types).\n*   **`@example`**: Very helpful for demonstrating usage, especially for utilities or complex functions.\n*   **`@throws {ErrorType} - Condition`**: Document expected errors that callers might need to handle.\n*   **`@deprecated - Reason/Alternative`**: Crucial for managing API evolution.\n*   **`@see {Link/Reference}`**: Useful for linking to related code, external docs, or issue trackers.\n\n## What NOT to Comment\n\n*   **Obvious Code:** Don't explain code that is self-evident (e.g., `// Increment count` for `count++`).\n*   **Exact Type Duplication:** Avoid comments that just re-state the TypeScript type (e.g., `/** @param {string} userId - The user ID */` when the TS signature is `userId: string`). Focus on *purpose* if adding a `@param` comment.\n*   **Version Control Information:** Don't add comments about authors or change history (`// Changed by John Doe on 2023-10-27`). Use `git blame` and commit history for this.\n*   **Outdated Comments:** Delete or update comments ruthlessly if the code changes. Incorrect comments are worse than no comments.\n*   **Commented-Out Code:** Remove dead code instead of commenting it out. Use version control to retrieve old code if needed.\n",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        },
        {
          "id": "conflict-resolution",
          "title": "Conflict Resolution",
          "fileName": "conflict-resolution.mdc",
          "frontmatter": {
            "description": "Guidance for resolving conflicts when coding rules or guidelines conflict with each other",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# Conflict Resolution Guidelines\n\n## Overview\n\nWhen coding rules or guidelines appear to conflict, use this document to determine the correct approach. These guidelines establish a hierarchy and decision-making process for resolving conflicts.\n\n## Rule Priority Hierarchy\n\nWhen rules conflict, follow this priority order:\n\n1. **Security & Safety** (Highest Priority)\n   - Security guidelines override all other rules\n   - Error handling patterns take precedence\n   - Never compromise security for convenience\n\n2. **No-Hiding Rule** (`no-hiding.mdc`)\n   - All lint errors must be fixed\n   - Cannot be overridden by other rules\n   - Type safety cannot be compromised\n\n3. **Architecture Patterns** (`key-architecture-patterns.mdc`)\n   - Service layer pattern\n   - Separation of concerns\n   - Registry patterns\n\n4. **Code Quality**\n   - TypeScript strict typing\n   - Testing requirements\n   - Error handling\n\n5. **Style & Formatting** (Lowest Priority)\n   - Naming conventions\n   - Formatting rules\n   - Code style\n\n## Common Conflict Scenarios\n\n### Scenario 1: Performance vs. Code Clarity\n\n**Conflict:** Performance optimization makes code less readable\n\n**Resolution:**\n1. **Measure first** - Verify the optimization is actually needed\n2. **Document the trade-off** - Add JSDoc explaining why\n3. **Extract to utility** - Move complex optimization to well-named function\n4. **Prefer clarity** - Unless performance is proven bottleneck\n\n```typescript\n// ‚úÖ GOOD - Optimized but documented\n/**\n * Uses memoization to prevent expensive recalculation.\n * Performance-critical: called in render loop of 1000+ items.\n */\nconst processedData = useMemo(() => {\n  return expensiveCalculation(data);\n}, [data]);\n\n// ‚ùå BAD - Optimization without context\nconst pd = useMemo(() => ec(d), [d]);\n```\n\n### Scenario 2: Logging Guidelines vs. Error Handling\n\n**Conflict:** Error handling patterns suggest logging, but logging guidelines say \"don't log by default\"\n\n**Resolution:**\n1. **Error handling takes precedence** - Errors should be logged\n2. **Use appropriate log level** - `logger.error()` for actual errors\n3. **Don't add info/debug logs** - Only log errors and critical operations\n\n```typescript\n// ‚úÖ GOOD - Error logging is appropriate\ntry {\n  await criticalOperation();\n} catch (error) {\n  logger.error('Critical operation failed', { error }); // ‚úÖ Allowed\n  throw new ApplicationError('Operation failed', 500);\n}\n\n// ‚ùå BAD - Unnecessary info logging\nlogger.info('Starting operation'); // ‚ùå Not needed by default\nawait operation();\nlogger.info('Operation completed'); // ‚ùå Not needed by default\n```\n\n### Scenario 3: Type Safety vs. Quick Fix\n\n**Conflict:** Quick fix suggests using `any`, but no-hiding rule forbids it\n\n**Resolution:**\n1. **No-hiding rule always wins** - Never use `any` or suppress errors\n2. **Take time to properly type** - It's worth the effort\n3. **Ask for help** - If unsure how to type, ask rather than suppress\n\n```typescript\n// ‚ùå BAD - Suppressing type error\n// @ts-ignore\nconst result = unsafeOperation();\n\n// ‚úÖ GOOD - Proper typing\ninterface OperationResult {\n  value: unknown;\n  status: 'success' | 'error';\n}\n\nconst result: OperationResult = safeOperation();\n```\n\n### Scenario 4: Architecture vs. Convenience\n\n**Conflict:** Easier to put logic in API route, but architecture says use service layer\n\n**Resolution:**\n1. **Architecture pattern takes precedence** - Always use service layer\n2. **Keep routes thin** - Delegate to services\n3. **Extract to service** - Even for simple operations\n\n```typescript\n// ‚ùå BAD - Logic in route\nexport default async function handler(req, res) {\n  const processed = data.map(item => transform(item));\n  res.json(processed);\n}\n\n// ‚úÖ GOOD - Logic in service\nexport default async function handler(req, res) {\n  const processed = await processDataService(data);\n  res.json(processed);\n}\n```\n\n### Scenario 5: Testing vs. Time Constraints\n\n**Conflict:** Need to ship quickly, but testing guidelines require 100% coverage\n\n**Resolution:**\n1. **Testing is non-negotiable** - Services must have tests\n2. **Focus on critical paths** - Test the most important logic first\n3. **Don't skip tests** - They prevent future bugs\n\n```typescript\n// ‚ùå BAD - Skipping tests\n// TODO: Add tests later\nexport async function criticalService() {\n  // No tests\n}\n\n// ‚úÖ GOOD - At least basic tests\ndescribe('CriticalService', () => {\n  it('should handle happy path', async () => {\n    // Basic test\n  });\n  // Can add more tests in follow-up PR\n});\n```\n\n### Scenario 6: Styling vs. Consistency\n\n**Conflict:** New code style conflicts with existing codebase style\n\n**Resolution:**\n1. **Follow guidelines** - Use the documented style\n2. **Update existing code** - If guidelines changed, update gradually\n3. **Be consistent** - Don't mix styles in same file\n\n```typescript\n// ‚úÖ GOOD - Consistent with guidelines\nconst userName = user.name; // camelCase, descriptive\n\n// ‚ùå BAD - Mixing styles\nconst userName = user.name; // Some places\nconst uName = user.name; // Other places\n```\n\n## Decision-Making Process\n\nWhen encountering a conflict:\n\n### Step 1: Identify the Conflict\n\n- Which rules are conflicting?\n- What are the competing priorities?\n- What's the specific scenario?\n\n### Step 2: Check Priority Hierarchy\n\n- Refer to the priority hierarchy above\n- Determine which rule has higher priority\n- Check if there's a documented exception\n\n### Step 3: Consider Context\n\n- Is this a one-time exception or pattern?\n- What are the trade-offs?\n- What's the impact?\n\n### Step 4: Make Decision\n\n- Follow the higher-priority rule\n- Document the decision if non-obvious\n- Update guidelines if pattern emerges\n\n### Step 5: Document Exception (if needed)\n\n```typescript\n/**\n * Uses 'any' here because [specific reason].\n * \n * Exception to no-hiding rule approved by [team/lead] on [date].\n * TODO: Refactor to proper types in [ticket/issue].\n */\nfunction temporaryFunction(data: any) {\n  // ...\n}\n```\n\n## When to Update Guidelines\n\nUpdate guidelines when:\n\n1. **Pattern Emerges** - Same conflict happens multiple times\n2. **Team Consensus** - Team agrees on new approach\n3. **Best Practice Changes** - Industry standards evolve\n4. **Tool Updates** - New tools enable better patterns\n\n## Escalation\n\nIf you cannot resolve a conflict:\n\n1. **Document the conflict** - Write down both sides\n2. **Discuss with team** - Get multiple perspectives\n3. **Seek team lead input** - For final decision\n4. **Update guidelines** - Document the resolution\n\n## Examples\n\n### Example 1: Performance Optimization\n\n**Situation:** Need to optimize a slow component, but optimization makes code complex\n\n**Resolution:**\n- Measure performance first\n- If optimization needed, implement it\n- Add JSDoc explaining the trade-off\n- Consider extracting to utility function\n\n### Example 2: Third-Party Library Limitation\n\n**Situation:** Library requires `any` type, but no-hiding rule forbids it\n\n**Resolution:**\n- Create wrapper function with proper types\n- Use type guards to narrow types\n- Document the limitation\n- Consider alternative library if too problematic\n\n### Example 3: Legacy Code Integration\n\n**Situation:** Integrating with legacy code that doesn't follow guidelines\n\n**Resolution:**\n- Create adapter layer following guidelines\n- Don't compromise new code for legacy\n- Gradually refactor legacy code\n- Document the integration approach\n\n## Remember\n\n- **Security and safety first** - Never compromise these\n- **No-hiding rule is absolute** - Fix errors, don't suppress\n- **Architecture patterns are important** - Follow them consistently\n- **When in doubt, ask** - Better to discuss than guess\n- **Document exceptions** - If you must break a rule, explain why\n\n## Quick Reference\n\n**Always Follow:**\n- Security guidelines\n- No-hiding rule\n- Architecture patterns\n- Type safety\n\n**Can Be Flexible:**\n- Code style (within reason)\n- Performance optimizations (measure first)\n- Testing scope (focus on critical paths)\n\n**Never Compromise:**\n- Security\n- Type safety\n- Error handling\n- Architecture separation\n",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        },
        {
          "id": "core-framework-language",
          "title": "Core Framework & Language",
          "fileName": "core-framework-&-language.mdc",
          "frontmatter": {
            "description": "Core framework, language, and runtime specifications for the codebase",
            "globs": [
              "**/*.ts",
              "**/*.tsx",
              "**/pages/**",
              "**/next.config.*"
            ],
            "alwaysApply": true
          },
          "content": "# Core Framework & Language\n\n## Overview\n\nThis document defines the foundational technology stack and runtime environment for the project. All code must align with these specifications.\n\n## Framework\n\n- **Framework:** [Next.js](https://nextjs.org/) (using Pages Router)\n  - Provides server-side rendering, static site generation, API routes, and a robust React development environment\n  - Uses the Pages Router architecture (`src/pages/` directory structure)\n  - Supports both static and dynamic rendering strategies\n\n## Language\n\n- **Language:** [TypeScript](https://www.typescriptlang.org/)\n  - Used throughout the codebase for type safety and improved developer experience\n  - Strict type checking enabled\n  - All files must use TypeScript (`.ts` or `.tsx` extensions)\n\n## Runtime\n\n- **Runtime:** [Node.js](https://nodejs.org/)\n  - Version specified in `.nvmrc` or `.tool-versions` file\n  - Ensure Node.js version matches project requirements before development\n\n## Version Management\n\nAlways check and use the correct Node.js version:\n\n```bash\n# Using nvm\nnvm use\n\n# Using asdf\nasdf install\n```\n\n## TypeScript Configuration\n\nThe project uses strict TypeScript settings. Key requirements:\n\n- Strict mode enabled\n- No implicit `any` types\n- All files must have proper type annotations\n- Use TypeScript interfaces and types instead of `any` or `unknown` where possible\n",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx",
            "**/pages/**",
            "**/next.config.*"
          ]
        },
        {
          "id": "error-handling-patterns",
          "title": "Error Handling Patterns",
          "fileName": "error-handling-patterns.mdc",
          "frontmatter": {
            "description": "Error handling patterns and best practices for the codebase",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# Error Handling Patterns\n\n## Philosophy\n\nErrors are inevitable in any application. Our error handling strategy focuses on:\n1. **Graceful Degradation** - The application should continue functioning even when errors occur\n2. **User-Friendly Feedback** - Users should understand what went wrong without technical jargon\n3. **Developer Debugging** - Errors should contain enough context for debugging\n4. **Security** - Never expose sensitive information in error messages\n\n## Error Types\n\n### 1. Application Errors\n\nCustom error classes for domain-specific errors:\n\n```typescript\n// src/utils/errors/ApplicationError.ts\nexport class ApplicationError extends Error {\n  public readonly statusCode: number;\n  public readonly isOperational: boolean;\n\n  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = this.constructor.name;\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    Error.captureStackTrace(this);\n  }\n}\n\n// Specific error types\nexport class ValidationError extends ApplicationError {\n  constructor(message: string) {\n    super(message, 400);\n  }\n}\n\nexport class AuthenticationError extends ApplicationError {\n  constructor(message: string = 'Authentication failed') {\n    super(message, 401);\n  }\n}\n\nexport class AuthorizationError extends ApplicationError {\n  constructor(message: string = 'Access denied') {\n    super(message, 403);\n  }\n}\n\nexport class NotFoundError extends ApplicationError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 404);\n  }\n}\n\nexport class ConflictError extends ApplicationError {\n  constructor(message: string) {\n    super(message, 409);\n  }\n}\n\nexport class RateLimitError extends ApplicationError {\n  constructor(message: string = 'Too many requests') {\n    super(message, 429);\n  }\n}\n```\n\n### 2. External Service Errors\n\nWrap external service errors with context:\n\n```typescript\n// src/utils/errors/ExternalServiceError.ts\nexport class ExternalServiceError extends ApplicationError {\n  public readonly service: string;\n  public readonly originalError?: any;\n\n  constructor(service: string, message: string, originalError?: any) {\n    super(`${service} error: ${message}`, 503);\n    this.service = service;\n    this.originalError = originalError;\n  }\n}\n\n// Usage\ntry {\n  const result = await supabase.from('users').select();\n  if (result.error) {\n    throw new ExternalServiceError('Supabase', result.error.message, result.error);\n  }\n} catch (error) {\n  // Handle or re-throw\n}\n```\n\n## Error Handling Patterns\n\n### 1. Service Layer Error Handling\n\nServices should handle errors and provide meaningful context:\n\n```typescript\n// src/services/userService.ts\nimport { NotFoundError, ValidationError, ExternalServiceError } from '@/utils/errors';\nimport { getServerLogger } from '@/utils/logger';\n\nconst logger = getServerLogger('Service:UserService');\n\nexport async function getUserProfile(userId: string) {\n  try {\n    // Input validation\n    if (!userId || !isValidUUID(userId)) {\n      throw new ValidationError('Invalid user ID format');\n    }\n\n    const { data, error } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', userId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        throw new NotFoundError('User');\n      }\n      throw new ExternalServiceError('Supabase', error.message, error);\n    }\n\n    return data;\n  } catch (error) {\n    // Log the error with context\n    logger.error('Failed to fetch user profile', {\n      userId,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      stack: error instanceof Error ? error.stack : undefined\n    });\n    \n    // Re-throw application errors\n    if (error instanceof ApplicationError) {\n      throw error;\n    }\n    \n    // Wrap unexpected errors\n    throw new ApplicationError('Failed to fetch user profile', 500);\n  }\n}\n```\n\n### 2. API Route Error Handling\n\nUse a consistent error handler for API routes:\n\n```typescript\n// src/utils/api/errorHandler.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { ApplicationError } from '@/utils/errors';\nimport { getServerLogger } from '@/utils/logger';\n\nconst logger = getServerLogger('API:ErrorHandler');\n\nexport function withErrorHandler(\n  handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>\n) {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    try {\n      await handler(req, res);\n    } catch (error) {\n      // Log error details\n      logger.error('API request failed', {\n        method: req.method,\n        url: req.url,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        stack: error instanceof Error ? error.stack : undefined,\n        userId: (req as any).user?.id\n      });\n\n      // Send appropriate response\n      if (error instanceof ApplicationError) {\n        return res.status(error.statusCode).json({\n          error: {\n            message: error.message,\n            code: error.constructor.name\n          }\n        });\n      }\n\n      // Don't expose internal errors to clients\n      return res.status(500).json({\n        error: {\n          message: 'An unexpected error occurred',\n          code: 'INTERNAL_SERVER_ERROR'\n        }\n      });\n    }\n  };\n}\n\n// Usage in API route\n// src/pages/api/users/[id].ts\nexport default withAuthentication(\n  withErrorHandler(async (req, res) => {\n    const { id } = req.query;\n    const user = await getUserProfile(id as string);\n    res.status(200).json({ data: user });\n  })\n);\n```\n\n### 3. React Error Boundaries\n\nFor catching React component errors:\n\n```typescript\n// src/components/ErrorBoundary.tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\nimport { Box, Heading, Text, Button } from '@chakra-ui/react';\nimport { getClientLogger } from '@/utils/logger/clientLogger';\n\nconst logger = getClientLogger('Component:ErrorBoundary');\n\ninterface Props {\n  children: ReactNode;\n  fallback?: (error: Error, resetError: () => void) => ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    logger.error('React component error', {\n      error: error.message,\n      componentStack: errorInfo.componentStack,\n      stack: error.stack\n    });\n  }\n\n  resetError = () => {\n    this.setState({ hasError: false, error: null });\n  };\n\n  render() {\n    if (this.state.hasError && this.state.error) {\n      if (this.props.fallback) {\n        return this.props.fallback(this.state.error, this.resetError);\n      }\n\n      return (\n        <Box p={8} textAlign=\"center\">\n          <Heading size=\"lg\" mb={4}>Something went wrong</Heading>\n          <Text mb={4}>\n            We're sorry, but something unexpected happened. Please try refreshing the page.\n          </Text>\n          <Button onClick={this.resetError} colorScheme=\"blue\">\n            Try Again\n          </Button>\n        </Box>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage - Wrap critical sections\n// src/pages/_app.tsx\nfunction MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <ErrorBoundary>\n      <Component {...pageProps} />\n    </ErrorBoundary>\n  );\n}\n```\n\n### 4. Client-Side API Error Handling\n\nConsistent error handling for client-side API calls:\n\n```typescript\n// src/utils/api/client.ts\nexport class APIError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'APIError';\n  }\n}\n\nexport async function safeFetch<T>(\n  url: string,\n  options?: RequestInit\n): Promise<T> {\n  try {\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new APIError(\n        errorData.error?.message || 'Request failed',\n        response.status,\n        errorData.error?.code\n      );\n    }\n    \n    return await response.json();\n  } catch (error) {\n    if (error instanceof APIError) {\n      throw error;\n    }\n    \n    // Network errors\n    throw new APIError(\n      'Network error. Please check your connection.',\n      0\n    );\n  }\n}\n```\n\n### 5. Form Error Handling\n\nUsing React Hook Form with Yup validation:\n\n```typescript\n// src/components/forms/UserForm.tsx\nimport { useForm } from 'react-hook-form';\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport { userSchema } from '@/schemas/userSchema';\nimport { useState } from 'react';\nimport { Alert, AlertIcon } from '@chakra-ui/react';\n\nexport function UserForm() {\n  const [submitError, setSubmitError] = useState<string | null>(null);\n  \n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n    setError\n  } = useForm({\n    resolver: yupResolver(userSchema)\n  });\n\n  const onSubmit = async (data: any) => {\n    try {\n      setSubmitError(null);\n      await createUser(data);\n    } catch (error) {\n      if (error instanceof APIError) {\n        // Field-specific errors\n        if (error.code === 'EMAIL_EXISTS') {\n          setError('email', { message: 'Email already exists' });\n        } else {\n          // General form error\n          setSubmitError(error.message);\n        }\n      } else {\n        setSubmitError('An unexpected error occurred. Please try again.');\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {submitError && (\n        <Alert status=\"error\" mb={4}>\n          <AlertIcon />\n          {submitError}\n        </Alert>\n      )}\n      {/* Form fields */}\n    </form>\n  );\n}\n```\n\n## Error Recovery Strategies\n\n### 1. Retry Logic\n\nFor transient failures:\n\n```typescript\n// src/utils/retry.ts\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  options: {\n    maxAttempts?: number;\n    delay?: number;\n    backoff?: number;\n    shouldRetry?: (error: any) => boolean;\n  } = {}\n): Promise<T> {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    backoff = 2,\n    shouldRetry = (error) => error instanceof ExternalServiceError\n  } = options;\n\n  let lastError: any;\n  \n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      \n      if (attempt === maxAttempts || !shouldRetry(error)) {\n        throw error;\n      }\n      \n      const waitTime = delay * Math.pow(backoff, attempt - 1);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n  }\n  \n  throw lastError;\n}\n\n// Usage\nconst data = await withRetry(() => fetchUserData(userId), {\n  shouldRetry: (error) => error.statusCode === 503\n});\n```\n\n### 2. Fallback Values\n\nProvide sensible defaults:\n\n```typescript\n// src/hooks/useUserPreferences.ts\nexport function useUserPreferences() {\n  const [preferences, setPreferences] = useState(DEFAULT_PREFERENCES);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    fetchUserPreferences()\n      .then(setPreferences)\n      .catch((error) => {\n        logger.warn('Failed to load user preferences, using defaults', { error });\n        setError(error);\n        // Keep using default preferences\n      });\n  }, []);\n\n  return { preferences, error };\n}\n```\n\n### 3. Circuit Breaker\n\nPrevent cascading failures:\n\n```typescript\n// src/utils/circuitBreaker.ts\nexport class CircuitBreaker {\n  private failures = 0;\n  private lastFailureTime = 0;\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n\n  constructor(\n    private threshold: number = 5,\n    private timeout: number = 60000\n  ) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'HALF_OPEN';\n      } else {\n        throw new Error('Circuit breaker is OPEN');\n      }\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess() {\n    this.failures = 0;\n    this.state = 'CLOSED';\n  }\n\n  private onFailure() {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failures >= this.threshold) {\n      this.state = 'OPEN';\n    }\n  }\n}\n```\n\n## Error Monitoring\n\n### 1. Structured Error Logging\n\nAlways include context:\n\n```typescript\nlogger.error('Operation failed', {\n  operation: 'createWorkflow',\n  userId: req.user.id,\n  workflowData: { name: workflow.name }, // Don't log sensitive data\n  error: {\n    message: error.message,\n    code: error.code,\n    stack: error.stack\n  },\n  timestamp: new Date().toISOString()\n});\n```\n\n### 2. Error Aggregation\n\nTrack error patterns:\n\n```typescript\n// src/utils/errorTracking.ts\nexport function trackError(error: Error, context: Record<string, any> = {}) {\n  // In production, send to error tracking service\n  if (process.env.NODE_ENV === 'production') {\n    // e.g., Sentry, LogRocket, etc.\n    // Sentry.captureException(error, { extra: context });\n  }\n  \n  // Always log locally\n  logger.error('Tracked error', { error, context });\n}\n```\n\n## Best Practices\n\n1. **Be Specific** - Create specific error types for different scenarios\n2. **Add Context** - Include relevant IDs, operations, and state in error logs\n3. **User-Friendly Messages** - Separate technical errors from user-facing messages\n4. **Don't Swallow Errors** - Always handle errors explicitly\n5. **Test Error Paths** - Include error scenarios in your tests\n6. **Document Errors** - Document possible errors in function JSDoc\n7. **Fail Fast** - Validate inputs early and throw immediately\n8. **Graceful Degradation** - Provide fallbacks where possible\n9. **Security First** - Never expose sensitive data in error messages\n10. **Monitor Proactively** - Set up alerts for error spikes\n\n## Common Patterns to Avoid\n\n```typescript\n// ‚ùå BAD - Silent failures\ntry {\n  await riskyOperation();\n} catch (error) {\n  // Silently ignoring errors\n}\n\n// ‚ùå BAD - Generic error messages\nthrow new Error('Error occurred');\n\n// ‚ùå BAD - Exposing internals\nres.status(500).json({ error: error.stack });\n\n// ‚ùå BAD - Inconsistent error handling\nif (!user) return res.status(404).json({ msg: 'Not found' });\nif (!valid) return res.status(400).send('Bad request');\n\n// ‚úÖ GOOD - Consistent, informative errors\nif (!user) throw new NotFoundError('User');\nif (!valid) throw new ValidationError('Invalid input format');\n```",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        },
        {
          "id": "frontend",
          "title": "Frontend",
          "fileName": "frontend.mdc",
          "frontmatter": {
            "description": "Frontend technology stack, libraries, and usage patterns",
            "globs": [
              "**/components/**",
              "**/pages/**",
              "**/*.tsx",
              "**/styles/**"
            ],
            "alwaysApply": true
          },
          "content": "# Frontend Technology Stack\n\n## Overview\n\nThis document defines the frontend technologies, libraries, and patterns used in the application. All frontend code should align with these specifications.\n\n## UI Library\n\n**Library:** [Chakra UI](https://chakra-ui.com/)\n\n- Used for building user interface components\n- Handles styling, theming, and color modes\n- Custom theme defined in `src/styles/CustomTheme.tsx`\n- Provides accessible, composable components out of the box\n\n**Usage Pattern:**\n\n```typescript\nimport { Box, Button, Text, VStack } from '@chakra-ui/react';\n\nexport function MyComponent() {\n  return (\n    <Box p={4}>\n      <VStack spacing={4}>\n        <Text>Hello World</Text>\n        <Button colorScheme=\"blue\">Click me</Button>\n      </VStack>\n    </Box>\n  );\n}\n```\n\n## Styling\n\n**Approach:** Multi-layered styling strategy\n\n1. **CSS Modules** - For component-specific styles (e.g., `calendar-styles.module.css`)\n2. **Chakra UI Style Props** - For inline styling using Chakra's prop-based API\n3. **Emotion** - Via Chakra UI for advanced styling needs\n4. **Global Styles** - Defined in `src/styles/globals.css`\n\n**When to Use Each:**\n\n- **CSS Modules:** Complex component-specific styles, animations, or when you need CSS-specific features\n- **Chakra Props:** Quick styling, responsive design, theme integration\n- **Emotion:** Advanced dynamic styling, complex selectors, or when CSS Modules aren't sufficient\n\n## State Management\n\n**Global State:** [Zustand](https://github.com/pmndrs/zustand)\n\n- Used for global application state (e.g., `useUserDataStore`, `useCurrentPanel`)\n- See `state-management-patterns.mdc` for detailed patterns\n- Keep stores focused and use selective subscriptions for performance\n\n**Local State:** React hooks\n\n- Use `useState` for component-specific UI state\n- Use `useEffect` for side effects and lifecycle management\n- Keep UI-only state local, not in global stores\n\n**Example:**\n\n```typescript\n// Global state - Zustand\nimport { useUserDataStore } from '@/stores/userStore';\n\nfunction UserProfile() {\n  const user = useUserDataStore((state) => state.user);\n  // ...\n}\n\n// Local state - React hooks\nfunction Dropdown() {\n  const [isOpen, setIsOpen] = useState(false);\n  // ...\n}\n```\n\n## Data Fetching (Client-Side)\n\n**Primary:** Standard `fetch` API wrapped in custom utilities\n\n- `authenticatedGet` - GET requests with auth headers\n- `authenticatedPost` - POST requests with auth headers\n- `safeFetch` - Fetch wrapper with error handling\n- Located in `src/utils/api/`\n\n**Secondary:** [Axios](https://axios-http.com/)\n\n- Used in specific cases (e.g., Twitter callback)\n- Only use when `fetch` utilities don't meet requirements\n\n**Example:**\n\n```typescript\nimport { authenticatedGet, authenticatedPost } from '@/utils/api';\n\n// GET request\nconst user = await authenticatedGet<User>('/api/users/me');\n\n// POST request\nconst result = await authenticatedPost('/api/workflows', {\n  name: 'My Workflow',\n  steps: []\n});\n```\n\n## Form Handling\n\n**Library:** [React Hook Form](https://react-hook-form.com/)\n\n- Used for managing form state and validation\n- Examples: `SignUpForm`, `CharacterForm`\n- Integrates with Yup for schema validation\n- Provides performant form handling with minimal re-renders\n\n**Example:**\n\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport { userSchema } from '@/schemas/userSchema';\n\nexport function UserForm() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors }\n  } = useForm({\n    resolver: yupResolver(userSchema)\n  });\n\n  const onSubmit = async (data: FormData) => {\n    await createUser(data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* form fields */}\n    </form>\n  );\n}\n```\n\n## Drag & Drop\n\n**Library:** [React DnD](https://react-dnd.github.io/react-dnd/)\n\n- Used for reordering elements\n- Primary use case: Workflow builder (`WorkflowSteps`)\n- Provides accessible drag and drop functionality\n\n## Calendar\n\n**Library:** [React Calendar](https://github.com/wojtekmaj/react-calendar)\n\n- Used for date selection and calendar displays\n- Styled with CSS Modules (e.g., `calendar-styles.module.css`)\n\n## Best Practices\n\n1. **Component Organization:** Use modular component structure (see `key-architecture-patterns.mdc`)\n2. **State Management:** Prefer local state, use Zustand only for global concerns\n3. **Styling:** Use Chakra props first, CSS Modules for complex cases\n4. **Forms:** Always use React Hook Form with Yup validation\n5. **Data Fetching:** Use custom fetch utilities, not raw `fetch` or Axios directly\n6. **Accessibility:** Leverage Chakra UI's built-in accessibility features\n",
          "alwaysApply": true,
          "globs": [
            "**/components/**",
            "**/pages/**",
            "**/*.tsx",
            "**/styles/**"
          ]
        },
        {
          "id": "git-workflow",
          "title": "Git Workflow",
          "fileName": "git-workflow.mdc",
          "frontmatter": {
            "description": "Git workflow, commit message conventions, and version control best practices",
            "globs": [
              "**/.git/**",
              "**/.gitignore"
            ],
            "alwaysApply": true
          },
          "content": "# Git Workflow Guidelines\n\n## Commit Message Format\n\nFollow the [Conventional Commits](https://www.conventionalcommits.org/) specification for consistent commit messages.\n\n### Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- **`feat`**: A new feature\n- **`fix`**: A bug fix\n- **`docs`**: Documentation only changes\n- **`style`**: Code style changes (formatting, missing semicolons, etc.)\n- **`refactor`**: Code refactoring without bug fixes or features\n- **`perf`**: Performance improvements\n- **`test`**: Adding or updating tests\n- **`chore`**: Maintenance tasks, dependency updates\n- **`build`**: Build system or external dependencies\n- **`ci`**: CI/CD configuration changes\n\n### Examples\n\n```bash\n# Feature\nfeat(auth): add JWT token refresh mechanism\n\n# Bug fix\nfix(api): resolve user profile null reference error\n\n# Breaking change\nfeat(api)!: change user endpoint response format\n\nBREAKING CHANGE: The user endpoint now returns nested user object instead of flat structure\n\n# Multiple changes\nfeat(workflows): add workflow execution history\n\n- Add history tracking in workflow service\n- Create history API endpoint\n- Update UI to display execution history\n```\n\n### Scope\n\nUse scope to indicate which part of the codebase is affected:\n\n- `api`: API routes and handlers\n- `auth`: Authentication and authorization\n- `ui`: Frontend components\n- `store`: State management (Zustand stores)\n- `service`: Service layer functions\n- `utils`: Utility functions\n- `config`: Configuration files\n- `deps`: Dependencies\n\n### Subject\n\n- Use imperative mood (\"add\" not \"added\" or \"adds\")\n- First line should be 50 characters or less\n- Don't end with a period\n- Be specific and descriptive\n\n### Body (Optional)\n\n- Explain the \"what\" and \"why\" vs \"how\"\n- Wrap at 72 characters\n- Can include multiple paragraphs\n\n### Footer (Optional)\n\n- Reference issues: `Closes #123`, `Fixes #456`\n- Breaking changes: `BREAKING CHANGE: <description>`\n\n## Branch Naming\n\n### Format\n\n```\n<type>/<description>\n```\n\n### Types\n\n- `feature/`: New features\n- `fix/`: Bug fixes\n- `hotfix/`: Critical production fixes\n- `refactor/`: Code refactoring\n- `docs/`: Documentation updates\n- `test/`: Test additions/updates\n\n### Examples\n\n```bash\nfeature/user-profile-editor\nfix/api-authentication-error\nhotfix/critical-data-loss-bug\nrefactor/workflow-service-layer\n```\n\n## Commit Best Practices\n\n### ‚úÖ DO\n\n- Make atomic commits (one logical change per commit)\n- Write clear, descriptive commit messages\n- Commit frequently (small, incremental changes)\n- Test before committing\n- Review your changes with `git diff` before committing\n\n### ‚ùå DON'T\n\n- Commit commented-out code\n- Commit debugging code or console.logs\n- Commit with lint errors (see `no-hiding.mdc`)\n- Mix unrelated changes in one commit\n- Commit secrets or sensitive data\n- Force push to main/master branch\n\n## Workflow\n\n### 1. Create Feature Branch\n\n```bash\ngit checkout -b feature/my-new-feature\n```\n\n### 2. Make Changes\n\n- Write code following all guidelines\n- Ensure no lint errors\n- Test your changes\n\n### 3. Stage Changes\n\n```bash\n# Review what you're committing\ngit status\ngit diff\n\n# Stage specific files\ngit add path/to/file.ts\n\n# Or stage all changes\ngit add .\n```\n\n### 4. Commit\n\n```bash\ngit commit -m \"feat(scope): descriptive message\"\n```\n\n### 5. Push and Create PR\n\n```bash\ngit push origin feature/my-new-feature\n```\n\nThen create a Pull Request with:\n- Clear title matching commit message format\n- Description explaining the change\n- Reference to related issues\n- Screenshots for UI changes\n\n## Pull Request Guidelines\n\n### PR Title\n\nFollow the same format as commit messages:\n\n```\nfeat(auth): add password reset functionality\n```\n\n### PR Description Template\n\n```markdown\n## Description\nBrief description of what this PR does.\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Testing\n- [ ] Tests pass locally\n- [ ] Manual testing completed\n- [ ] Edge cases considered\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] No lint errors\n- [ ] Self-review completed\n- [ ] Comments added for complex logic\n- [ ] Documentation updated if needed\n```\n\n## Handling Conflicts\n\n### When Your Branch is Behind\n\n```bash\n# Fetch latest changes\ngit fetch origin\n\n# Rebase your branch on main\ngit checkout feature/my-feature\ngit rebase origin/main\n\n# Resolve conflicts if any\n# Then continue rebase\ngit rebase --continue\n\n# Force push (only on feature branches)\ngit push --force-with-lease origin feature/my-feature\n```\n\n## Git Ignore\n\nEnsure these are in `.gitignore`:\n\n```\n# Dependencies\nnode_modules/\n.pnp\n.pnp.js\n\n# Testing\ncoverage/\n.nyc_output\n\n# Production\nbuild/\ndist/\n.next/\nout/\n\n# Environment variables\n.env\n.env.local\n.env*.local\n\n# IDE\n.vscode/\n.idea/\n*.swp\n*.swo\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\nlogs/\n*.log\nnpm-debug.log*\n\n# Temporary files\n*.tmp\n.cache/\n```\n\n## Common Commands\n\n```bash\n# Check status\ngit status\n\n# View changes\ngit diff\ngit diff --staged\n\n# View commit history\ngit log --oneline --graph\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Undo last commit (discard changes)\ngit reset --hard HEAD~1\n\n# Stash changes\ngit stash\ngit stash pop\n\n# View stashes\ngit stash list\n```\n\n## Remember\n\n- **Small, frequent commits** are better than large, infrequent ones\n- **Clear commit messages** help future you and your team\n- **Test before committing** to avoid broken commits\n- **Review your changes** with `git diff` before committing\n- **Never commit secrets** or sensitive data\n",
          "alwaysApply": true,
          "globs": [
            "**/.git/**",
            "**/.gitignore"
          ]
        },
        {
          "id": "key-architecture-patterns",
          "title": "Key Architecture Patterns",
          "fileName": "key-architecture-patterns.mdc",
          "frontmatter": {
            "description": "Key architectural patterns and organizational principles for the codebase",
            "globs": [
              "**/services/**",
              "**/utils/**",
              "**/components/modules/**",
              "**/*Registry*.ts",
              "**/*registry*.ts"
            ],
            "alwaysApply": true
          },
          "content": "# Key Architectural Patterns\n\n## Overview\n\nThis document outlines the core architectural patterns used throughout the codebase. These patterns ensure consistency, maintainability, and separation of concerns.\n\n## Service Layer Pattern\n\n**Purpose:** Encapsulate business logic and complex data access operations.\n\n**Location:** `src/services/` directory\n\n**Principles:**\n- API routes should be thin wrappers that delegate to service functions\n- All business logic lives in services, not in API route handlers\n- Services handle data transformation, validation, and external API calls\n- Services are pure functions that can be easily tested\n\n**Example:**\n\n```typescript\n// ‚ùå BAD - Business logic in API route\n// src/pages/api/users/[id].ts\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { data, error } = await supabase\n    .from('users')\n    .select('*')\n    .eq('id', req.query.id)\n    .single();\n  \n  if (error) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  \n  // Business logic mixed with route handling\n  const processedData = {\n    ...data,\n    displayName: `${data.firstName} ${data.lastName}`,\n    isActive: data.status === 'active'\n  };\n  \n  res.json(processedData);\n}\n\n// ‚úÖ GOOD - Business logic in service\n// src/services/userService.ts\nexport async function getUserProfile(userId: string): Promise<UserProfile> {\n  const { data, error } = await supabase\n    .from('users')\n    .select('*')\n    .eq('id', userId)\n    .single();\n  \n  if (error) {\n    throw new NotFoundError('User');\n  }\n  \n  return {\n    ...data,\n    displayName: `${data.firstName} ${data.lastName}`,\n    isActive: data.status === 'active'\n  };\n}\n\n// src/pages/api/users/[id].ts\nexport default withErrorHandler(async (req, res) => {\n  const user = await getUserProfile(req.query.id as string);\n  res.json(user);\n});\n```\n\n## Utility Functions Pattern\n\n**Purpose:** Organize reusable, lower-level helper functions.\n\n**Location:** `src/utils/` directory, organized by category\n\n**Structure:**\n\n```\nsrc/utils/\n‚îú‚îÄ‚îÄ api/          # API-related utilities (fetch wrappers, HOFs)\n‚îú‚îÄ‚îÄ auth/        # Authentication utilities\n‚îú‚îÄ‚îÄ formatters/  # Data formatting functions\n‚îú‚îÄ‚îÄ validators/  # Validation helpers\n‚îî‚îÄ‚îÄ helpers/     # General utility functions\n```\n\n**Principles:**\n- Pure functions when possible (no side effects)\n- Single responsibility per function\n- Well-documented with JSDoc\n- Reusable across the codebase\n\n**Example:**\n\n```typescript\n// src/utils/formatters/currency.ts\n/**\n * Formats a number as currency in the specified locale.\n *\n * @param amount - The amount to format\n * @param currency - ISO currency code (default: 'USD')\n * @param locale - Locale string (default: 'en-US')\n * @returns Formatted currency string\n */\nexport function formatCurrency(\n  amount: number,\n  currency: string = 'USD',\n  locale: string = 'en-US'\n): string {\n  return new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency,\n  }).format(amount);\n}\n```\n\n## Modular Components Pattern\n\n**Purpose:** Group feature-specific UI components together.\n\n**Location:** `src/components/modules/` directory\n\n**Structure:**\n\n```\nsrc/components/modules/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ SignUpForm.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ PasswordReset.tsx\n‚îú‚îÄ‚îÄ workflows/\n‚îÇ   ‚îú‚îÄ‚îÄ WorkflowBuilder.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ WorkflowSteps.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ WorkflowCard.tsx\n‚îî‚îÄ‚îÄ users/\n    ‚îú‚îÄ‚îÄ UserProfile.tsx\n    ‚îî‚îÄ‚îÄ UserList.tsx\n```\n\n**Principles:**\n- Group related components by feature/domain\n- Keep components focused and composable\n- Share types and utilities within the module\n- Export through index files for clean imports\n\n**Example:**\n\n```typescript\n// src/components/modules/workflows/index.ts\nexport { WorkflowBuilder } from './WorkflowBuilder';\nexport { WorkflowSteps } from './WorkflowSteps';\nexport { WorkflowCard } from './WorkflowCard';\nexport type { Workflow, WorkflowStep } from './types';\n\n// Usage\nimport { WorkflowBuilder, type Workflow } from '@/components/modules/workflows';\n```\n\n## Registry Pattern\n\n**Purpose:** Manage dynamic collections of components, executors, or handlers.\n\n**Examples:** `ActionRegistry`, `DatasetRegistry`, `WorkflowRegistry`\n\n**Principles:**\n- Centralized registration and lookup\n- Type-safe registration and retrieval\n- Supports dynamic loading and extension\n- Clear interface for registration and discovery\n\n**Example:**\n\n```typescript\n// src/utils/registries/ActionRegistry.ts\ntype ActionHandler = (params: Record<string, unknown>) => Promise<unknown>;\n\nclass ActionRegistry {\n  private actions = new Map<string, ActionHandler>();\n\n  register(name: string, handler: ActionHandler): void {\n    if (this.actions.has(name)) {\n      throw new Error(`Action \"${name}\" is already registered`);\n    }\n    this.actions.set(name, handler);\n  }\n\n  get(name: string): ActionHandler {\n    const handler = this.actions.get(name);\n    if (!handler) {\n      throw new NotFoundError(`Action \"${name}\" not found`);\n    }\n    return handler;\n  }\n\n  list(): string[] {\n    return Array.from(this.actions.keys());\n  }\n}\n\nexport const actionRegistry = new ActionRegistry();\n```\n\n## Best Practices\n\n1. **Separation of Concerns:** Keep API routes thin, services focused, and utilities reusable\n2. **Single Responsibility:** Each module/function should do one thing well\n3. **Testability:** Architecture should make testing easy (services are pure, utilities are isolated)\n4. **Consistency:** Follow these patterns consistently across the codebase\n5. **Documentation:** Document architectural decisions and patterns in code comments\n",
          "alwaysApply": true,
          "globs": [
            "**/services/**",
            "**/utils/**",
            "**/components/modules/**",
            "**/*Registry*.ts",
            "**/*registry*.ts"
          ]
        },
        {
          "id": "logging-guidelines",
          "title": "Logging Guidelines",
          "fileName": "logging-guidelines.mdc",
          "frontmatter": {
            "description": "Logging standards for server-side and client-side code with emphasis on minimal logging by default",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# Logging Guidelines\n\n## Introduction\n\n### ‚ö†Ô∏è CRITICAL DEFAULT BEHAVIOR\n\n**BY DEFAULT: DO NOT ADD LOGS TO YOUR CODE**\n\n**Only add logging when:**\n1. Explicitly requested by the user/stakeholder\n2. Debugging a specific issue (temporary, remove after resolution)\n3. Required for production monitoring (errors, critical operations)\n\n**Default behavior when writing code:**\n- ‚úÖ Write code without logging statements\n- ‚úÖ Focus on proper error handling instead of logging\n- ‚úÖ Use TypeScript types and error boundaries for debugging\n- ‚ùå Do NOT add `logger.info()`, `logger.debug()`, or `console.log()` by default\n- ‚ùå Do NOT add logging \"just in case\" or for future debugging\n\n**When logging IS needed (after explicit request):**\nFollow all guidelines below for proper logging implementation.\n\n---\n\nThis document outlines the mandatory rules and best practices for implementing logging within the Next.js application using the configured logging system. Adherence to these guidelines is crucial for maintaining consistent, informative, and manageable logs across both server-side and client-side code.\n\nThe primary goals are:\n\n1.  **Consistency:** Ensure logs follow a standard format and approach.\n2.  **Context:** Provide sufficient context within logs for effective debugging.\n3.  **Performance:** Avoid negatively impacting application performance, especially with client-side logging.\n4.  **Security:** Prevent logging sensitive information.\n5.  **Manageability:** Structure logs appropriately for different environments and potential aggregation tools.\n\n## General Logging Principles\n\n- **Context is Key:** Always include relevant context in your log messages. Use the provided logger factory functions (`getServerLogger`, `getClientLogger`) to automatically include module/component context. Manually add other relevant IDs (e.g., `userId`, `requestId`, `workflowId`, `tweetId`) where applicable.\n- **Appropriate Levels:** Use the correct log level (`error`, `warn`, `info`, `debug`) based on the severity and purpose of the message. See the \"Log Levels\" section below for specific guidance.\n- **Be Descriptive:** Log messages should clearly explain the event or state being logged.\n- **Avoid Sensitive Data:** **NEVER** log passwords, API keys, full access tokens, personally identifiable information (PII), or other sensitive credentials. Mask or omit this data.\n- **Structured Data (Server):** When logging on the server, provide additional context as a metadata object (the second argument to logger methods). This aids machine parsing, even though the default console output is formatted text.\n- **Error Objects:** When logging errors, log the `Error` object itself to capture stack traces (e.g., `logger.error('Operation failed', { error: err });`).\n\n## Server-Side Logging (`getServerLogger`)\n\n**When to Use:**\n\n- API Routes (`src/pages/api/`)\n- Route Handlers (App Router)\n- Server Components (App Router)\n- `getServerSideProps` (Pages Router)\n- Server Actions (App Router)\n- Middleware\n\n**How to Use:**\n\n1.  **Import:** Import the factory function:\n    ```typescript\n    import { getServerLogger } from \"@/utils/logger\";\n    ```\n2.  **Instantiate:** Create a logger instance at the top of the module, providing a descriptive `moduleName`:\n    ```typescript\n    const logger = getServerLogger(\"API:/api/users/getUser\"); // Example: API Route\n    // const logger = getServerLogger('Component:UserProfileServer'); // Example: Server Component\n    // const logger = getServerLogger('Service:AuthService'); // Example: Utility/Service\n    ```\n3.  **Log Messages:** Use the appropriate level methods (`error`, `warn`, `info`, `debug`):\n    ```typescript\n    logger.info('Processing user request', { userId: 'user-123', action: 'updateProfile' });\n    // ... later ...\n    if (potentialIssue) {\n        logger.warn('Potential issue detected during update', { userId: 'user-123', details: '...' });\n    }\n    // ... on error ...\n    catch (error) {\n        logger.error('Failed to update user profile', { userId: 'user-123', error: error }); // Pass the error object\n    }\n    ```\n\n**What to Log (Server-Side):**\n\n- API request start/end (consider `http` level).\n- Significant state changes or operations (e.g., user signup, workflow execution start/end).\n- Successful completion of critical tasks.\n- Errors and exceptions (always include the error object and stack trace).\n- Warnings about potential issues or deprecated usage.\n- Detailed debugging information (`debug` level) for development tracing.\n\n## Client-Side Logging (`getClientLogger`)\n\n**When to Use:**\n\n- Client Components (`\"use client\";` directive or Pages Router components rendered client-side).\n- `useEffect` hooks running in the browser.\n- Event handlers (`onClick`, `onChange`, etc.) executed in the browser.\n- Browser-specific API interactions.\n\n**How to Use:**\n\n1.  **Import:** Import the factory function:\n    ```typescript\n    import { getClientLogger } from \"@/utils/logger/clientLogger\";\n    ```\n2.  **Instantiate:** Create a logger instance at the top of the component or hook, providing a descriptive `componentName`:\n    ```typescript\n    const logger = getClientLogger(\"Component:AuthForm\");\n    // const logger = getClientLogger('Hook:useWorkflowForm');\n    ```\n3.  **Log Messages:** Use the appropriate level methods (`error`, `warn`, `info`, `debug`):\n\n    - **`logger.error(message, meta)`:** Logs to the browser console AND sends the log to the `/api/log` endpoint (using `authenticatedPost`). **Use for actual errors encountered by the user.**\n    - **`logger.warn(message, meta)`:** Logs to the browser console. Currently _does not_ send to the server by default (can be enabled in `clientLogger.ts`). **Use sparingly for important warnings.**\n    - **`logger.info(message, meta)`:** Logs to the browser console only. **Use for general component lifecycle or state information during development.**\n    - **`logger.debug(message, meta)`:** Logs to the browser console _only_ during development (`process.env.NODE_ENV === 'development'`). **Use for detailed debugging.**\n\n    ```typescript\n    // Example in a component\n    const handleSubmit = async () => {\n      logger.info(\"Submit button clicked\"); // Console only\n      try {\n        // ... form submission logic ...\n      } catch (error) {\n        logger.error(\"Form submission failed\", {\n          formId: \"signup\",\n          error: error,\n        }); // Sends to server\n      }\n    };\n    ```\n\n**What to Log (Client-Side - Sending to Server):**\n\n- **Critical Errors:** Uncaught exceptions within components (use Error Boundaries or try/catch), failed API calls initiated by the client, significant UI state errors preventing user action.\n- **Important Warnings (Optional):** Maybe specific warnings indicating potential data loss or severe usability issues, but be _very_ selective.\n\n**What to Log (Client-Side - Browser Console Only):**\n\n- Component lifecycle events (`info`, `debug`).\n- State changes during development (`debug`).\n- User interaction events during development (`debug`).\n- Temporary debugging messages (`debug`).\n\n**Performance Warning:** Sending logs from the client uses network resources and server processing time. **DO NOT** send `info` or `debug` logs to the server in production. Be cautious even with `warn` logs. Over-logging from the client can degrade user experience and overload the `/api/log` endpoint.\n\n## Log Levels Guidance\n\nUse log levels consistently:\n\n- **`error` (0):** For actual errors, application failures, exceptions caught in `catch` blocks, failed critical operations (e.g., failed DB write, failed critical API call). **These are essential for production monitoring.**\n- **`warn` (1):** For potential problems, unexpected situations that don't crash the app, use of deprecated features, non-critical API failures (e.g., optional data fetch failed). **Use judiciously in production.**\n- **`info` (2):** For high-level application lifecycle events (e.g., \"Server started\", \"User logged in\", \"Workflow started/completed\"), successful completion of major operations. **Should be relatively low volume in production.**\n- **`http` (3):** For logging server-side HTTP requests and responses (method, URL, status code, duration). Often handled by middleware.\n- **`debug` (5):** For detailed diagnostic information useful only during development and troubleshooting (e.g., variable values, function entry/exit, detailed state changes). **Should NOT be enabled in production.**\n\n**Rule:** The configured `LOG_LEVEL` environment variable determines the _maximum_ level that will be processed. Messages logged at a level _numerically higher_ than the configured level will be ignored (e.g., if `LOG_LEVEL=info`, `debug` messages won't be processed).\n\n## Conclusion\n\nYou **MUST** use the `getServerLogger(moduleName)` function for all server-side logging and the `getClientLogger(componentName)` function for all client-side logging. Adhere strictly to the guidelines on what to log and which levels to use, especially regarding client-side logging sent to the server. This ensures our logs remain valuable, performant, and secure.\n",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        },
        {
          "id": "no-hiding",
          "title": "No Hiding",
          "fileName": "no-hiding.mdc",
          "frontmatter": {
            "description": "Critical rule requiring all lint errors to be fully resolved, never suppressed or hidden",
            "globs": [
              "**/*.ts",
              "**/*.tsx",
              "**/*.js",
              "**/*.jsx"
            ],
            "alwaysApply": true
          },
          "content": "# No Hiding Rule\n\n## Critical Principle\n\n**NEVER hide lint errors. You MUST solve them fully.**\n\nThis is a non-negotiable rule that ensures code quality, maintainability, and prevents technical debt from accumulating.\n\n## What This Means\n\n### ‚ùå NEVER Do This\n\n```typescript\n// ‚ùå BAD - Suppressing lint errors\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction processData(data: any) {\n  // ...\n}\n\n// ‚ùå BAD - Ignoring TypeScript errors\n// @ts-ignore\nconst result = unsafeOperation();\n\n// ‚ùå BAD - Using type assertions to bypass errors\nconst value = (data as unknown as TargetType).property;\n\n// ‚ùå BAD - Commenting out problematic code instead of fixing\n// const brokenCode = somethingThatErrors();\n```\n\n### ‚úÖ ALWAYS Do This\n\n```typescript\n// ‚úÖ GOOD - Fix the root cause\nfunction processData<T>(data: T): ProcessedData<T> {\n  // Properly typed implementation\n}\n\n// ‚úÖ GOOD - Add proper type guards\nif (isTargetType(data)) {\n  const result = safeOperation(data);\n}\n\n// ‚úÖ GOOD - Use proper type narrowing\nif (data && typeof data === 'object' && 'property' in data) {\n  const value = data.property;\n}\n\n// ‚úÖ GOOD - Refactor to eliminate the error\nconst fixedCode = properlyImplementedFunction();\n```\n\n## Why This Rule Exists\n\n1. **Code Quality:** Lint errors indicate real problems that need attention\n2. **Type Safety:** TypeScript errors prevent runtime bugs\n3. **Maintainability:** Hidden errors create confusion for future developers\n4. **Technical Debt:** Suppressing errors accumulates problems over time\n5. **Team Consistency:** Everyone follows the same quality standards\n\n## Common Scenarios and Solutions\n\n### Scenario 1: TypeScript `any` Type\n\n**Problem:**\n```typescript\n// Lint error: Don't use 'any' type\nfunction process(data: any) {\n  return data.value;\n}\n```\n\n**Solution:**\n```typescript\n// Use generics or proper types\nfunction process<T extends { value: unknown }>(data: T): T['value'] {\n  return data.value;\n}\n\n// Or create a proper interface\ninterface ProcessableData {\n  value: unknown;\n}\n\nfunction process(data: ProcessableData): unknown {\n  return data.value;\n}\n```\n\n### Scenario 2: Unused Variables\n\n**Problem:**\n```typescript\n// Lint error: 'unusedVar' is assigned but never used\nconst unusedVar = expensiveOperation();\n```\n\n**Solution:**\n```typescript\n// Remove if truly unused\nconst result = expensiveOperation();\n// Use the result or remove the variable\n\n// Or prefix with underscore if intentionally unused (sparingly)\nconst _unusedVar = expensiveOperation(); // Only if you have a good reason\n```\n\n### Scenario 3: Missing Return Types\n\n**Problem:**\n```typescript\n// Lint error: Missing return type annotation\nfunction calculateTotal(items) {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n```\n\n**Solution:**\n```typescript\nfunction calculateTotal(items: Item[]): number {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n```\n\n### Scenario 4: Console Statements\n\n**Problem:**\n```typescript\n// Lint error: Unexpected console statement\nconsole.log('Debug info', data);\n```\n\n**Solution:**\n```typescript\n// Use proper logging (only when requested - see logging-guidelines.mdc)\nimport { getClientLogger } from '@/utils/logger/clientLogger';\nconst logger = getClientLogger('Component:MyComponent');\nlogger.debug('Debug info', { data });\n```\n\n### Scenario 5: Non-null Assertions\n\n**Problem:**\n```typescript\n// Lint error: Forbidden non-null assertion\nconst value = data!.property;\n```\n\n**Solution:**\n```typescript\n// Use proper null checking\nif (!data) {\n  throw new Error('Data is required');\n}\nconst value = data.property;\n\n// Or use optional chaining with defaults\nconst value = data?.property ?? defaultValue;\n```\n\n## Enforcement\n\nThis rule is enforced through:\n\n1. **Linter Configuration:** ESLint and TypeScript strict mode catch violations\n2. **Pre-commit Hooks:** Code cannot be committed with lint errors\n3. **CI/CD Pipeline:** Builds fail if lint errors exist\n4. **Code Reviews:** Reviewers must ensure no errors are suppressed\n\n## When You Encounter Lint Errors\n\n1. **Read the Error:** Understand what the linter is complaining about\n2. **Understand Why:** Consider why the rule exists\n3. **Fix Properly:** Address the root cause, not the symptom\n4. **Ask for Help:** If unsure how to fix, ask the team rather than suppressing\n5. **Document:** If a fix requires a non-obvious approach, add a comment explaining why\n\n## Exceptions\n\n**There are NO exceptions to this rule.**\n\nIf you believe a lint rule is incorrect or too strict:\n1. Discuss with the team\n2. Update the lint configuration if there's consensus\n3. Never suppress errors on a case-by-case basis\n\n## Related Guidelines\n\n- **Styling Guidelines:** Follow code style to prevent many lint errors\n- **TypeScript Best Practices:** Proper typing prevents type-related errors\n- **Commenting Guidelines:** Good comments help explain non-obvious code that might trigger lints\n\n## Remember\n\n**Every suppressed error is a future bug waiting to happen.**\n\nFix errors properly, and your codebase will be cleaner, safer, and easier to maintain.",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx",
            "**/*.js",
            "**/*.jsx"
          ]
        },
        {
          "id": "performance-guidelines",
          "title": "Performance Guidelines",
          "fileName": "performance-guidelines.mdc",
          "frontmatter": {
            "description": "Performance optimization guidelines for React and Next.js applications",
            "globs": [
              "**/*.tsx",
              "**/*.ts",
              "**/pages/**",
              "**/components/**"
            ],
            "alwaysApply": true
          },
          "content": "# Performance Guidelines\n\n## Philosophy\n\nPerformance directly impacts user experience and business metrics. Our optimization strategy focuses on:\n1. **Measure First** - Never optimize without data\n2. **User-Centric** - Optimize for perceived performance\n3. **Progressive Enhancement** - Fast baseline, enhanced experience\n4. **Bundle Size Awareness** - Every KB matters\n\n## Core Web Vitals\n\nFocus on these key metrics:\n- **LCP (Largest Contentful Paint)** - Target: < 2.5s\n- **FID (First Input Delay)** - Target: < 100ms\n- **CLS (Cumulative Layout Shift)** - Target: < 0.1\n\n## React Performance Patterns\n\n### 1. Component Optimization\n\n#### React.memo for Expensive Components\n\n```typescript\n// ‚ùå BAD - Re-renders on every parent render\nexport function ExpensiveList({ items, userId }: Props) {\n  return (\n    <VStack>\n      {items.map(item => (\n        <ComplexItem key={item.id} item={item} userId={userId} />\n      ))}\n    </VStack>\n  );\n}\n\n// ‚úÖ GOOD - Only re-renders when props change\nexport const ExpensiveList = React.memo(({ items, userId }: Props) => {\n  return (\n    <VStack>\n      {items.map(item => (\n        <ComplexItem key={item.id} item={item} userId={userId} />\n      ))}\n    </VStack>\n  );\n}, (prevProps, nextProps) => {\n  // Custom comparison if needed\n  return prevProps.userId === nextProps.userId && \n         prevProps.items.length === nextProps.items.length;\n});\n```\n\n#### useMemo for Expensive Computations\n\n```typescript\n// ‚ùå BAD - Recalculates on every render\nexport function DataAnalysis({ data }: Props) {\n  const processedData = data.map(item => ({\n    ...item,\n    score: calculateComplexScore(item),\n    percentile: calculatePercentile(item, data)\n  }));\n\n  return <DataVisualization data={processedData} />;\n}\n\n// ‚úÖ GOOD - Only recalculates when data changes\nexport function DataAnalysis({ data }: Props) {\n  const processedData = useMemo(() => {\n    return data.map(item => ({\n      ...item,\n      score: calculateComplexScore(item),\n      percentile: calculatePercentile(item, data)\n    }));\n  }, [data]);\n\n  return <DataVisualization data={processedData} />;\n}\n```\n\n#### useCallback for Stable Function References\n\n```typescript\n// ‚ùå BAD - Creates new function on every render\nexport function TodoList({ todos }: Props) {\n  const handleDelete = (id: string) => {\n    deleteTodo(id);\n  };\n\n  return todos.map(todo => (\n    <TodoItem key={todo.id} todo={todo} onDelete={handleDelete} />\n  ));\n}\n\n// ‚úÖ GOOD - Stable function reference\nexport function TodoList({ todos }: Props) {\n  const handleDelete = useCallback((id: string) => {\n    deleteTodo(id);\n  }, []); // Empty deps if function doesn't depend on props/state\n\n  return todos.map(todo => (\n    <TodoItem key={todo.id} todo={todo} onDelete={handleDelete} />\n  ));\n}\n```\n\n### 2. State Management Optimization\n\n#### Avoid Unnecessary Re-renders with Zustand\n\n```typescript\n// ‚ùå BAD - Component re-renders on any store change\nexport function UserProfile() {\n  const store = useUserDataStore();\n  return <div>{store.profile.name}</div>;\n}\n\n// ‚úÖ GOOD - Only re-renders when specific data changes\nexport function UserProfile() {\n  const userName = useUserDataStore(state => state.profile.name);\n  return <div>{userName}</div>;\n}\n\n// ‚úÖ BETTER - Multiple selections with shallow equality\nexport function UserCard() {\n  const { name, avatar } = useUserDataStore(\n    state => ({ name: state.profile.name, avatar: state.profile.avatar }),\n    shallow // Prevents re-render if values haven't changed\n  );\n  return (\n    <Box>\n      <Avatar src={avatar} />\n      <Text>{name}</Text>\n    </Box>\n  );\n}\n```\n\n#### Local State Before Global State\n\n```typescript\n// ‚ùå BAD - Global state for UI-only concerns\nconst useUIStore = create((set) => ({\n  isDropdownOpen: false,\n  activeTab: 0,\n  // UI state doesn't belong in global store\n}));\n\n// ‚úÖ GOOD - Local state for component-specific UI\nexport function Dropdown() {\n  const [isOpen, setIsOpen] = useState(false);\n  // Keep UI state local\n}\n```\n\n### 3. List Rendering Optimization\n\n#### Virtualization for Long Lists\n\n```typescript\n// ‚ùå BAD - Rendering 10000 items\nexport function UserList({ users }: { users: User[] }) {\n  return (\n    <VStack>\n      {users.map(user => (\n        <UserCard key={user.id} user={user} />\n      ))}\n    </VStack>\n  );\n}\n\n// ‚úÖ GOOD - Virtual scrolling with react-window\nimport { FixedSizeList } from 'react-window';\n\nexport function UserList({ users }: { users: User[] }) {\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (\n    <div style={style}>\n      <UserCard user={users[index]} />\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={users.length}\n      itemSize={80}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n```\n\n#### Proper Keys for List Items\n\n```typescript\n// ‚ùå BAD - Using index as key\n{items.map((item, index) => (\n  <Item key={index} {...item} />\n))}\n\n// ‚úÖ GOOD - Stable, unique keys\n{items.map(item => (\n  <Item key={item.id} {...item} />\n))}\n```\n\n### 4. Event Handler Optimization\n\n#### Debouncing User Input\n\n```typescript\n// ‚ùå BAD - API call on every keystroke\nexport function SearchBox() {\n  const [query, setQuery] = useState('');\n  \n  const handleSearch = async (value: string) => {\n    const results = await searchAPI(value);\n    setResults(results);\n  };\n\n  return (\n    <Input\n      value={query}\n      onChange={(e) => {\n        setQuery(e.target.value);\n        handleSearch(e.target.value);\n      }}\n    />\n  );\n}\n\n// ‚úÖ GOOD - Debounced API calls\nimport { useDebouncedCallback } from 'use-debounce';\n\nexport function SearchBox() {\n  const [query, setQuery] = useState('');\n  \n  const debouncedSearch = useDebouncedCallback(async (value: string) => {\n    const results = await searchAPI(value);\n    setResults(results);\n  }, 300);\n\n  return (\n    <Input\n      value={query}\n      onChange={(e) => {\n        setQuery(e.target.value);\n        debouncedSearch(e.target.value);\n      }}\n    />\n  );\n}\n```\n\n## Next.js Performance Patterns\n\n### 1. Image Optimization\n\n```typescript\n// ‚ùå BAD - Unoptimized images\n<img src=\"/hero-image.png\" alt=\"Hero\" />\n\n// ‚úÖ GOOD - Next.js Image component\nimport Image from 'next/image';\n\n<Image\n  src=\"/hero-image.png\"\n  alt=\"Hero\"\n  width={1200}\n  height={600}\n  priority // For above-the-fold images\n  placeholder=\"blur\"\n  blurDataURL={blurDataUrl}\n/>\n```\n\n### 2. Code Splitting\n\n#### Dynamic Imports for Heavy Components\n\n```typescript\n// ‚ùå BAD - Loading heavy component upfront\nimport HeavyChart from '@/components/HeavyChart';\n\nexport function Dashboard() {\n  const [showChart, setShowChart] = useState(false);\n  \n  return (\n    <>\n      <Button onClick={() => setShowChart(true)}>Show Chart</Button>\n      {showChart && <HeavyChart />}\n    </>\n  );\n}\n\n// ‚úÖ GOOD - Load only when needed\nimport dynamic from 'next/dynamic';\n\nconst HeavyChart = dynamic(() => import('@/components/HeavyChart'), {\n  loading: () => <Spinner />,\n  ssr: false // If not needed for SSR\n});\n\nexport function Dashboard() {\n  const [showChart, setShowChart] = useState(false);\n  \n  return (\n    <>\n      <Button onClick={() => setShowChart(true)}>Show Chart</Button>\n      {showChart && <HeavyChart />}\n    </>\n  );\n}\n```\n\n### 3. API Route Optimization\n\n#### Efficient Data Fetching\n\n```typescript\n// ‚ùå BAD - Multiple sequential queries\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const user = await getUserById(req.query.id);\n  const posts = await getPostsByUserId(user.id);\n  const comments = await getCommentsByUserId(user.id);\n  \n  res.json({ user, posts, comments });\n}\n\n// ‚úÖ GOOD - Parallel queries\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const userId = req.query.id as string;\n  \n  const [user, posts, comments] = await Promise.all([\n    getUserById(userId),\n    getPostsByUserId(userId),\n    getCommentsByUserId(userId)\n  ]);\n  \n  res.json({ user, posts, comments });\n}\n```\n\n#### Response Caching\n\n```typescript\n// ‚úÖ Set appropriate cache headers\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // For static data\n  res.setHeader('Cache-Control', 'public, s-maxage=3600, stale-while-revalidate');\n  \n  // For user-specific data\n  res.setHeader('Cache-Control', 'private, max-age=600');\n  \n  const data = await fetchData();\n  res.json(data);\n}\n```\n\n### 4. Static Generation vs Server-Side Rendering\n\n```typescript\n// ‚úÖ Static Generation for marketing pages\nexport const getStaticProps: GetStaticProps = async () => {\n  const data = await fetchStaticData();\n  \n  return {\n    props: { data },\n    revalidate: 3600 // ISR - revalidate every hour\n  };\n};\n\n// ‚úÖ SSR only when necessary (user-specific data)\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const user = await authenticateUser(context.req);\n  \n  if (!user) {\n    return { redirect: { destination: '/login', permanent: false } };\n  }\n  \n  const userData = await fetchUserData(user.id);\n  return { props: { userData } };\n};\n```\n\n## Bundle Size Optimization\n\n### 1. Tree Shaking Imports\n\n```typescript\n// ‚ùå BAD - Imports entire library\nimport * as _ from 'lodash';\nconst result = _.debounce(fn, 300);\n\n// ‚úÖ GOOD - Import only what you need\nimport debounce from 'lodash/debounce';\nconst result = debounce(fn, 300);\n\n// ‚ùå BAD - Imports all icons\nimport * as Icons from '@chakra-ui/icons';\n<Icons.AddIcon />\n\n// ‚úÖ GOOD - Specific imports\nimport { AddIcon } from '@chakra-ui/icons';\n<AddIcon />\n```\n\n### 2. Lazy Load Third-Party Scripts\n\n```typescript\n// ‚ùå BAD - Loading analytics on page load\nimport Script from 'next/script';\n\n<Script src=\"https://analytics.com/script.js\" />\n\n// ‚úÖ GOOD - Load after interactive\n<Script \n  src=\"https://analytics.com/script.js\"\n  strategy=\"afterInteractive\"\n/>\n\n// ‚úÖ BETTER - Load only when needed\n<Script \n  src=\"https://analytics.com/script.js\"\n  strategy=\"lazyOnload\"\n/>\n```\n\n### 3. Analyze Bundle Size\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"analyze\": \"ANALYZE=true next build\"\n  }\n}\n```\n\n```typescript\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n});\n\nmodule.exports = withBundleAnalyzer({\n  // your config\n});\n```\n\n## Data Fetching Optimization\n\n### 1. SWR for Client-Side Caching\n\n```typescript\n// ‚ùå BAD - Fetching in useEffect\nexport function UserProfile({ userId }: Props) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      });\n  }, [userId]);\n\n  if (loading) return <Spinner />;\n  return <div>{user.name}</div>;\n}\n\n// ‚úÖ GOOD - SWR with caching, revalidation, error handling\nimport useSWR from 'swr';\n\nexport function UserProfile({ userId }: Props) {\n  const { data: user, error, isLoading } = useSWR(\n    `/api/users/${userId}`,\n    fetcher,\n    {\n      revalidateOnFocus: false,\n      revalidateOnReconnect: false,\n      dedupingInterval: 60000, // Cache for 1 minute\n    }\n  );\n\n  if (isLoading) return <Spinner />;\n  if (error) return <ErrorMessage />;\n  return <div>{user.name}</div>;\n}\n```\n\n### 2. Optimistic Updates\n\n```typescript\n// ‚úÖ Update UI immediately, sync with server\nexport function TodoItem({ todo }: Props) {\n  const { mutate } = useSWRConfig();\n  \n  const toggleComplete = async () => {\n    // Optimistic update\n    mutate(\n      `/api/todos/${todo.id}`,\n      { ...todo, completed: !todo.completed },\n      false // Don't revalidate yet\n    );\n    \n    // Sync with server\n    try {\n      await updateTodo(todo.id, { completed: !todo.completed });\n      mutate(`/api/todos/${todo.id}`); // Revalidate\n    } catch (error) {\n      // Rollback on error\n      mutate(`/api/todos/${todo.id}`);\n    }\n  };\n\n  return (\n    <Checkbox isChecked={todo.completed} onChange={toggleComplete}>\n      {todo.title}\n    </Checkbox>\n  );\n}\n```\n\n## Performance Monitoring\n\n### 1. React DevTools Profiler\n\n```typescript\n// Wrap components to measure performance\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(\n  id: string,\n  phase: \"mount\" | \"update\",\n  actualDuration: number\n) {\n  console.log(`${id} (${phase}) took ${actualDuration}ms`);\n}\n\n<Profiler id=\"Navigation\" onRender={onRenderCallback}>\n  <Navigation />\n</Profiler>\n```\n\n### 2. Web Vitals Monitoring\n\n```typescript\n// pages/_app.tsx\nexport function reportWebVitals(metric: NextWebVitalsMetric) {\n  if (metric.label === 'web-vital') {\n    console.log(metric); // or send to analytics\n  }\n}\n```\n\n### 3. Custom Performance Marks\n\n```typescript\n// Measure critical operations\nexport async function loadDashboardData() {\n  performance.mark('dashboard-load-start');\n  \n  const data = await fetchDashboardData();\n  \n  performance.mark('dashboard-load-end');\n  performance.measure(\n    'dashboard-load',\n    'dashboard-load-start',\n    'dashboard-load-end'\n  );\n  \n  return data;\n}\n```\n\n## Performance Checklist\n\n### Before Deploy\n- [ ] Run bundle analyzer and check for large dependencies\n- [ ] Ensure images use Next.js Image component\n- [ ] Verify static pages use getStaticProps where possible\n- [ ] Check for proper key props in lists\n- [ ] Review React DevTools for unnecessary re-renders\n- [ ] Test on throttled network conditions\n- [ ] Verify lazy loading for below-the-fold content\n\n### Monitoring\n- [ ] Set up Web Vitals monitoring\n- [ ] Track bundle size in CI/CD\n- [ ] Monitor API response times\n- [ ] Set up alerts for performance regressions\n\n## Anti-Patterns to Avoid\n\n```typescript\n// ‚ùå Inline function definitions in render\n<Button onClick={() => handleClick(item.id)}>\n\n// ‚ùå Unnecessary spread operators\n<Component {...props} />  // If not all props are needed\n\n// ‚ùå Large inline styles objects\n<Box style={{ display: 'flex', padding: 20, margin: 10, ...more }}>\n\n// ‚ùå Synchronous expensive operations in render\nconst expensiveResult = calculateComplexValue(data); // Do this in useMemo\n\n// ‚ùå Multiple setState calls\nsetLoading(true);\nsetError(null);\nsetData(null); // Combine into single state or use reducer\n```\n\n## Remember\n\n- **Measure before optimizing** - Use profiler and metrics\n- **User perception matters** - Optimize for perceived performance\n- **Progressive enhancement** - Fast for everyone, enhanced for some\n- **Mobile first** - Most users are on mobile devices\n- **Every KB counts** - Be mindful of bundle size",
          "alwaysApply": true,
          "globs": [
            "**/*.tsx",
            "**/*.ts",
            "**/pages/**",
            "**/components/**"
          ]
        },
        {
          "id": "state-management-patterns",
          "title": "State Management Patterns",
          "fileName": "state-management-patterns.mdc",
          "frontmatter": {
            "description": "State management patterns and best practices using Zustand",
            "globs": [
              "**/stores/**",
              "**/hooks/**",
              "**/*.store.ts",
              "**/*.store.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# State Management Patterns\n\n## Philosophy\n\nOur state management approach with Zustand focuses on:\n\n1. **Simplicity** - Keep stores small and focused\n2. **Performance** - Minimize re-renders through selective subscriptions\n3. **Type Safety** - Leverage TypeScript for predictable state\n4. **Separation of Concerns** - UI state vs application state\n\n## When to Use Zustand\n\n### Use Zustand For:\n\n- **Global Application State** - User data, authentication status\n- **Cross-Component Communication** - State shared between unrelated components\n- **Persistent State** - Data that needs to survive navigation\n- **Complex State Logic** - When useState becomes unwieldy\n\n### Use Local State For:\n\n- **UI-Only State** - Modal open/close, form inputs, hover states\n- **Component-Specific Data** - Data that doesn't need to be shared\n- **Temporary State** - Values that reset on unmount\n\n## Store Organization\n\n### 1. Single Responsibility Stores\n\n```typescript\n// ‚ùå BAD - Monolithic store\nconst useAppStore = create((set) => ({\n  // User stuff\n  user: null,\n  isAuthenticated: false,\n  login: () => {},\n  logout: () => {},\n\n  // UI stuff\n  sidebarOpen: false,\n  theme: \"light\",\n\n  // Data stuff\n  workflows: [],\n  posts: [],\n  comments: [],\n}));\n\n// ‚úÖ GOOD - Focused stores\n// stores/userStore.ts\ninterface UserState {\n  user: User | null;\n  isAuthenticated: boolean;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  logout: () => Promise<void>;\n  updateProfile: (updates: Partial<User>) => Promise<void>;\n}\n\nexport const useUserStore = create<UserState>((set) => ({\n  user: null,\n  isAuthenticated: false,\n\n  login: async (credentials) => {\n    const user = await authService.login(credentials);\n    set({ user, isAuthenticated: true });\n  },\n\n  logout: async () => {\n    await authService.logout();\n    set({ user: null, isAuthenticated: false });\n  },\n\n  updateProfile: async (updates) => {\n    set((state) => ({\n      user: state.user ? { ...state.user, ...updates } : null,\n    }));\n  },\n}));\n\n// stores/workflowStore.ts\ninterface WorkflowState {\n  workflows: Workflow[];\n  selectedWorkflowId: string | null;\n  isLoading: boolean;\n  error: Error | null;\n\n  fetchWorkflows: () => Promise<void>;\n  selectWorkflow: (workflowId: string) => void;\n  createWorkflow: (data: CreateWorkflowData) => Promise<void>;\n  updateWorkflow: (\n    workflowId: string,\n    updates: Partial<Workflow>\n  ) => Promise<void>;\n  deleteWorkflow: (workflowId: string) => Promise<void>;\n}\n\nexport const useWorkflowStore = create<WorkflowState>((set, get) => ({\n  workflows: [],\n  selectedWorkflowId: null,\n  isLoading: false,\n  error: null,\n\n  fetchWorkflows: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const workflows = await workflowService.getAll();\n      set({ workflows, isLoading: false });\n    } catch (error) {\n      set({ error: error as Error, isLoading: false });\n    }\n  },\n\n  selectWorkflow: (workflowId) => set({ selectedWorkflowId: workflowId }),\n\n  createWorkflow: async (data) => {\n    const workflow = await workflowService.create(data);\n    set((state) => ({\n      workflows: [...state.workflows, workflow],\n    }));\n  },\n\n  updateWorkflow: async (workflowId, updates) => {\n    const updated = await workflowService.update(workflowId, updates);\n    set((state) => ({\n      workflows: state.workflows.map((workflow) =>\n        workflow.id === workflowId ? updated : workflow\n      ),\n    }));\n  },\n\n  deleteWorkflow: async (workflowId) => {\n    await workflowService.delete(workflowId);\n    set((state) => ({\n      workflows: state.workflows.filter(\n        (workflow) => workflow.id !== workflowId\n      ),\n      selectedWorkflowId:\n        state.selectedWorkflowId === workflowId\n          ? null\n          : state.selectedWorkflowId,\n    }));\n  },\n}));\n```\n\n### 2. Store File Structure\n\n```\nsrc/stores/\n‚îú‚îÄ‚îÄ index.ts           // Re-exports all stores\n‚îú‚îÄ‚îÄ userStore.ts       // User authentication and profile\n‚îú‚îÄ‚îÄ workflowStore.ts   // Workflow management\n‚îú‚îÄ‚îÄ uiStore.ts        // Global UI state (theme, sidebar)\n‚îú‚îÄ‚îÄ types.ts          // Shared types for stores\n‚îî‚îÄ‚îÄ __tests__/\n    ‚îî‚îÄ‚îÄ userStore.test.ts\n```\n\n## Performance Patterns\n\n### 1. Selective Subscriptions\n\n```typescript\n// ‚ùå BAD - Component re-renders on any store change\nfunction UserProfile() {\n  const store = useUserStore();\n  return <div>{store.user?.name}</div>;\n}\n\n// ‚úÖ GOOD - Only re-renders when user.name changes\nfunction UserProfile() {\n  const userName = useUserStore((state) => state.user?.name);\n  return <div>{userName}</div>;\n}\n\n// ‚úÖ BETTER - Multiple selections with shallow comparison\nimport { shallow } from \"zustand/shallow\";\n\nfunction UserCard() {\n  const { name, email, avatar } = useUserStore(\n    (state) => ({\n      name: state.user?.name,\n      email: state.user?.email,\n      avatar: state.user?.avatar,\n    }),\n    shallow\n  );\n\n  return (\n    <Card>\n      <Avatar src={avatar} />\n      <Text>{name}</Text>\n      <Text>{email}</Text>\n    </Card>\n  );\n}\n```\n\n### 2. Computed Values with Selectors\n\n```typescript\n// ‚ùå BAD - Computing in component\nfunction WorkflowList() {\n  const workflows = useWorkflowStore((state) => state.workflows);\n  const activeWorkflows = workflows.filter(\n    (workflow) => workflow.status === \"active\"\n  );\n\n  return <List items={activeWorkflows} />;\n}\n\n// ‚úÖ GOOD - Memoized selector\nconst selectActiveWorkflows = (state: WorkflowState) =>\n  state.workflows.filter((workflow) => workflow.status === \"active\");\n\nfunction WorkflowList() {\n  const activeWorkflows = useWorkflowStore(selectActiveWorkflows);\n  return <List items={activeWorkflows} />;\n}\n\n// ‚úÖ BETTER - Reusable selectors\n// stores/workflowStore.ts\nexport const workflowSelectors = {\n  activeWorkflows: (state: WorkflowState) =>\n    state.workflows.filter((workflow) => workflow.status === \"active\"),\n\n  selectedWorkflow: (state: WorkflowState) =>\n    state.workflows.find(\n      (workflow) => workflow.id === state.selectedWorkflowId\n    ),\n\n  workflowById: (workflowId: string) => (state: WorkflowState) =>\n    state.workflows.find((workflow) => workflow.id === workflowId),\n};\n\n// Usage\nconst activeWorkflows = useWorkflowStore(workflowSelectors.activeWorkflows);\nconst workflow = useWorkflowStore(workflowSelectors.workflowById(workflowId));\n```\n\n### 3. Transient Updates (No Re-render)\n\n```typescript\n// For updates that shouldn't trigger re-renders\ninterface StoreWithTransient {\n  bears: number;\n  increaseBears: () => void;\n  // Transient state\n  socket: WebSocket | null;\n  setSocket: (socket: WebSocket) => void;\n}\n\nconst useStore = create<StoreWithTransient>((set) => ({\n  bears: 0,\n  increaseBears: () => set((state) => ({ bears: state.bears + 1 })),\n\n  // Using ref to avoid re-renders\n  socket: null,\n  setSocket: (socket) => {\n    useStore.setState({ socket }, false, { type: \"setSocket\", socket });\n  },\n}));\n\n// Or use subscribeWithSelector\nconst useStore = create(\n  subscribeWithSelector((set) => ({\n    bears: 0,\n    socket: null,\n    // ...\n  }))\n);\n```\n\n## Advanced Patterns\n\n### 1. Middleware and DevTools\n\n```typescript\nimport { devtools, persist } from \"zustand/middleware\";\n\ninterface UserState {\n  user: User | null;\n  preferences: UserPreferences;\n  // ... actions\n}\n\nexport const useUserStore = create<UserState>()(\n  devtools(\n    persist(\n      (set) => ({\n        user: null,\n        preferences: DEFAULT_PREFERENCES,\n\n        updatePreferences: (updates) =>\n          set(\n            (state) => ({\n              preferences: { ...state.preferences, ...updates },\n            }),\n            false,\n            \"updatePreferences\" // Action name in DevTools\n          ),\n      }),\n      {\n        name: \"user-storage\", // localStorage key\n        partialize: (state) => ({\n          // Only persist preferences, not user data\n          preferences: state.preferences,\n        }),\n      }\n    ),\n    {\n      name: \"UserStore\", // DevTools instance name\n    }\n  )\n);\n```\n\n### 2. Async Actions with Loading States\n\n```typescript\ninterface DataState<T> {\n  data: T | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\ninterface PostsState extends DataState<Post[]> {\n  fetchPosts: () => Promise<void>;\n  createPost: (data: CreatePostData) => Promise<void>;\n  optimisticUpdate: (postId: string, updates: Partial<Post>) => void;\n  confirmUpdate: (postId: string, updatedPost: Post) => void;\n  rollbackUpdate: (postId: string, originalPost: Post) => void;\n}\n\nexport const usePostsStore = create<PostsState>((set, get) => ({\n  data: null,\n  isLoading: false,\n  error: null,\n\n  fetchPosts: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const posts = await postsService.getAll();\n      set({ data: posts, isLoading: false });\n    } catch (error) {\n      set({ error: error as Error, isLoading: false });\n    }\n  },\n\n  createPost: async (data) => {\n    // Optimistic update\n    const tempId = `temp-${Date.now()}`;\n    const tempPost: Post = { ...data, id: tempId, createdAt: new Date() };\n\n    set((state) => ({\n      data: state.data ? [...state.data, tempPost] : [tempPost],\n    }));\n\n    try {\n      const newPost = await postsService.create(data);\n      // Replace temp post with real one\n      set((state) => ({\n        data:\n          state.data?.map((post) => (post.id === tempId ? newPost : post)) ||\n          null,\n      }));\n    } catch (error) {\n      // Rollback on error\n      set((state) => ({\n        data: state.data?.filter((post) => post.id !== tempId) || null,\n        error: error as Error,\n      }));\n    }\n  },\n\n  optimisticUpdate: (postId, updates) => {\n    set((state) => ({\n      data:\n        state.data?.map((post) =>\n          post.id === postId ? { ...post, ...updates } : post\n        ) || null,\n    }));\n  },\n\n  confirmUpdate: (postId, updatedPost) => {\n    set((state) => ({\n      data:\n        state.data?.map((post) => (post.id === postId ? updatedPost : post)) ||\n        null,\n    }));\n  },\n\n  rollbackUpdate: (postId, originalPost) => {\n    set((state) => ({\n      data:\n        state.data?.map((post) => (post.id === postId ? originalPost : post)) ||\n        null,\n    }));\n  },\n}));\n```\n\n### 3. Store Composition\n\n```typescript\n// Combining multiple stores\ninterface CombinedState {\n  user: User | null;\n  workflows: Workflow[];\n  isAuthenticated: boolean;\n}\n\nexport const useCombinedStore = create<CombinedState>(() => ({\n  get user() {\n    return useUserStore.getState().user;\n  },\n  get workflows() {\n    return useWorkflowStore.getState().workflows;\n  },\n  get isAuthenticated() {\n    return useUserStore.getState().isAuthenticated;\n  },\n}));\n\n// Or using hooks\nexport function useAuthenticatedWorkflows() {\n  const isAuthenticated = useUserStore((state) => state.isAuthenticated);\n  const workflows = useWorkflowStore((state) => state.workflows);\n\n  return isAuthenticated ? workflows : [];\n}\n```\n\n### 4. Store Slices Pattern\n\n```typescript\n// For very large stores, split into slices\nimport { StateCreator } from \"zustand\";\n\ninterface BearSlice {\n  bears: number;\n  addBear: () => void;\n}\n\ninterface FishSlice {\n  fishes: number;\n  addFish: () => void;\n}\n\ninterface BoundStore extends BearSlice, FishSlice {}\n\nconst createBearSlice: StateCreator<BoundStore, [], [], BearSlice> = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n});\n\nconst createFishSlice: StateCreator<BoundStore, [], [], FishSlice> = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n});\n\nconst useBoundStore = create<BoundStore>()((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n}));\n```\n\n## Testing Zustand Stores\n\n```typescript\n// __tests__/userStore.test.ts\nimport { renderHook, act } from \"@testing-library/react\";\nimport { useUserStore } from \"../userStore\";\n\n// Reset store between tests\nbeforeEach(() => {\n  useUserStore.setState({ user: null, isAuthenticated: false });\n});\n\ndescribe(\"UserStore\", () => {\n  it(\"should login user successfully\", async () => {\n    const { result } = renderHook(() => useUserStore());\n\n    await act(async () => {\n      await result.current.login({\n        email: \"test@example.com\",\n        password: \"password\",\n      });\n    });\n\n    expect(result.current.isAuthenticated).toBe(true);\n    expect(result.current.user).toMatchObject({\n      email: \"test@example.com\",\n    });\n  });\n\n  it(\"should select specific state\", () => {\n    // Set initial state\n    useUserStore.setState({\n      user: { id: \"1\", name: \"Test User\", email: \"test@example.com\" },\n    });\n\n    // Test selector\n    const { result } = renderHook(() =>\n      useUserStore((state) => state.user?.name)\n    );\n\n    expect(result.current).toBe(\"Test User\");\n  });\n});\n```\n\n## Common Patterns\n\n### 1. Form State Management\n\n```typescript\n// For complex forms, keep in Zustand\ninterface FormState {\n  values: FormValues;\n  errors: FormErrors;\n  touched: Set<string>;\n  isSubmitting: boolean;\n\n  setFieldValue: (field: string, value: any) => void;\n  setFieldError: (field: string, error: string) => void;\n  setFieldTouched: (field: string) => void;\n  reset: () => void;\n  submit: () => Promise<void>;\n}\n\n// For simple forms, use local state or React Hook Form\n```\n\n### 2. Real-time Updates\n\n```typescript\ninterface RealtimeState {\n  messages: Message[];\n  subscribe: () => () => void; // Returns unsubscribe\n}\n\nexport const useMessagesStore = create<RealtimeState>((set, get) => ({\n  messages: [],\n\n  subscribe: () => {\n    const ws = new WebSocket(\"ws://localhost:3000\");\n\n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      set((state) => ({\n        messages: [...state.messages, message],\n      }));\n    };\n\n    // Return cleanup function\n    return () => ws.close();\n  },\n}));\n\n// Usage with cleanup\nfunction MessagesComponent() {\n  const messages = useMessagesStore((state) => state.messages);\n  const subscribe = useMessagesStore((state) => state.subscribe);\n\n  useEffect(() => {\n    const unsubscribe = subscribe();\n    return unsubscribe;\n  }, [subscribe]);\n\n  return <MessagesList messages={messages} />;\n}\n```\n\n### 3. Derived State\n\n```typescript\n// Don't store derived state\ninterface BadExample {\n  items: Item[];\n  filteredItems: Item[]; // ‚ùå Derived from items\n  filter: string;\n}\n\n// Do compute on demand\ninterface GoodExample {\n  items: Item[];\n  filter: string;\n}\n\nconst selectFilteredItems = (state: GoodExample) =>\n  state.items.filter((item) =>\n    item.name.toLowerCase().includes(state.filter.toLowerCase())\n  );\n```\n\n## Best Practices\n\n### DO:\n\n1. **Keep stores focused** - One domain per store\n2. **Use TypeScript** - Type your stores completely\n3. **Normalize data** - Store IDs and use selectors for lookups\n4. **Handle errors** - Include error state in async operations\n5. **Use selectors** - For computed values and performance\n6. **Test stores** - They contain business logic\n\n### DON'T:\n\n1. **Don't overuse global state** - Local state is often sufficient\n2. **Don't store derived state** - Compute it with selectors\n3. **Don't mutate state directly** - Always use set()\n4. **Don't create huge stores** - Split them up\n5. **Don't store UI-only state globally** - Keep it local\n\n## Migration from Other State Management\n\n### From Redux:\n\n- Actions ‚Üí Store methods\n- Reducers ‚Üí set() calls\n- Selectors ‚Üí Zustand selectors\n- Middleware ‚Üí Zustand middleware\n- Connect ‚Üí useStore hook\n\n### From Context API:\n\n- Multiple contexts ‚Üí Multiple stores\n- useContext ‚Üí useStore\n- Provider wrapping ‚Üí No wrapping needed\n- Performance issues ‚Üí Solved with selectors\n\n## Debugging\n\n### 1. Enable Redux DevTools\n\n```typescript\nconst useStore = create(\n  devtools((set) => ({\n    // your store\n  }))\n);\n```\n\n### 2. Log State Changes\n\n```typescript\nconst useStore = create((set, get) => ({\n  // Wrap set for logging\n  updateUser: (user) => {\n    console.log(\"Before:\", get().user);\n    set({ user });\n    console.log(\"After:\", get().user);\n  },\n}));\n```\n\n### 3. Inspect Current State\n\n```typescript\n// In console\nuseUserStore.getState();\n\n// In component\nconst debugState = () => {\n  console.log(\"Current state:\", useUserStore.getState());\n};\n```\n\nRemember: Zustand is powerful but lightweight. Use it wisely to keep your application state manageable and performant.\n",
          "alwaysApply": true,
          "globs": [
            "**/stores/**",
            "**/hooks/**",
            "**/*.store.ts",
            "**/*.store.tsx"
          ]
        },
        {
          "id": "styling-guidelines",
          "title": "Styling Guidelines",
          "fileName": "styling-guidelines.mdc",
          "frontmatter": {
            "description": "Comprehensive code style guide covering types, functions, naming conventions, and formatting rules",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# CODEBASE STYLING GUIDELINES\n\nYou MUST follow these coding guidelines when adding ANY code to the codebase\n\n## 1. Types\n- Symbols and BigInts cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don‚Äôt support them natively.\n\n## 2. References\n- Use `const` for all of your references; avoid using `var`.\n- If you must reassign references, use `let` instead of `var`.\n- Note that both `let` and `const` are block-scoped, whereas `var` is function-scoped.\n\n## 3. Objects\n- Use the literal syntax for object creation.\n- Use computed property names when creating objects with dynamic property names.\n- Use object method shorthand.\n- Use property value shorthand.\n- Group your shorthand properties at the beginning of your object declaration.\n- Only quote properties that are invalid identifiers.\n- Do not call `Object.prototype` methods directly (e.g., `hasOwnProperty`). Prefer `Object.prototype.hasOwnProperty.call(object, key)` or `Object.hasOwn(object, key)`.\n- Prefer the object spread syntax over `Object.assign` to shallow-copy objects.\n- Use the object rest parameter syntax to get a new object with certain properties omitted.\n\n## 4. Arrays\n- Use the literal syntax for array creation.\n- Use `Array#push` instead of direct assignment to add items to an array.\n- Use array spreads `...` to copy arrays.\n- To convert an iterable object to an array, use spreads `...` instead of `Array.from`.\n- Use `Array.from` for converting an array-like object to an array.\n- Use `Array.from` instead of spread `...` for mapping over iterables.\n- Use return statements in array method callbacks. It‚Äôs ok to omit the return if the function body consists of a single statement returning an expression without side effects.\n- Use line breaks after opening array brackets and before closing array brackets if an array has multiple lines.\n\n## 5. Destructuring\n- Use object destructuring when accessing and using multiple properties of an object.\n- Use array destructuring.\n- Use object destructuring for multiple return values, not array destructuring.\n\n## 6. Strings\n- Use single quotes `''` for strings.\n- Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation.\n- When programmatically building up strings, use template strings instead of concatenation.\n- Never use `eval()` on a string.\n- Do not unnecessarily escape characters in strings.\n\n## 7. Functions\n- Use named function expressions instead of function declarations.\n- Wrap immediately invoked function expressions in parentheses.\n- Never declare a function in a non-function block (`if`, `while`, etc). Assign the function to a variable instead.\n- Never name a parameter `arguments`.\n- Never use `arguments`, opt to use rest syntax `...` instead.\n- Use default parameter syntax rather than mutating function arguments.\n- Avoid side effects with default parameters.\n- Always put default parameters last.\n- Never use the Function constructor to create a new function.\n- Ensure consistent spacing in function signatures: include a space before the parameter parentheses and before the opening curly brace.\n- Never mutate parameters.\n- Never reassign parameters.\n- Prefer the use of the spread syntax `...` to call variadic functions.\n- Functions with multiline signatures, or invocations, should be indented with each item on a line by itself, with a trailing comma on the last item.\n\n## 8. Arrow Functions\n- When you must use an anonymous function (as when passing an inline callback), use arrow function notation.\n- If the function body consists of a single statement returning an expression without side effects, omit the braces and use the implicit return. Otherwise, keep the braces and use a `return` statement.\n- In case the expression spans over multiple lines, wrap it in parentheses for better readability.\n- Always include parentheses around arguments for clarity and consistency.\n- Avoid confusing arrow function syntax (`=>`) with comparison operators (`<=`, `>=`); wrap the expression in parentheses if necessary.\n- For arrow functions with implicit returns, the body should either be on the same line as the arrow (`=>`) or wrapped in parentheses if multiline.\n\n## 9. Classes & Constructors\n- Always use `class`. Avoid manipulating `prototype` directly.\n- Use `extends` for inheritance.\n- Methods can return `this` to help with method chaining.\n- It‚Äôs okay to write a custom `toString()` method, just make sure it works successfully and causes no side effects.\n- An empty constructor function or one that just delegates to a parent class is unnecessary.\n- Avoid duplicate class members.\n- Class methods should use `this` or be made into a static method unless an external library or framework requires using specific non-static methods.\n\n## 10. Modules\n- Always use modules (`import`/`export`) over a non-standard module system.\n- Do not use wildcard imports.\n- Do not export directly from an import.\n- Only import from a path in one place.\n- Do not export mutable bindings.\n- In modules with a single export, prefer default export over named export.\n- Put all `import`s above non-import statements.\n- Multiline imports should be indented just like multiline array and object literals, with a trailing comma.\n- Disallow Webpack loader syntax in module import statements.\n- Do not include JavaScript filename extensions in `import` statements.\n\n## 11. Iterators and Generators\n- Don‚Äôt use iterators. Prefer JavaScript‚Äôs higher-order functions (`map()`, `every()`, `filter()`, `find()`, `findIndex()`, `reduce()`, `some()`, etc.) instead of loops like `for-in` or `for-of`.\n- Use `Object.keys()`, `Object.values()`, or `Object.entries()` to produce arrays from objects for iteration.\n- Don‚Äôt use generators for now.\n- If using generators, ensure proper spacing: `function* foo()` or `const foo = function* () {}`.\n\n## 12. Properties\n- Use dot notation when accessing properties.\n- Use bracket notation `[]` when accessing properties with a variable.\n- Use exponentiation operator `**` when calculating exponentiations.\n\n## 13. Variables\n- Always use `const` or `let` to declare variables.\n- Use one `const` or `let` declaration per variable or assignment.\n- Group all your `const`s and then group all your `let`s.\n- Assign variables where you need them, but place them in a reasonable place.\n- Don‚Äôt chain variable assignments.\n- Avoid using unary increments and decrements (`++`, `--`). Prefer `num += 1` or `num -= 1`.\n- Avoid linebreaks before or after `=` in an assignment. If your assignment violates max-len, surround the value in parens.\n- Disallow unused variables.\n\n## 14. Hoisting\n- Variables, classes, and functions should be defined before they can be used.\n\n## 15. Comparison Operators & Equality\n- Use `===` and `!==` over `==` and `!=`.\n- Use shortcuts for booleans (e.g., `if (isValid)`) but explicit comparisons for strings (e.g., `name !== ''`) and numbers (e.g., `collection.length > 0`).\n- Use braces to create blocks in `case` and `default` clauses that contain lexical declarations (e.g. `let`, `const`, `function`, and `class`).\n- Ternaries should not be nested and generally be single line expressions.\n- Avoid unneeded ternary statements (prefer `||`, `!!`, `!`, `??`).\n- When mixing operators, enclose them in parentheses. Exceptions: standard arithmetic operators (`+`, `-`, `**`). Enclose `/` and `*` when mixed.\n- Use the nullish coalescing operator (`??`) to provide defaults specifically for `null` or `undefined` values.\n\n## 16. Blocks\n- Use braces with all multiline blocks.\n- If you‚Äôre using multiline blocks with `if` and `else`, put `else` on the same line as your `if` block‚Äôs closing brace.\n- If an `if` block always executes a `return` statement, the subsequent `else` block is unnecessary. A `return` in an `else if` block following an `if` block that contains a `return` can be separated into multiple `if` blocks.\n\n## 17. Control Statements\n- If a control statement (`if`, `while` etc.) gets too long or exceeds the maximum line length, each (grouped) condition can be put into a new line. The logical operator should begin the line.\n- Don't use selection operators (e.g., `&&`, `||` for short-circuiting) in place of control statements (e.g., `if`).\n\n## 18. Comments\n- Use `/** ... */` for multiline comments.\n- Use `//` for single line comments.\n- Place single line comments on a newline above the subject of the comment.\n- Put an empty line before the comment unless it‚Äôs on the first line of a block.\n- Start all comments with a space.\n- Use `// FIXME:` to annotate problems.\n- Use `// TODO:` to annotate solutions to problems.\n\n## 19. Whitespace\n- Use soft tabs (space character) set to 2 spaces for indentation.\n- Place 1 space before the leading brace.\n- Place 1 space before the opening parenthesis in control statements (`if`, `while` etc.).\n- Place no space between the argument list and the function name in function calls and declarations.\n- Set off operators with spaces.\n- End files with a single newline character.\n- Use indentation when making long method chains (more than 2 method chains). Use a leading dot.\n- Leave a blank line after blocks and before the next statement.\n- Do not pad blocks with blank lines.\n- Do not use multiple consecutive blank lines.\n- Do not add spaces inside parentheses.\n- Do not add spaces inside array brackets `[]`.\n- Add spaces inside curly braces `{}`.\n- Avoid lines of code longer than 100 characters (including whitespace). Long strings are exempt.\n- Require consistent spacing inside block tokens on the same line (e.g., `function foo() { return true; }`).\n- Avoid spaces before commas and require a space after commas.\n- Do not add spaces inside computed property brackets (e.g., `obj[foo]`).\n- Avoid spaces between function names and their invocation parentheses (e.g., `func()`).\n- Place a space after the colon in object literal properties, but no space before the colon (e.g., `{ foo: 42 }`).\n- Avoid trailing spaces at the end of lines.\n- Allow only one newline at the end of files. Avoid a newline at the beginning of files.\n\n## 20. Commas\n- Do not use leading commas.\n- Use trailing commas in multiline arrays, objects, function parameters, and import/export lists.\n- Do not use a trailing comma after a rest element (`...`).\n\n## 21. Semicolons\n- Always use semicolons to terminate statements.\n\n## 22. Type Casting & Coercion\n- Perform type coercion at the beginning of the statement.\n- Strings: Use `String()` for type casting. Do not use `new String()`, string concatenation `+ ''`, or `.toString()`.\n- Numbers: Use `Number()` for type casting. Use `parseInt()` always with a radix (usually 10) for parsing strings. Do not use `new Number()`.\n- Booleans: Use `Boolean()` or the double bang `!!` for type casting. Do not use `new Boolean()`.\n\n## 23. Naming Conventions\n- **NEVER abbreviate variables.** Always use full, descriptive names. Single-letter variables and abbreviations are forbidden except for standard mathematical conventions (e.g., `x`, `y` in coordinate systems, `i` in mathematical contexts).\n- Avoid single letter names. Be descriptive.\n- Use camelCase when naming objects, functions, and instances.\n- Use PascalCase only when naming constructors or classes.\n- Do not use trailing or leading underscores.\n- Don't save references to `this` (like `self` or `that`). Use arrow functions or `Function#bind`.\n- A base filename should exactly match the name of its default export.\n- Use camelCase when you export-default a function. Your filename should be identical to your function's name.\n- Use PascalCase when you export a constructor / class / singleton / function library / bare object.\n- Acronyms and initialisms should always be consistently all uppercased or all lowercased.\n- You may optionally uppercase a constant only if it (1) is exported, (2) is a `const`, and (3) the programmer can trust it (and its nested properties) to never change. Do not uppercase constants within a file unless exported.\n\n### Variable Naming Examples\n\n```typescript\n// ‚ùå BAD - Abbreviated variables\nworkflows.filter((w) => w.status === 'active');\ndata.map((p) => p.id === tempId ? newPost : p);\nusers.map((u) => u.id);\nconst { id, name } = user; // If destructuring, use descriptive names\n\n// ‚úÖ GOOD - Full descriptive names\nworkflows.filter((workflow) => workflow.status === 'active');\ndata.map((post) => post.id === tempId ? newPost : post);\nusers.map((user) => user.id);\nconst { id: userId, name: userName } = user;\nconst userId = user.id;\n```\n\n## 24. Accessors\n- Accessor functions for properties are not required.\n- Do not use JavaScript getters/setters. Instead, if you do make accessor functions, use `getVal()` and `setVal('hello')`.\n- If the property/method is a `boolean`, use `isVal()` or `hasVal()` for accessor function names.\n- It‚Äôs okay to create generic `get()` and `set()` functions, but be consistent if you do.\n\n## 25. Events\n- When attaching data payloads to events, pass an object literal (hash) instead of a raw value.\n\n## 26. jQuery\n- Prefix jQuery object variables with a `$`.\n- Cache jQuery lookups.\n- For DOM queries use Cascading selectors (`$('.sidebar ul')`) or parent > child selectors (`$('.sidebar > ul')`).\n- Use `find` with scoped jQuery object queries (e.g., `$sidebar.find('ul')`).\n\n## 27. ECMAScript 5 Compatibility\n- (No specific guideline other than referencing compatibility tables).\n\n## 28. ECMAScript 6+ (ES 2015+) Styles\n- Do not use TC39 proposals that have not reached stage 3.\n\n## 29. Standard Library\n- Use `Number.isNaN` instead of global `isNaN`.\n- Use `Number.isFinite` instead of global `isFinite`.\n\n## 30. Testing\n- Write tests.\n- Strive to write many small pure functions, and minimize where mutations occur.\n- Be cautious about stubs and mocks.\n- 100% test coverage is a good goal to strive for.\n- Whenever you fix a bug, write a regression test.",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        },
        {
          "id": "testing",
          "title": "Testing",
          "fileName": "testing.mdc",
          "frontmatter": {
            "description": "Testing philosophy and patterns for the codebase",
            "globs": [
              "**/*.test.ts",
              "**/*.test.tsx",
              "**/*.spec.ts",
              "**/*.spec.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# Testing Guidelines\n\n## Testing Philosophy\n\nOur testing strategy focuses on **testing logic and behavior, not implementation details**. We prioritize testing at the appropriate layer of abstraction to ensure maintainability and meaningful test coverage.\n\n### Core Principles\n\n1. **Test Business Logic in Services** - All business logic should reside in service functions and be thoroughly tested\n2. **Test Authentication/Authorization Separately** - HOFs (Higher-Order Functions) like `withAuthentication` should have their own isolated tests\n3. **Backend API Routes Test Integration** - Test the service layer, not the API route handlers directly\n4. **Frontend is Tested Manually** - UI components and user interactions are validated through manual testing\n5. **No UI Component Tests** - We don't write automated tests for React components\n\n## Testing Stack\n\n- **Framework:** [Jest](https://jestjs.io/)\n- **Utilities:** React Testing Library may be used for testing custom hooks and React utilities, but **NOT for component rendering tests**\n- **TypeScript Support:** `ts-jest`\n- **Mocking:** Jest mocks for external dependencies\n\n**Note:** React Testing Library is available in the stack but should only be used for:\n\n- Testing custom React hooks (`useWorkflowForm`, `useUserPreferences`, etc.)\n- Testing React utilities that need React context\n- **NOT** for testing component rendering, user interactions, or UI behavior\n\n## What to Test\n\n### 1. Service Layer (`src/services/**`)\n\n**Priority: CRITICAL** - This is where all business logic lives\n\n```typescript\n// src/services/__tests__/userService.test.ts\nimport { getUserProfile, updateUserProfile } from \"../userService\";\nimport { supabase } from \"@/lib/supabase\";\n\njest.mock(\"@/lib/supabase\");\n\ndescribe(\"UserService\", () => {\n  describe(\"getUserProfile\", () => {\n    it(\"should fetch user profile successfully\", async () => {\n      const mockUser = { id: \"user-123\", name: \"Test User\" };\n      (supabase.from as jest.Mock).mockReturnValue({\n        select: jest.fn().mockReturnValue({\n          eq: jest.fn().mockReturnValue({\n            single: jest\n              .fn()\n              .mockResolvedValue({ data: mockUser, error: null }),\n          }),\n        }),\n      });\n\n      const result = await getUserProfile(\"user-123\");\n      expect(result).toEqual(mockUser);\n    });\n\n    it(\"should handle database errors gracefully\", async () => {\n      // Test error scenarios\n    });\n  });\n});\n```\n\n### 2. Higher-Order Functions (`src/utils/api/`, `src/utils/auth/`)\n\n**Priority: HIGH** - Authentication and middleware logic must be bulletproof\n\n```typescript\n// src/utils/api/__tests__/withAuthentication.test.ts\nimport { withAuthentication } from \"../withAuthentication\";\nimport { NextApiRequest, NextApiResponse } from \"next\";\nimport { createMocks } from \"node-mocks-http\";\n\ndescribe(\"withAuthentication HOF\", () => {\n  it(\"should allow authenticated requests to proceed\", async () => {\n    const handler = jest.fn((req, res) =>\n      res.status(200).json({ success: true })\n    );\n    const wrapped = withAuthentication(handler);\n\n    const { req, res } = createMocks({\n      headers: { authorization: \"Bearer valid-token\" },\n    });\n\n    await wrapped(req, res);\n    expect(handler).toHaveBeenCalledWith(\n      expect.objectContaining({ user: expect.any(Object) }),\n      res\n    );\n  });\n\n  it(\"should reject unauthenticated requests\", async () => {\n    const handler = jest.fn();\n    const wrapped = withAuthentication(handler);\n\n    const { req, res } = createMocks();\n    await wrapped(req, res);\n\n    expect(res._getStatusCode()).toBe(401);\n    expect(handler).not.toHaveBeenCalled();\n  });\n});\n```\n\n### 3. Utility Functions (`src/utils/**`)\n\n**Priority: MEDIUM** - Pure functions and helpers\n\n```typescript\n// src/utils/__tests__/formatters.test.ts\nimport { formatCurrency, parseDate } from \"../formatters\";\n\ndescribe(\"formatCurrency\", () => {\n  it(\"should format USD correctly\", () => {\n    expect(formatCurrency(1234.56, \"USD\")).toBe(\"$1,234.56\");\n  });\n});\n```\n\n### 4. Validation Schemas (`src/schemas/**`)\n\n**Priority: HIGH** - Data integrity is critical\n\n```typescript\n// src/schemas/__tests__/userSchema.test.ts\nimport { userUpdateSchema } from \"../userSchema\";\n\ndescribe(\"userUpdateSchema\", () => {\n  it(\"should validate correct user data\", () => {\n    const validData = { name: \"John Doe\", email: \"john@example.com\" };\n    expect(() => userUpdateSchema.validateSync(validData)).not.toThrow();\n  });\n\n  it(\"should reject invalid email\", () => {\n    const invalidData = { email: \"not-an-email\" };\n    expect(() => userUpdateSchema.validateSync(invalidData)).toThrow();\n  });\n});\n```\n\n## What NOT to Test\n\n### 1. API Route Handlers\n\nDon't test the route handlers directly - they should be thin wrappers around services:\n\n```typescript\n// ‚ùå DON'T DO THIS\ntest('POST /api/users/create', async () => {\n  const res = await fetch('/api/users/create', { ... });\n  // Testing the HTTP layer\n});\n\n// ‚úÖ DO THIS INSTEAD\ntest('createUser service', async () => {\n  const user = await createUser({ ... });\n  // Test the service directly\n});\n```\n\n### 2. React Components\n\nNo automated component testing - rely on manual testing:\n\n```typescript\n// ‚ùå NO COMPONENT TESTS - Don't test component rendering\ntest(\"Button renders correctly\", () => {\n  render(<Button />);\n  // We don't do this\n});\n\n// ‚úÖ ALLOWED - Testing custom hooks (not components)\nimport { renderHook } from \"@testing-library/react\";\ntest(\"useWorkflowForm initializes correctly\", () => {\n  const { result } = renderHook(() => useWorkflowForm());\n  expect(result.current.values).toEqual({});\n});\n```\n\n**When React Testing Library is acceptable:**\n\n- Testing custom hooks that contain business logic\n- Testing utilities that use React context\n- **Never** for testing component rendering, props, or user interactions\n\n### 3. Next.js Page Components\n\nPages are just components - test manually:\n\n```typescript\n// ‚ùå NO PAGE TESTS\ntest(\"Dashboard page loads\", () => {\n  render(<DashboardPage />);\n  // Manual testing only\n});\n```\n\n## Test Organization\n\n```\nsrc/\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ __tests__/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ userService.test.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflowService.test.ts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authService.test.ts\n‚îÇ   ‚îú‚îÄ‚îÄ userService.ts\n‚îÇ   ‚îî‚îÄ‚îÄ workflowService.ts\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __tests__/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ withAuthentication.test.ts\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ withValidation.test.ts\n‚îÇ   ‚îî‚îÄ‚îÄ __tests__/\n‚îÇ       ‚îî‚îÄ‚îÄ helpers.test.ts\n‚îî‚îÄ‚îÄ schemas/\n    ‚îî‚îÄ‚îÄ __tests__/\n        ‚îî‚îÄ‚îÄ validationSchemas.test.ts\n```\n\n## Testing Best Practices\n\n### 1. Test Behavior, Not Implementation\n\n```typescript\n// ‚ùå BAD - Testing implementation details\nexpect(service._privateMethod()).toBe(\"something\");\nexpect(mockDatabase.query).toHaveBeenCalledWith(\"SELECT * FROM users\");\n\n// ‚úÖ GOOD - Testing behavior\nexpect(await service.getActiveUsers()).toHaveLength(3);\nexpect(await service.findUserByEmail(\"test@example.com\")).toMatchObject({\n  email: \"test@example.com\",\n});\n```\n\n### 2. Use Descriptive Test Names\n\n```typescript\n// ‚ùå BAD\ntest(\"test user creation\");\ntest(\"error case\");\n\n// ‚úÖ GOOD\ntest(\"should create user with valid email and password\");\ntest(\"should throw ValidationError when email is missing\");\n```\n\n### 3. Isolate External Dependencies\n\n```typescript\n// Always mock external services\njest.mock(\"@/lib/supabase\");\njest.mock(\"@/lib/emailService\");\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n```\n\n### 4. Test Edge Cases in Services\n\n```typescript\ndescribe(\"WorkflowService\", () => {\n  test(\"should handle empty workflow steps\", async () => {});\n  test(\"should handle circular dependencies\", async () => {});\n  test(\"should handle missing required fields\", async () => {});\n  test(\"should handle concurrent modifications\", async () => {});\n});\n```\n\n## Running Tests\n\n```bash\n# Run all tests\nnpm test\n\n# Run tests in watch mode during development\nnpm run test:watch\n\n# Run tests with coverage (aim for 100% coverage on services)\nnpm run test:coverage\n\n# Run specific test file\nnpm test src/services/__tests__/userService.test.ts\n```\n\n## Coverage Goals\n\n- **Services (`src/services/`)**: 100% coverage required\n- **HOFs (`src/utils/api/`)**: 100% coverage required\n- **Validation Schemas**: 100% coverage required\n- **Utility Functions**: 90%+ coverage recommended\n- **Overall**: Focus on critical business logic, not lines of code\n\n## Mocking Guidelines\n\n### 1. Mock at the Boundary\n\n```typescript\n// Mock external services, not internal modules\njest.mock(\"@/lib/supabase\"); // ‚úÖ Good\njest.mock(\"../internalHelper\"); // ‚ùå Avoid\n```\n\n### 2. Use Consistent Mock Patterns\n\n```typescript\n// Create reusable mock factories\nexport const mockSupabaseUser = (overrides = {}) => ({\n  id: \"user-123\",\n  email: \"test@example.com\",\n  created_at: new Date().toISOString(),\n  ...overrides,\n});\n```\n\n## Integration Testing\n\nWhile we primarily focus on unit tests, some integration between services may need testing:\n\n```typescript\n// When services interact, test the integration\ndescribe(\"AuthService + UserService integration\", () => {\n  test(\"should create user profile after successful signup\", async () => {\n    const credentials = { email: \"new@example.com\", password: \"secure123\" };\n    const { user } = await authService.signUp(credentials);\n    const profile = await userService.getUserProfile(user.id);\n\n    expect(profile).toMatchObject({\n      userId: user.id,\n      email: credentials.email,\n    });\n  });\n});\n```\n\n## Remember\n\n- **Frontend = Manual Testing**: Trust your eyes and hands for UI testing\n- **Backend = Automated Testing**: Services must be thoroughly tested\n- **Logic Lives in Services**: Keep API routes thin, test services\n- **Test the Contract**: Focus on inputs/outputs, not how it works\n- **Fast Feedback**: Tests should run quickly to encourage TDD\n",
          "alwaysApply": true,
          "globs": [
            "**/*.test.ts",
            "**/*.test.tsx",
            "**/*.spec.ts",
            "**/*.spec.tsx"
          ]
        }
      ]
    },
    {
      "id": "python",
      "name": "Python",
      "directory": "Python",
      "icon": "icons/python.png",
      "summary": "General Python development",
      "focus": "Type safety, readability, best practices",
      "readme": "# Cursor Rules for Python Projects\n\nThis folder contains Cursor AI coding rules and guidelines for general Python projects. These rules help maintain consistency, code quality, and best practices when working with Python codebases and AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and best practices.\n\n## Overview of Rules\n\n### üìò Python Code Style Guide (`python-code-style-guide.mdc`)\n\nA comprehensive Python coding standards guide that establishes best practices for writing clean, maintainable, and type-safe Python code.\n\n**Philosophy:**\n- **Readability** - Python's core philosophy is that code is read more than written\n- **Type Safety** - Leverage type hints fully for clarity and tooling support\n- **Explicitness** - Explicit is better than implicit (PEP 20)\n- **Consistency** - Uniform patterns across the codebase\n- **Quality** - No shortcuts, no suppressed errors, no technical debt\n\n**Key Topics Covered:**\n\n1. **The Zen of Python**\n   - Core principles from PEP 20\n   - Readability and simplicity\n   - Explicit over implicit\n\n2. **Naming Conventions**\n   - Variables & Functions: `snake_case`\n   - Classes: `PascalCase`\n   - Constants: `UPPER_SNAKE_CASE`\n   - **NEVER abbreviate** - always use full, descriptive names\n\n3. **Type Hints**\n   - Mandatory for all functions\n   - Modern syntax (Python 3.10+)\n   - Generic types and TypeVars\n   - Forward references\n   - Type aliases\n\n4. **Functions**\n   - Single responsibility principle\n   - Proper docstrings\n   - Default arguments\n   - Lambda functions\n   - Pure functions\n\n5. **Classes**\n   - Well-structured class definitions\n   - Dataclasses for data containers\n   - Inheritance and composition\n   - Properties and descriptors\n   - Abstract base classes\n\n6. **Error Handling**\n   - Custom exception hierarchy\n   - Specific exception handling\n   - Context managers\n   - Proper logging\n\n7. **Async Programming**\n   - Async/await patterns\n   - Parallel execution\n   - Concurrency limits\n   - Timeout handling\n\n8. **Collections and Comprehensions**\n   - List/dict/set comprehensions\n   - Generator expressions\n   - itertools usage\n   - Performance considerations\n\n9. **Code Quality**\n   - Pre-commit hooks\n   - Type checking with mypy\n   - Linting with ruff\n   - Formatting with Black\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @python-code-style-guide.mdc Please refactor this function to follow our Python style guide\n   ```\n\n### File Structure\n\n```\nPython/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ python-code-style-guide.mdc\n```\n\n## Quick Reference\n\n### When Writing Python Code\n\n- ‚úÖ **Always use type hints** - For all function parameters and return types\n- ‚úÖ **Never abbreviate variables** - Use full, descriptive names\n- ‚úÖ **Write docstrings** - Google-style for all public functions\n- ‚úÖ **Handle errors properly** - Never use bare `except:`\n- ‚úÖ **Use f-strings** - Preferred for string formatting\n- ‚úÖ **Follow PEP 8** - Consistent formatting with Black\n- ‚úÖ **Use dataclasses** - For structured data containers\n- ‚úÖ **Prefer composition** - Over complex inheritance hierarchies\n- ‚úÖ **Write pure functions** - Where possible for testability\n- ‚úÖ **Use context managers** - For resource management\n\n### Type Hints Checklist\n\nBefore submitting code, ensure:\n\n- [ ] All functions have parameter type hints\n- [ ] All functions have return type hints\n- [ ] Complex types use proper generics\n- [ ] Optional values use `X | None` syntax\n- [ ] Type aliases are used for complex types\n- [ ] Forward references use `from __future__ import annotations`\n\n### Naming Examples\n\n```python\n# ‚ùå BAD - Abbreviated names\ndef calc_tot(items):\n    return sum(i.price for i in items)\n\n# ‚úÖ GOOD - Descriptive names\ndef calculate_total(items: list[Item]) -> float:\n    return sum(item.price for item in items)\n\n# ‚ùå BAD - Single letter variables\nfor u in users:\n    process(u)\n\n# ‚úÖ GOOD - Descriptive iteration variables\nfor user in users:\n    process_user(user)\n```\n\n### Function Examples\n\n```python\n# ‚úÖ GOOD - Type hints, docstring, single responsibility\ndef validate_email(email: str) -> bool:\n    \"\"\"\n    Validate email format.\n\n    Args:\n        email: Email address to validate\n\n    Returns:\n        True if email format is valid, False otherwise\n\n    Example:\n        >>> validate_email(\"user@example.com\")\n        True\n    \"\"\"\n    import re\n    pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    return bool(re.match(pattern, email))\n```\n\n### Error Handling Examples\n\n```python\n# ‚ùå BAD - Bare except\ntry:\n    risky_operation()\nexcept:\n    pass\n\n# ‚ùå BAD - Catching too broadly\ntry:\n    risky_operation()\nexcept Exception:\n    pass\n\n# ‚úÖ GOOD - Specific exceptions with proper handling\ntry:\n    result = risky_operation()\nexcept ValueError as error:\n    logger.warning(\"Invalid value: %s\", error)\n    raise ValidationError(str(error)) from error\nexcept IOError as error:\n    logger.error(\"IO operation failed\", exc_info=True)\n    raise\n```\n\n### Async Examples\n\n```python\n# ‚úÖ GOOD - Parallel execution\nasync def fetch_user_with_posts(user_id: int) -> tuple[User, list[Post]]:\n    \"\"\"Fetch user and their posts in parallel.\"\"\"\n    user_task = asyncio.create_task(fetch_user(user_id))\n    posts_task = asyncio.create_task(fetch_user_posts(user_id))\n    \n    user, posts = await asyncio.gather(user_task, posts_task)\n    return user, posts\n```\n\n## Best Practices Summary\n\n### DO ‚úÖ\n\n- Use type hints for all functions\n- Write descriptive, non-abbreviated variable names\n- Provide Google-style docstrings for public APIs\n- Handle exceptions specifically and properly\n- Use dataclasses for data containers\n- Prefer composition over inheritance\n- Use context managers for resources\n- Write pure functions when possible\n- Use async/await for I/O operations\n- Run Black, isort, and mypy\n\n### DON'T ‚ùå\n\n- Never use bare `except:`\n- Never abbreviate variable names\n- Never skip type hints\n- Never use mutable default arguments\n- Never use `type()` for type checking (use `isinstance()`)\n- Never ignore exceptions silently\n- Never use global mutable state\n- Never mix blocking I/O with async\n- Never suppress linter errors without reason\n\n## Tooling Configuration\n\n### pyproject.toml\n\n```toml\n[tool.black]\nline-length = 100\ntarget-version = ['py311']\n\n[tool.isort]\nprofile = \"black\"\nline_length = 100\n\n[tool.ruff]\nline-length = 100\ntarget-version = \"py311\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"W\", \"F\", \"I\", \"B\", \"C4\", \"UP\"]\n\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\n```\n\n### Pre-commit Hooks\n\n```yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 24.4.2\n    hooks:\n      - id: black\n\n  - repo: https://github.com/pycqa/isort\n    rev: 5.13.2\n    hooks:\n      - id: isort\n\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.4.4\n    hooks:\n      - id: ruff\n        args: [--fix]\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.10.0\n    hooks:\n      - id: mypy\n```\n\n## Integration with Framework-Specific Rules\n\nThis general Python guide can be used alongside framework-specific rules:\n\n- **Python + FastAPI:** See `../Python + FastAPI/` for FastAPI-specific patterns\n- **Python + Django:** Use this guide with Django best practices\n- **Python + Flask:** Combine with Flask patterns\n- **Any Python Project:** This guide provides the foundation for all Python projects\n\n## Related Guidelines\n\nFor framework-specific Python patterns, see:\n\n- **[Python + FastAPI](../Python%20+%20FastAPI/)** - FastAPI and async API patterns\n- **[Root README](../README.md)** - Overview of all coding rules\n\n## Contributing\n\nWhen updating these rules:\n\n1. Keep guidelines clear and actionable\n2. Include examples where helpful (‚ùå BAD vs ‚úÖ GOOD patterns)\n3. Update this README if adding new rule files\n4. Ensure consistency with other Python-related rules\n5. Test guidelines work well with AI assistants\n\n## Notes\n\n- These rules are designed for general Python projects (3.10+)\n- Rules marked with `alwaysApply: true` are enforced automatically\n- The guide emphasizes type safety and readability above all else\n- Never suppress errors - always fix the root cause\n- When used with framework-specific rules, this guide provides the Python foundation\n\n## Remember\n\n- **Python is readable by design** - write code that reads like prose\n- **Explicit is better than implicit** - be clear about your intentions\n- **Type hints are documentation** - they help both humans and tools\n- **Errors should never pass silently** - always handle exceptions properly\n- **Consistency is key** - follow these patterns uniformly across the codebase\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "guides": [
        {
          "id": "python-code-style-guide",
          "title": "Python Code Style Guide",
          "fileName": "python-code-style-guide.mdc",
          "frontmatter": {
            "description": "Comprehensive Python code style guide based on PEP 8 and modern best practices",
            "globs": [
              "**/*.py"
            ],
            "alwaysApply": true
          },
          "content": "# Python Code Style Guide\n\n## Philosophy\n\nThis guide establishes Python coding standards that prioritize:\n1. **Readability** - Python's core philosophy is that code is read more than written\n2. **Type Safety** - Leverage type hints fully for clarity and tooling support\n3. **Explicitness** - Explicit is better than implicit (PEP 20)\n4. **Consistency** - Uniform patterns across the codebase\n5. **Quality** - No shortcuts, no suppressed errors, no technical debt\n\n## Core Principles\n\n### 1. The Zen of Python\n\nAlways remember the guiding principles from PEP 20:\n\n```python\n# Key principles to internalize:\n# - Beautiful is better than ugly\n# - Explicit is better than implicit\n# - Simple is better than complex\n# - Readability counts\n# - Errors should never pass silently\n# - In the face of ambiguity, refuse the temptation to guess\n```\n\n### 2. Descriptive Naming\n\n**NEVER abbreviate variables.** Always use full, descriptive names.\n\n```python\n# ‚ùå BAD - Abbreviated and unclear\nwfs = workflows.filter(lambda w: w.status == \"active\")\nusr = users.find(lambda u: u.id == uid)\ndef calc_tot(items): pass\n\n# ‚úÖ GOOD - Clear and descriptive\nactive_workflows = [workflow for workflow in workflows if workflow.status == \"active\"]\nuser = next((user for user in users if user.id == user_id), None)\ndef calculate_total(items: list[Item]) -> float: pass\n\n# ‚ùå BAD - Single letter variables (except in specific contexts)\nfor i in items:\n    process(i)\n    \nd = {}\nfor k, v in data.items():\n    d[k] = v\n\n# ‚úÖ GOOD - Descriptive names\nfor item in items:\n    process_item(item)\n\nresult = {}\nfor key, value in data.items():\n    result[key] = value\n\n# ‚úÖ ACCEPTABLE - Single letters in mathematical/conventional contexts\nfor i in range(10):  # Loop index\n    matrix[i][i] = 1  # Diagonal\n\nfor x, y in coordinates:  # Mathematical convention\n    plot_point(x, y)\n```\n\n**Naming Conventions:**\n- **Variables & Functions:** `snake_case` - `get_user_profile`, `is_valid`, `has_permission`\n- **Classes:** `PascalCase` - `UserService`, `ValidationError`, `ApiResponse`\n- **Constants:** `UPPER_SNAKE_CASE` - `MAX_RETRIES`, `DEFAULT_TIMEOUT`, `API_BASE_URL`\n- **Private Members:** Leading underscore - `_internal_method`, `_cache`\n- **\"Magic\" Methods:** Double underscore - `__init__`, `__str__`, `__repr__`\n- **Type Variables:** `PascalCase` - `T`, `K`, `V`, or descriptive like `ItemType`\n\n### 3. Type Hints\n\nAll functions MUST have type hints. This is non-negotiable.\n\n```python\n# ‚ùå BAD - No type hints\ndef process_user(user_data):\n    return user_data\n\ndef get_items(ids):\n    return [fetch_item(id) for id in ids]\n\n# ‚úÖ GOOD - Basic type hints\ndef process_user(user_data: dict) -> dict:\n    return user_data\n\ndef get_items(ids: list[int]) -> list[Item]:\n    return [fetch_item(item_id) for item_id in ids]\n\n# ‚úÖ BETTER - Specific types with modern syntax (Python 3.10+)\nfrom typing import Optional\n\ndef process_user(user_data: dict[str, Any]) -> dict[str, Any]:\n    return user_data\n\ndef get_user(user_id: int) -> User | None:\n    \"\"\"Get user by ID, returns None if not found.\"\"\"\n    return users.get(user_id)\n\n# ‚úÖ BEST - Using Pydantic or dataclasses for structured data\nfrom dataclasses import dataclass\nfrom pydantic import BaseModel\n\n@dataclass\nclass UserData:\n    name: str\n    email: str\n    age: int | None = None\n\ndef process_user(user_data: UserData) -> ProcessedUser:\n    return ProcessedUser.from_data(user_data)\n```\n\n#### Type Hint Best Practices\n\n```python\nfrom typing import (\n    Any,\n    Callable,\n    ClassVar,\n    Final,\n    Generic,\n    Literal,\n    Optional,\n    TypeAlias,\n    TypeVar,\n)\nfrom collections.abc import Iterable, Mapping, Sequence\n\n# Modern union syntax (Python 3.10+)\ndef get_value(key: str) -> int | None:\n    pass\n\n# For Python 3.9, use Optional\ndef get_value(key: str) -> Optional[int]:\n    pass\n\n# Generic types\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\nV = TypeVar(\"V\")\n\ndef first_or_none(items: Sequence[T]) -> T | None:\n    \"\"\"Return first item or None if empty.\"\"\"\n    return items[0] if items else None\n\ndef get_or_default(mapping: Mapping[K, V], key: K, default: V) -> V:\n    \"\"\"Get value from mapping or return default.\"\"\"\n    return mapping.get(key, default)\n\n# Callable types\nHandler = Callable[[str, int], bool]\n\ndef register_handler(handler: Handler) -> None:\n    \"\"\"Register an event handler.\"\"\"\n    pass\n\n# Type aliases\nUserId = int\nUserMap = dict[UserId, User]\n\ndef get_users() -> UserMap:\n    pass\n\n# Literal types for specific values\ndef set_log_level(level: Literal[\"debug\", \"info\", \"warning\", \"error\"]) -> None:\n    pass\n\n# Final for constants\nMAX_RETRIES: Final = 3\nAPI_VERSION: Final[str] = \"v1\"\n\n# ClassVar for class-level attributes\nclass Config:\n    DEFAULT_TIMEOUT: ClassVar[int] = 30\n```\n\n#### Forward References\n\n```python\nfrom __future__ import annotations\n\nclass Node:\n    def __init__(self, value: int, next_node: Node | None = None) -> None:\n        self.value = value\n        self.next = next_node\n\n    def get_next(self) -> Node | None:\n        return self.next\n```\n\n### 4. Functions\n\n#### Function Definitions\n\n```python\n# ‚úÖ GOOD - Type hints, docstring, single responsibility\ndef calculate_total_price(\n    items: list[Item],\n    discount_percentage: float = 0.0,\n    include_tax: bool = True,\n) -> float:\n    \"\"\"\n    Calculate the total price of items with optional discount and tax.\n\n    Args:\n        items: List of items to calculate price for\n        discount_percentage: Discount to apply (0-100)\n        include_tax: Whether to include tax in the calculation\n\n    Returns:\n        Total price after discount and optional tax\n\n    Raises:\n        ValueError: If discount_percentage is negative or greater than 100\n\n    Example:\n        >>> items = [Item(price=10.0), Item(price=20.0)]\n        >>> calculate_total_price(items, discount_percentage=10)\n        27.0\n    \"\"\"\n    if discount_percentage < 0 or discount_percentage > 100:\n        raise ValueError(\"Discount must be between 0 and 100\")\n\n    subtotal = sum(item.price for item in items)\n    discounted = subtotal * (1 - discount_percentage / 100)\n    \n    if include_tax:\n        return discounted * TAX_RATE\n    return discounted\n```\n\n#### Function Best Practices\n\n```python\n# ‚úÖ GOOD - Single responsibility, pure functions where possible\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate email format.\"\"\"\n    import re\n    pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    return bool(re.match(pattern, email))\n\ndef normalize_email(email: str) -> str:\n    \"\"\"Normalize email to lowercase.\"\"\"\n    return email.strip().lower()\n\ndef prepare_user_email(email: str) -> str:\n    \"\"\"Validate and normalize user email.\"\"\"\n    normalized = normalize_email(email)\n    if not validate_email(normalized):\n        raise ValueError(f\"Invalid email format: {email}\")\n    return normalized\n\n# ‚ùå BAD - Multiple responsibilities\ndef process_user_email(email: str, db: Database) -> User:\n    # Validates\n    # Normalizes\n    # Checks database\n    # Creates user\n    # Sends email\n    pass\n\n# ‚úÖ GOOD - Default arguments\ndef fetch_data(\n    endpoint: str,\n    timeout: float = 30.0,\n    retries: int = 3,\n) -> dict[str, Any]:\n    \"\"\"Fetch data from endpoint with configurable timeout and retries.\"\"\"\n    pass\n\n# ‚úÖ GOOD - *args and **kwargs with types\ndef log_event(\n    event_type: str,\n    *args: str,\n    level: str = \"info\",\n    **metadata: Any,\n) -> None:\n    \"\"\"Log an event with optional metadata.\"\"\"\n    pass\n```\n\n#### Lambda Functions\n\n```python\n# ‚úÖ GOOD - Simple lambdas for inline operations\nusers_sorted_by_name = sorted(users, key=lambda user: user.name)\nactive_users = list(filter(lambda user: user.is_active, users))\n\n# ‚ùå BAD - Complex lambdas (use regular functions instead)\nprocess = lambda x: x.value * 2 if x.is_valid and x.status == \"active\" else 0\n\n# ‚úÖ GOOD - Regular function for complex logic\ndef calculate_value(item: Item) -> float:\n    if item.is_valid and item.status == \"active\":\n        return item.value * 2\n    return 0\n\nprocessed = [calculate_value(item) for item in items]\n```\n\n### 5. Classes\n\n#### Class Definitions\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import ClassVar\n\n\n# ‚úÖ GOOD - Well-structured class\nclass UserService:\n    \"\"\"Service for user-related operations.\"\"\"\n\n    DEFAULT_PAGE_SIZE: ClassVar[int] = 20\n\n    def __init__(self, database: Database, cache: Cache) -> None:\n        \"\"\"\n        Initialize UserService.\n\n        Args:\n            database: Database connection\n            cache: Cache instance for caching user data\n        \"\"\"\n        self._database = database\n        self._cache = cache\n\n    async def get_user_by_id(self, user_id: int) -> User | None:\n        \"\"\"Get user by ID, checking cache first.\"\"\"\n        cached = await self._cache.get(f\"user:{user_id}\")\n        if cached:\n            return User.from_dict(cached)\n\n        user = await self._database.fetch_user(user_id)\n        if user:\n            await self._cache.set(f\"user:{user_id}\", user.to_dict())\n        return user\n\n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create a new user.\"\"\"\n        user = await self._database.create_user(user_data)\n        await self._cache.set(f\"user:{user.id}\", user.to_dict())\n        return user\n\n    def _validate_user_data(self, user_data: UserCreate) -> None:\n        \"\"\"Validate user data (internal method).\"\"\"\n        if not user_data.email:\n            raise ValidationError(\"Email is required\")\n\n\n# ‚úÖ GOOD - Dataclass for data containers\n@dataclass\nclass Point:\n    \"\"\"A 2D point.\"\"\"\n\n    x: float\n    y: float\n\n    def distance_from_origin(self) -> float:\n        \"\"\"Calculate distance from origin.\"\"\"\n        return (self.x**2 + self.y**2) ** 0.5\n\n\n# ‚úÖ GOOD - Dataclass with defaults and factory\n@dataclass\nclass UserConfig:\n    \"\"\"User configuration settings.\"\"\"\n\n    username: str\n    email: str\n    preferences: dict[str, Any] = field(default_factory=dict)\n    max_items: int = 100\n    is_premium: bool = False\n\n\n# ‚úÖ GOOD - Frozen dataclass for immutable data\n@dataclass(frozen=True)\nclass ApiResponse:\n    \"\"\"Immutable API response.\"\"\"\n\n    status_code: int\n    body: str\n    headers: tuple[tuple[str, str], ...] = ()\n```\n\n#### Inheritance and Composition\n\n```python\nfrom abc import ABC, abstractmethod\n\n\n# ‚úÖ GOOD - Abstract base class\nclass Repository(ABC):\n    \"\"\"Abstract base repository.\"\"\"\n\n    @abstractmethod\n    async def get_by_id(self, entity_id: int) -> Entity | None:\n        \"\"\"Get entity by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def create(self, entity: Entity) -> Entity:\n        \"\"\"Create new entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def update(self, entity: Entity) -> Entity:\n        \"\"\"Update existing entity.\"\"\"\n        pass\n\n\nclass UserRepository(Repository):\n    \"\"\"User repository implementation.\"\"\"\n\n    def __init__(self, database: Database) -> None:\n        self._database = database\n\n    async def get_by_id(self, entity_id: int) -> User | None:\n        return await self._database.fetch_user(entity_id)\n\n    async def create(self, entity: User) -> User:\n        return await self._database.create_user(entity)\n\n    async def update(self, entity: User) -> User:\n        return await self._database.update_user(entity)\n\n\n# ‚úÖ GOOD - Prefer composition over inheritance\nclass UserService:\n    \"\"\"User service using composition.\"\"\"\n\n    def __init__(\n        self,\n        repository: UserRepository,\n        validator: UserValidator,\n        notifier: Notifier,\n    ) -> None:\n        self._repository = repository\n        self._validator = validator\n        self._notifier = notifier\n\n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create user with validation and notification.\"\"\"\n        self._validator.validate(user_data)\n        user = await self._repository.create(User.from_create_data(user_data))\n        await self._notifier.notify_user_created(user)\n        return user\n```\n\n#### Properties and Descriptors\n\n```python\nclass Temperature:\n    \"\"\"Temperature with Celsius and Fahrenheit conversion.\"\"\"\n\n    def __init__(self, celsius: float = 0.0) -> None:\n        self._celsius = celsius\n\n    @property\n    def celsius(self) -> float:\n        \"\"\"Get temperature in Celsius.\"\"\"\n        return self._celsius\n\n    @celsius.setter\n    def celsius(self, value: float) -> None:\n        \"\"\"Set temperature in Celsius.\"\"\"\n        if value < -273.15:\n            raise ValueError(\"Temperature cannot be below absolute zero\")\n        self._celsius = value\n\n    @property\n    def fahrenheit(self) -> float:\n        \"\"\"Get temperature in Fahrenheit.\"\"\"\n        return self._celsius * 9 / 5 + 32\n\n    @fahrenheit.setter\n    def fahrenheit(self, value: float) -> None:\n        \"\"\"Set temperature in Fahrenheit.\"\"\"\n        self.celsius = (value - 32) * 5 / 9\n```\n\n### 6. Error Handling\n\n```python\n# ‚úÖ GOOD - Custom exception hierarchy\nclass ApplicationError(Exception):\n    \"\"\"Base exception for application errors.\"\"\"\n\n    def __init__(self, message: str, code: str | None = None) -> None:\n        self.message = message\n        self.code = code or self.__class__.__name__\n        super().__init__(self.message)\n\n\nclass ValidationError(ApplicationError):\n    \"\"\"Validation error.\"\"\"\n\n    def __init__(self, message: str, field: str | None = None) -> None:\n        super().__init__(message, code=\"VALIDATION_ERROR\")\n        self.field = field\n\n\nclass NotFoundError(ApplicationError):\n    \"\"\"Resource not found error.\"\"\"\n\n    def __init__(self, resource: str, identifier: Any = None) -> None:\n        message = f\"{resource} not found\"\n        if identifier:\n            message = f\"{resource} with id '{identifier}' not found\"\n        super().__init__(message, code=\"NOT_FOUND\")\n        self.resource = resource\n        self.identifier = identifier\n\n\nclass AuthenticationError(ApplicationError):\n    \"\"\"Authentication error.\"\"\"\n\n    def __init__(self, message: str = \"Authentication failed\") -> None:\n        super().__init__(message, code=\"AUTHENTICATION_ERROR\")\n\n\n# ‚úÖ GOOD - Specific exception handling\ndef get_user_by_id(user_id: int) -> User:\n    \"\"\"Get user by ID.\"\"\"\n    try:\n        user = database.fetch_user(user_id)\n    except DatabaseConnectionError as error:\n        logger.error(\"Database connection failed\", exc_info=True)\n        raise ApplicationError(\"Service temporarily unavailable\") from error\n    except DatabaseQueryError as error:\n        logger.error(\"Query failed\", exc_info=True)\n        raise ApplicationError(\"Failed to fetch user\") from error\n\n    if user is None:\n        raise NotFoundError(\"User\", user_id)\n\n    return user\n\n\n# ‚ùå BAD - Bare except\ntry:\n    risky_operation()\nexcept:  # Catches everything including KeyboardInterrupt!\n    pass\n\n# ‚ùå BAD - Too broad exception\ntry:\n    risky_operation()\nexcept Exception:\n    pass  # Silently ignoring all errors\n\n# ‚úÖ GOOD - Specific exceptions with logging\ntry:\n    result = risky_operation()\nexcept ValueError as error:\n    logger.warning(\"Invalid value provided: %s\", error)\n    raise ValidationError(str(error)) from error\nexcept IOError as error:\n    logger.error(\"IO operation failed\", exc_info=True)\n    raise\n\n# ‚úÖ GOOD - Using else and finally\ntry:\n    file = open(filepath)\nexcept FileNotFoundError:\n    logger.warning(\"File not found: %s\", filepath)\n    return None\nelse:\n    # Only runs if no exception\n    content = file.read()\nfinally:\n    # Always runs\n    file.close()\n```\n\n### 7. Context Managers\n\n```python\nfrom contextlib import contextmanager, asynccontextmanager\nfrom typing import Generator, AsyncGenerator\n\n\n# ‚úÖ GOOD - Context manager for resource management\n@contextmanager\ndef database_transaction(database: Database) -> Generator[Transaction, None, None]:\n    \"\"\"Context manager for database transactions.\"\"\"\n    transaction = database.begin_transaction()\n    try:\n        yield transaction\n        transaction.commit()\n    except Exception:\n        transaction.rollback()\n        raise\n\n\n# Usage\nwith database_transaction(db) as transaction:\n    transaction.execute(\"INSERT INTO users VALUES (?)\", [user_data])\n    transaction.execute(\"INSERT INTO audit_log VALUES (?)\", [audit_data])\n\n\n# ‚úÖ GOOD - Async context manager\n@asynccontextmanager\nasync def async_database_session(pool: ConnectionPool) -> AsyncGenerator[Session, None]:\n    \"\"\"Async context manager for database sessions.\"\"\"\n    session = await pool.acquire()\n    try:\n        yield session\n    finally:\n        await pool.release(session)\n\n\n# ‚úÖ GOOD - Class-based context manager\nclass Timer:\n    \"\"\"Context manager for timing code blocks.\"\"\"\n\n    def __init__(self, name: str = \"Operation\") -> None:\n        self.name = name\n        self.start_time: float = 0\n        self.end_time: float = 0\n\n    def __enter__(self) -> \"Timer\":\n        self.start_time = time.perf_counter()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> bool:\n        self.end_time = time.perf_counter()\n        elapsed = self.end_time - self.start_time\n        logger.info(\"%s took %.4f seconds\", self.name, elapsed)\n        return False  # Don't suppress exceptions\n\n\n# Usage\nwith Timer(\"Data processing\"):\n    process_large_dataset(data)\n```\n\n### 8. Async/Await\n\n```python\nimport asyncio\nfrom typing import Any\n\n\n# ‚úÖ GOOD - Proper async function\nasync def fetch_user_data(user_id: int) -> dict[str, Any]:\n    \"\"\"Fetch user data asynchronously.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"{API_URL}/users/{user_id}\") as response:\n            response.raise_for_status()\n            return await response.json()\n\n\n# ‚úÖ GOOD - Parallel execution\nasync def fetch_user_with_posts(user_id: int) -> tuple[User, list[Post]]:\n    \"\"\"Fetch user and their posts in parallel.\"\"\"\n    user_task = asyncio.create_task(fetch_user(user_id))\n    posts_task = asyncio.create_task(fetch_user_posts(user_id))\n\n    user, posts = await asyncio.gather(user_task, posts_task)\n    return user, posts\n\n\n# ‚úÖ GOOD - Batch processing with semaphore\nasync def fetch_all_users(user_ids: list[int], max_concurrent: int = 10) -> list[User]:\n    \"\"\"Fetch multiple users with concurrency limit.\"\"\"\n    semaphore = asyncio.Semaphore(max_concurrent)\n\n    async def fetch_with_limit(user_id: int) -> User:\n        async with semaphore:\n            return await fetch_user(user_id)\n\n    tasks = [fetch_with_limit(user_id) for user_id in user_ids]\n    return await asyncio.gather(*tasks)\n\n\n# ‚úÖ GOOD - Timeout handling\nasync def fetch_with_timeout(url: str, timeout: float = 30.0) -> dict[str, Any]:\n    \"\"\"Fetch data with timeout.\"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            return await fetch_data(url)\n    except asyncio.TimeoutError:\n        logger.warning(\"Request to %s timed out after %.1fs\", url, timeout)\n        raise\n\n\n# ‚ùå BAD - Blocking I/O in async function\nasync def bad_read_file(filepath: str) -> str:\n    # This blocks the event loop!\n    with open(filepath) as file:\n        return file.read()\n\n# ‚úÖ GOOD - Use async file I/O\nasync def read_file_async(filepath: str) -> str:\n    \"\"\"Read file asynchronously.\"\"\"\n    async with aiofiles.open(filepath) as file:\n        return await file.read()\n\n\n# ‚úÖ GOOD - Run blocking code in thread pool\nasync def run_blocking_operation(data: bytes) -> str:\n    \"\"\"Run CPU-bound operation in thread pool.\"\"\"\n    loop = asyncio.get_running_loop()\n    return await loop.run_in_executor(None, process_data_sync, data)\n```\n\n### 9. Collections and Comprehensions\n\n```python\n# ‚úÖ GOOD - List comprehensions\nsquares = [number**2 for number in range(10)]\neven_squares = [number**2 for number in range(10) if number % 2 == 0]\n\n# ‚úÖ GOOD - Dict comprehensions\nuser_by_id = {user.id: user for user in users}\nname_lengths = {name: len(name) for name in names}\n\n# ‚úÖ GOOD - Set comprehensions\nunique_domains = {email.split(\"@\")[1] for email in emails}\n\n# ‚úÖ GOOD - Generator expressions for large datasets\ntotal = sum(item.price for item in items)  # Memory efficient\nfirst_valid = next((item for item in items if item.is_valid), None)\n\n# ‚ùå BAD - Overly complex comprehensions\nresult = [\n    process(item)\n    for item in data\n    if validate(item) and transform(item) and check(item) and filter(item)\n]\n\n# ‚úÖ GOOD - Break complex logic into functions\ndef should_process(item: Item) -> bool:\n    \"\"\"Check if item should be processed.\"\"\"\n    return (\n        item.is_valid\n        and item.status == \"active\"\n        and item.owner_id in allowed_owners\n    )\n\nresult = [process(item) for item in data if should_process(item)]\n\n# ‚úÖ GOOD - Multiline comprehensions for readability\nactive_user_emails = [\n    user.email\n    for user in users\n    if user.is_active and user.email_verified\n]\n\n# ‚úÖ GOOD - Using itertools for complex operations\nfrom itertools import groupby, chain, islice\n\n# Group items by category\nitems_by_category = {\n    category: list(group)\n    for category, group in groupby(sorted(items, key=lambda x: x.category), key=lambda x: x.category)\n}\n\n# Chain multiple iterables\nall_items = list(chain(items_a, items_b, items_c))\n\n# Take first N items\nfirst_ten = list(islice(all_items, 10))\n```\n\n### 10. String Formatting\n\n```python\nname = \"Alice\"\ncount = 42\nprice = 19.99\n\n# ‚úÖ GOOD - f-strings (preferred)\nmessage = f\"Hello, {name}! You have {count} items.\"\nformatted_price = f\"Total: ${price:.2f}\"\n\n# ‚úÖ GOOD - f-strings with expressions\ndebug_info = f\"User {user.id} has {len(user.items)} items\"\nconditional = f\"Status: {'active' if is_active else 'inactive'}\"\n\n# ‚úÖ GOOD - Multiline f-strings\nreport = (\n    f\"User Report\\n\"\n    f\"Name: {user.name}\\n\"\n    f\"Email: {user.email}\\n\"\n    f\"Items: {len(user.items)}\\n\"\n)\n\n# ‚úÖ GOOD - Template strings for user input (security)\nfrom string import Template\n\ntemplate = Template(\"Hello, $name!\")\nmessage = template.safe_substitute(name=user_input)  # Safe from injection\n\n# ‚úÖ ACCEPTABLE - .format() for reusable templates\ntemplate = \"User {name} has {count} items\"\nmessage = template.format(name=name, count=count)\n\n# ‚ùå BAD - % formatting (legacy)\nmessage = \"Hello, %s! You have %d items.\" % (name, count)\n\n# ‚ùå BAD - String concatenation in loops\nresult = \"\"\nfor item in items:\n    result += str(item) + \", \"  # O(n¬≤) time complexity\n\n# ‚úÖ GOOD - Join for building strings\nresult = \", \".join(str(item) for item in items)\n```\n\n### 11. Imports\n\n#### Import Order\n\n1. Standard library imports\n2. Third-party imports\n3. Local application imports\n\n```python\n# Standard library\nimport os\nimport sys\nfrom datetime import datetime\nfrom typing import Any, Optional\n\n# Third-party\nimport requests\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String\n\n# Local application\nfrom app.core.config import settings\nfrom app.models.user import User\nfrom app.services.user_service import UserService\n```\n\n#### Import Best Practices\n\n```python\n# ‚úÖ GOOD - Absolute imports\nfrom app.services.user_service import UserService\n\n# ‚ùå BAD - Relative imports (avoid except in packages)\nfrom ..services.user_service import UserService\n\n# ‚úÖ GOOD - Import specific items\nfrom typing import Optional, List, Dict\n\n# ‚ùå BAD - Wildcard imports (pollutes namespace)\nfrom typing import *\nfrom app.models import *\n\n# ‚úÖ GOOD - Import what you need\nfrom app.models.user import User\n\n# ‚úÖ ACCEPTABLE - Import module when many items needed\nfrom app import models\n# Then use: models.User, models.Post, etc.\n\n# ‚úÖ GOOD - Alias for clarity\nfrom app.models.user import User as UserModel\nfrom app.schemas.user import User as UserSchema\n\n# ‚úÖ GOOD - Type-only imports for circular dependencies\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from app.services.user_service import UserService\n```\n\n### 12. Docstrings\n\nUse Google-style docstrings for all public functions, classes, and modules.\n\n```python\ndef fetch_user_data(\n    user_id: int,\n    include_posts: bool = False,\n    max_posts: int | None = None,\n) -> dict[str, Any]:\n    \"\"\"\n    Fetch user data from the API.\n\n    Retrieves user information and optionally their recent posts.\n    Results are cached for 5 minutes.\n\n    Args:\n        user_id: The unique identifier of the user\n        include_posts: Whether to include user's posts in the response\n        max_posts: Maximum number of posts to include (None for all)\n\n    Returns:\n        Dictionary containing user data with the following keys:\n        - id: User ID\n        - name: User's full name\n        - email: User's email address\n        - posts: List of posts (if include_posts is True)\n\n    Raises:\n        NotFoundError: If user with given ID doesn't exist\n        AuthenticationError: If API authentication fails\n        RateLimitError: If API rate limit is exceeded\n\n    Example:\n        >>> user_data = fetch_user_data(123, include_posts=True, max_posts=10)\n        >>> print(user_data[\"name\"])\n        \"John Doe\"\n        >>> len(user_data[\"posts\"])\n        10\n    \"\"\"\n    pass\n\n\nclass UserRepository:\n    \"\"\"\n    Repository for user data access.\n\n    Provides methods for CRUD operations on user entities.\n    Uses connection pooling for optimal performance.\n\n    Attributes:\n        database: Database connection instance\n        cache: Optional cache for read operations\n\n    Example:\n        >>> repo = UserRepository(database)\n        >>> user = await repo.get_by_id(123)\n        >>> print(user.name)\n        \"John Doe\"\n    \"\"\"\n\n    def __init__(self, database: Database, cache: Cache | None = None) -> None:\n        \"\"\"\n        Initialize UserRepository.\n\n        Args:\n            database: Database connection to use\n            cache: Optional cache instance for read-through caching\n        \"\"\"\n        self.database = database\n        self.cache = cache\n```\n\n### 13. Formatting and Style\n\n**Indentation:**\n- Use 4 spaces (never tabs)\n- Consistent indentation throughout\n\n**Line Length:**\n- Maximum 100 characters (configurable, 88 for Black default)\n- Break long lines appropriately\n\n**Blank Lines:**\n- Two blank lines between top-level definitions\n- One blank line between methods in a class\n- No blank lines at start/end of functions\n\n**Quotes:**\n- Use double quotes for strings: `\"hello\"`\n- Use single quotes when string contains double quotes: `'He said \"hello\"'`\n- Use triple double quotes for docstrings: `\"\"\"Docstring\"\"\"`\n\n```python\n# ‚úÖ GOOD - Proper formatting\nimport os\nfrom typing import Optional\n\n\nMAX_RETRIES = 3\n\n\nclass UserService:\n    \"\"\"Service for user operations.\"\"\"\n\n    def __init__(self, database: Database) -> None:\n        self.database = database\n\n    def get_user(self, user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID.\"\"\"\n        return self.database.fetch_user(user_id)\n\n    def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create a new user.\"\"\"\n        return self.database.create_user(user_data)\n\n\ndef helper_function() -> None:\n    \"\"\"A helper function.\"\"\"\n    pass\n```\n\n### 14. Decorators\n\n```python\nfrom functools import wraps\nfrom typing import Callable, TypeVar, ParamSpec\n\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\n\n\n# ‚úÖ GOOD - Type-safe decorator\ndef retry(max_attempts: int = 3, delay: float = 1.0) -> Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Retry decorator with configurable attempts and delay.\"\"\"\n    def decorator(func: Callable[P, R]) -> Callable[P, R]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n            last_exception: Exception | None = None\n            for attempt in range(1, max_attempts + 1):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as error:\n                    last_exception = error\n                    if attempt < max_attempts:\n                        time.sleep(delay)\n            raise last_exception\n        return wrapper\n    return decorator\n\n\n# Usage\n@retry(max_attempts=3, delay=0.5)\ndef fetch_data(url: str) -> dict:\n    \"\"\"Fetch data with automatic retry.\"\"\"\n    pass\n\n\n# ‚úÖ GOOD - Caching decorator\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef expensive_computation(value: int) -> int:\n    \"\"\"Cached expensive computation.\"\"\"\n    return value ** 2\n\n\n# ‚úÖ GOOD - Validation decorator\ndef validate_positive(func: Callable[P, R]) -> Callable[P, R]:\n    \"\"\"Ensure first argument is positive.\"\"\"\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        if args and args[0] <= 0:\n            raise ValueError(\"First argument must be positive\")\n        return func(*args, **kwargs)\n    return wrapper\n\n\n@validate_positive\ndef calculate_square_root(value: float) -> float:\n    \"\"\"Calculate square root of positive number.\"\"\"\n    return value ** 0.5\n```\n\n### 15. Testing Considerations\n\n```python\n# ‚úÖ GOOD - Testable code with dependency injection\nclass UserService:\n    \"\"\"User service with injectable dependencies.\"\"\"\n\n    def __init__(\n        self,\n        repository: UserRepository,\n        email_service: EmailService,\n    ) -> None:\n        self._repository = repository\n        self._email_service = email_service\n\n    async def create_user(self, user_data: UserCreate) -> User:\n        \"\"\"Create user and send welcome email.\"\"\"\n        user = await self._repository.create(user_data)\n        await self._email_service.send_welcome(user)\n        return user\n\n\n# ‚úÖ GOOD - Factory functions for test fixtures\ndef create_test_user(\n    user_id: int = 1,\n    name: str = \"Test User\",\n    email: str = \"test@example.com\",\n    is_active: bool = True,\n) -> User:\n    \"\"\"Create a test user with customizable defaults.\"\"\"\n    return User(\n        id=user_id,\n        name=name,\n        email=email,\n        is_active=is_active,\n    )\n\n\n# ‚úÖ GOOD - Type-safe mock\nfrom unittest.mock import AsyncMock, MagicMock\n\ndef create_mock_repository() -> MagicMock:\n    \"\"\"Create mock repository for testing.\"\"\"\n    mock = MagicMock(spec=UserRepository)\n    mock.get_by_id = AsyncMock(return_value=create_test_user())\n    mock.create = AsyncMock(side_effect=lambda data: create_test_user(**data.dict()))\n    return mock\n```\n\n### 16. Common Patterns to Avoid\n\n```python\n# ‚ùå BAD - Mutable default arguments\ndef add_item(item: str, items: list = []) -> list:\n    items.append(item)\n    return items\n\n# ‚úÖ GOOD - Use None as default\ndef add_item(item: str, items: list | None = None) -> list:\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# ‚ùå BAD - Using type() for type checking\nif type(value) == str:\n    pass\n\n# ‚úÖ GOOD - Use isinstance()\nif isinstance(value, str):\n    pass\n\n# ‚ùå BAD - Catching and ignoring exceptions\ntry:\n    risky_operation()\nexcept Exception:\n    pass\n\n# ‚úÖ GOOD - Handle exceptions properly\ntry:\n    risky_operation()\nexcept SpecificError as error:\n    logger.error(\"Operation failed: %s\", error)\n    raise ApplicationError(\"Operation failed\") from error\n\n# ‚ùå BAD - Using bare `assert` for validation\ndef set_age(age: int) -> None:\n    assert age >= 0, \"Age must be non-negative\"  # Can be disabled with -O\n\n# ‚úÖ GOOD - Proper validation\ndef set_age(age: int) -> None:\n    if age < 0:\n        raise ValueError(\"Age must be non-negative\")\n\n# ‚ùå BAD - Global mutable state\n_users = []\n\ndef add_user(user: User) -> None:\n    _users.append(user)\n\n# ‚úÖ GOOD - Encapsulate state in classes\nclass UserStore:\n    def __init__(self) -> None:\n        self._users: list[User] = []\n\n    def add_user(self, user: User) -> None:\n        self._users.append(user)\n\n# ‚ùå BAD - Checking for None/empty with ==\nif value == None:\n    pass\nif items == []:\n    pass\n\n# ‚úÖ GOOD - Use is None and truthiness\nif value is None:\n    pass\nif not items:\n    pass\n```\n\n### 17. Performance Best Practices\n\n```python\n# ‚úÖ GOOD - Use generators for large datasets\ndef read_large_file(filepath: str) -> Generator[str, None, None]:\n    \"\"\"Read large file line by line.\"\"\"\n    with open(filepath) as file:\n        for line in file:\n            yield line.strip()\n\n# ‚úÖ GOOD - Use set for membership testing\nallowed_ids = {1, 2, 3, 4, 5}  # O(1) lookup\nif user_id in allowed_ids:\n    pass\n\n# ‚ùå BAD - List for membership testing\nallowed_ids = [1, 2, 3, 4, 5]  # O(n) lookup\nif user_id in allowed_ids:\n    pass\n\n# ‚úÖ GOOD - Use dict.get() with default\nvalue = data.get(\"key\", default_value)\n\n# ‚ùå BAD - Check then access\nif \"key\" in data:\n    value = data[\"key\"]\nelse:\n    value = default_value\n\n# ‚úÖ GOOD - Use collections.defaultdict\nfrom collections import defaultdict\n\ncounts = defaultdict(int)\nfor item in items:\n    counts[item.category] += 1\n\n# ‚úÖ GOOD - Use slots for memory efficiency\nclass Point:\n    __slots__ = (\"x\", \"y\")\n\n    def __init__(self, x: float, y: float) -> None:\n        self.x = x\n        self.y = y\n\n# ‚úÖ GOOD - Cache expensive computations\nfrom functools import cache\n\n@cache\ndef fibonacci(n: int) -> int:\n    \"\"\"Calculate fibonacci number with caching.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n```\n\n## Code Quality Checklist\n\nBefore submitting code, ensure:\n\n- [ ] All functions have type hints (parameters and return types)\n- [ ] All public functions have docstrings\n- [ ] No suppressed linter errors (`# type: ignore`, `# noqa` without reason)\n- [ ] All variables use descriptive, non-abbreviated names\n- [ ] Complex logic is documented with comments explaining \"why\"\n- [ ] Error handling is implemented properly (no bare except)\n- [ ] Code follows formatting guidelines (run Black, isort)\n- [ ] No mutations of function parameters\n- [ ] Proper use of async/await for I/O operations\n- [ ] Tests are written for new functionality\n\n## Pre-commit Configuration\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 24.4.2\n    hooks:\n      - id: black\n\n  - repo: https://github.com/pycqa/isort\n    rev: 5.13.2\n    hooks:\n      - id: isort\n\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.4.4\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.10.0\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n```\n\n## pyproject.toml Configuration\n\n```toml\n[tool.black]\nline-length = 100\ntarget-version = ['py311']\n\n[tool.isort]\nprofile = \"black\"\nline_length = 100\n\n[tool.ruff]\nline-length = 100\ntarget-version = \"py311\"\n\n[tool.ruff.lint]\nselect = [\n    \"E\",    # pycodestyle errors\n    \"W\",    # pycodestyle warnings\n    \"F\",    # pyflakes\n    \"I\",    # isort\n    \"B\",    # flake8-bugbear\n    \"C4\",   # flake8-comprehensions\n    \"UP\",   # pyupgrade\n]\n\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_ignores = true\n```\n\n## Remember\n\n- **Python is readable by design** - write code that reads like prose\n- **Explicit is better than implicit** - be clear about your intentions\n- **Type hints are documentation** - they help both humans and tools\n- **Errors should never pass silently** - always handle exceptions properly\n- **Consistency is key** - follow these patterns uniformly across the codebase\n",
          "alwaysApply": true,
          "globs": [
            "**/*.py"
          ]
        }
      ]
    },
    {
      "id": "typescript",
      "name": "TypeScript",
      "directory": "Typescript",
      "icon": "icons/typescript.png",
      "summary": "Type-safe JavaScript development",
      "focus": "Type safety, code quality, best practices",
      "readme": "# Cursor Rules for TypeScript Projects\n\nThis folder contains Cursor AI coding rules and guidelines for general TypeScript projects. These rules help maintain consistency, code quality, and best practices when working with TypeScript codebases and AI assistants in Cursor.\n\n## What are Cursor Rules?\n\nCursor rules are markdown files (`.mdc` format) that provide context and guidelines to AI coding assistants. They help ensure that AI-generated code follows your project's specific patterns, conventions, and best practices.\n\n## Overview of Rules\n\n### üìò TypeScript Code Style Guide (`typescript-code-style-guide.mdc`)\n\nA comprehensive TypeScript coding standards guide that establishes best practices for writing type-safe, maintainable TypeScript code.\n\n**Core Principles:**\n- **Type Safety First** - Leverage TypeScript's type system fully, never use `any`\n- **Functional Over Classes** - Prefer functions, closures, and composition over classes and inheritance\n- **Descriptive Naming** - Never abbreviate variables, always use full descriptive names\n- **Maintainability** - Code should be clear and self-documenting\n- **Consistency** - Uniform patterns across the codebase\n- **Quality** - No shortcuts, no suppressed errors, no technical debt\n\n**Key Topics Covered:**\n\n1. **Type Safety**\n   - Never use `any` - use `unknown` and narrow it\n   - Avoid `@ts-ignore` or `@ts-expect-error`\n   - Explicit return types for public APIs\n   - Type guards for runtime type checking\n\n2. **Naming Conventions**\n   - Variables & Functions: `camelCase`\n   - Classes & Types: `PascalCase`\n   - Constants: `UPPER_SNAKE_CASE` (exported) or `camelCase` (local)\n   - **NEVER abbreviate** - always use full, descriptive names\n\n3. **Type Definitions**\n   - Interfaces vs Type Aliases (when to use each)\n   - Discriminated unions for type-safe state management\n   - Generic types and constraints\n   - Utility types (built-in and custom)\n\n4. **Function Signatures**\n   - Explicit return types\n   - Default parameters\n   - Rest parameters\n   - JSDoc documentation\n\n5. **Advanced Patterns**\n   - Type guards and narrowing\n   - Optional chaining and nullish coalescing\n   - Error handling with custom error classes\n   - Async/await patterns\n   - Functional composition over class inheritance\n\n6. **Code Quality**\n   - No suppressed lint errors\n   - Proper error handling\n   - Documentation standards\n   - Testing considerations\n   - Performance patterns\n\n## How to Use These Rules\n\n### In Cursor IDE\n\n1. **Automatic Application:** Files with `alwaysApply: true` in their frontmatter are automatically applied to all AI interactions.\n\n2. **Context-Aware Application:** Files with `globs` patterns are applied when working with matching file types or directories.\n\n3. **Manual Reference:** You can reference specific rules in your prompts:\n   ```\n   @typescript-code-style-guide.mdc Please refactor this function to follow our TypeScript style guide\n   ```\n\n### File Structure\n\n```\nTypescript/\n‚îú‚îÄ‚îÄ README.md (this file)\n‚îî‚îÄ‚îÄ typescript-code-style-guide.mdc\n```\n\n## Quick Reference\n\n### When Writing TypeScript Code\n\n- ‚úÖ **Never use `any`** - Use `unknown` if type is truly unknown, then narrow it\n- ‚úÖ **Avoid classes** - Use functions, closures, and composition instead (see note below)\n- ‚úÖ **Always use descriptive names** - Never abbreviate variables\n- ‚úÖ **Provide explicit return types** - Especially for exported functions\n- ‚úÖ **Use type guards** - For runtime type checking and narrowing\n- ‚úÖ **Leverage discriminated unions** - For complex state management\n- ‚úÖ **Document public APIs** - Use JSDoc for complex functions\n- ‚úÖ **Never suppress errors** - Fix the root cause, don't hide it\n- ‚úÖ **Use proper error handling** - Custom error classes with type safety\n- ‚úÖ **Prefer interfaces** - For object shapes that might be extended\n- ‚úÖ **Use type aliases** - For unions, intersections, and computed types\n\n> ‚ö†Ô∏è **Important: Prefer Functional Paradigms Over Classes**\n>\n> Classes introduce hidden state, complex inheritance hierarchies, and unnecessary overhead. Modern TypeScript with functional patterns is cleaner, more testable, and easier to reason about. Use pure functions, closures, and composition instead. Only use classes when absolutely necessary (custom Error classes, framework requirements, or genuinely complex stateful objects).\n\n### Type Safety Checklist\n\nBefore submitting code, ensure:\n\n- [ ] No `any` types (use `unknown` and narrow)\n- [ ] No unnecessary classes (use functions and closures instead)\n- [ ] All exported functions have explicit return types\n- [ ] No suppressed lint errors (`@ts-ignore`, `eslint-disable`)\n- [ ] All variables use descriptive, non-abbreviated names\n- [ ] Complex logic is documented with JSDoc\n- [ ] Error handling is implemented properly\n- [ ] Type guards are used for runtime type checking\n- [ ] Code follows formatting guidelines (2-space indentation, semicolons)\n- [ ] No mutations of function parameters\n- [ ] Proper use of `const`/`let` (prefer `const`)\n\n### Common Patterns\n\n#### Type-Safe Function\n\n```typescript\n/**\n * Calculates the total price of items with optional discount.\n *\n * @param items - Array of items with price property\n * @param discountPercentage - Optional discount (0-100)\n * @returns Total price after discount\n * @throws {ValidationError} If discount is out of range\n */\nfunction calculateTotal(\n  items: Item[],\n  discountPercentage: number = 0\n): number {\n  if (discountPercentage < 0 || discountPercentage > 100) {\n    throw new ValidationError('Discount must be between 0 and 100');\n  }\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  return subtotal * (1 - discountPercentage / 100);\n}\n```\n\n#### Type Guard\n\n```typescript\nfunction isUser(obj: unknown): obj is User {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'id' in obj &&\n    'name' in obj &&\n    typeof (obj as User).id === 'string'\n  );\n}\n\nfunction processValue(value: unknown) {\n  if (isUser(value)) {\n    // TypeScript knows value is User here\n    return value.name;\n  }\n  throw new Error('Invalid value type');\n}\n```\n\n#### Discriminated Union\n\n```typescript\ntype AsyncState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\nfunction handleState<T>(state: AsyncState<T>) {\n  switch (state.status) {\n    case 'idle':\n      return 'Ready';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Data: ${state.data}`; // TypeScript knows data exists\n    case 'error':\n      return `Error: ${state.error.message}`; // TypeScript knows error exists\n  }\n}\n```\n\n## Integration with Framework-Specific Rules\n\nThis general TypeScript guide can be used alongside framework-specific rules:\n\n- **TypeScript + React + Next.js:** See `../Typescript-React + Nextjs/` for React-specific patterns\n- **TypeScript + Node.js:** Use this guide with Node.js best practices\n- **TypeScript + Express:** Combine with Express.js patterns\n- **Any TypeScript Project:** This guide provides the foundation for all TypeScript projects\n\n## Best Practices Summary\n\n### DO ‚úÖ\n\n- Use TypeScript's type system fully\n- **Use functions and closures instead of classes**\n- **Use composition instead of inheritance**\n- Write descriptive, non-abbreviated variable names\n- Provide explicit return types for public APIs\n- Use type guards for runtime type checking\n- Leverage discriminated unions for complex state\n- Document complex logic with JSDoc\n- Handle errors properly with custom error classes\n- Use interfaces for object shapes\n- Use type aliases for unions and computed types\n\n### DON'T ‚ùå\n\n- Never use `any` - use `unknown` and narrow\n- **Never use classes unless absolutely necessary** (Error classes, framework APIs, complex state)\n- **Never use inheritance when composition works**\n- Never suppress errors - fix the root cause\n- Never abbreviate variables - use full names\n- Never skip return types on exported functions\n- Never mutate function parameters\n- Never use non-null assertions without checks\n- Never use type assertions without validation\n- Never hide lint errors\n\n## Related Guidelines\n\nFor framework-specific TypeScript patterns, see:\n\n- **[TypeScript-React + Nextjs](../Typescript-React%20+%20Nextjs/)** - React and Next.js specific patterns\n- **[Root README](../README.md)** - Overview of all coding rules\n\n## Contributing\n\nWhen updating these rules:\n\n1. Keep guidelines clear and actionable\n2. Include examples where helpful (BAD vs GOOD patterns)\n3. Update this README if adding new rule files\n4. Ensure consistency with other TypeScript-related rules\n5. Test guidelines work well with AI assistants\n\n## Notes\n\n- These rules are designed for general TypeScript projects\n- Rules marked with `alwaysApply: true` are enforced automatically\n- The guide emphasizes type safety and code quality above all else\n- Never suppress errors - always fix the root cause\n- When used with framework-specific rules, this guide provides the TypeScript foundation\n\n## Remember\n\n- **TypeScript is a tool for safety** - use it fully, don't bypass it\n- **Functions over classes** - prefer functional paradigms for cleaner, more testable code\n- **Readability matters** - code is read more than written\n- **Consistency is key** - follow these patterns uniformly\n- **Fix, don't suppress** - every error is an opportunity to improve\n- **Document intent** - comments explain \"why\", types explain \"what\"\n\n\n\n\n",
      "guides": [
        {
          "id": "typescript-code-style-guide",
          "title": "Typescript Code Style Guide",
          "fileName": "typescript-code-style-guide.mdc",
          "frontmatter": {
            "description": "General TypeScript code style guide based on quality and style patterns from the codebase",
            "globs": [
              "**/*.ts",
              "**/*.tsx"
            ],
            "alwaysApply": true
          },
          "content": "# TypeScript Code Style Guide\n\n## Philosophy\n\nThis guide establishes TypeScript coding standards that prioritize:\n\n1. **Type Safety** - Leverage TypeScript's type system fully\n2. **Functional Paradigms** - Prefer functions over classes, composition over inheritance\n3. **Maintainability** - Code should be clear and self-documenting\n4. **Consistency** - Uniform patterns across the codebase\n5. **Quality** - No shortcuts, no suppressed errors, no technical debt\n6. **Developer Experience** - Code that's pleasant to read and work with\n\n## Core Principles\n\n### 1. Type Safety First\n\nTypeScript's primary value is type safety. Use it fully:\n\n```typescript\n// ‚ùå BAD - Losing type safety\nfunction processData(data: any): any {\n  return data.value;\n}\n\n// ‚úÖ GOOD - Proper types\nfunction processData<T extends { value: unknown }>(data: T): T[\"value\"] {\n  return data.value;\n}\n\n// ‚úÖ BETTER - Explicit interface\ninterface ProcessableData {\n  value: unknown;\n}\n\nfunction processData(data: ProcessableData): unknown {\n  return data.value;\n}\n```\n\n**Rules:**\n\n- Never use `any` - use `unknown` if type is truly unknown, then narrow it\n- Avoid `@ts-ignore` or `@ts-expect-error` - fix the root cause\n- Prefer explicit return types for public APIs\n- Use type guards for runtime type checking\n- Leverage discriminated unions for complex state\n\n### 2. Descriptive Naming\n\n**NEVER abbreviate variables.** Always use full, descriptive names.\n\n```typescript\n// ‚ùå BAD - Abbreviated and unclear\nconst wf = workflows.filter((w) => w.status === \"active\");\nconst usr = users.find((u) => u.id === id);\nfunction calcTotal(items: Item[]) {}\n\n// ‚úÖ GOOD - Clear and descriptive\nconst activeWorkflows = workflows.filter(\n  (workflow) => workflow.status === \"active\"\n);\nconst user = users.find((user) => user.id === userId);\nfunction calculateTotal(items: Item[]): number {}\n```\n\n**Naming Conventions:**\n\n- **Variables & Functions:** `camelCase` - `getUserProfile`, `isValid`, `hasPermission`\n- **Classes & Types:** `PascalCase` - `UserService`, `ValidationError`, `ApiResponse`\n- **Constants:** `UPPER_SNAKE_CASE` for exported constants, `camelCase` for local\n- **Interfaces:** `PascalCase` - often without `I` prefix (e.g., `User` not `IUser`)\n- **Type Parameters:** Single uppercase letter - `T`, `K`, `V`, `E` (or descriptive like `TData`)\n- **Private Members:** No prefix needed (TypeScript handles visibility)\n\n### 3. Type Definitions\n\n#### Interfaces vs Type Aliases\n\n```typescript\n// ‚úÖ Use interfaces for object shapes that might be extended\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface AdminUser extends User {\n  permissions: string[];\n}\n\n// ‚úÖ Use type aliases for unions, intersections, and computed types\ntype Status = \"pending\" | \"active\" | \"inactive\";\ntype UserWithStatus = User & { status: Status };\ntype UserKeys = keyof User;\n```\n\n**Guidelines:**\n\n- Prefer `interface` for object shapes (better error messages, extensibility)\n- Use `type` for unions, intersections, and computed types\n- Use `type` for primitive aliases and tuple types\n\n#### Discriminated Unions\n\n```typescript\n// ‚úÖ GOOD - Type-safe state management\ntype AsyncState<T> =\n  | { status: \"idle\" }\n  | { status: \"loading\" }\n  | { status: \"success\"; data: T }\n  | { status: \"error\"; error: Error };\n\nfunction handleState<T>(state: AsyncState<T>) {\n  switch (state.status) {\n    case \"idle\":\n      return \"Ready\";\n    case \"loading\":\n      return \"Loading...\";\n    case \"success\":\n      return `Data: ${state.data}`; // TypeScript knows data exists\n    case \"error\":\n      return `Error: ${state.error.message}`; // TypeScript knows error exists\n  }\n}\n```\n\n### 4. Function Signatures\n\n```typescript\n// ‚úÖ GOOD - Clear, typed, documented\n/**\n * Calculates the total price of items with optional discount.\n *\n * @param items - Array of items with price property\n * @param discountPercentage - Optional discount (0-100)\n * @returns Total price after discount\n * @throws {ValidationError} If discount is out of range\n */\nfunction calculateTotal(items: Item[], discountPercentage: number = 0): number {\n  if (discountPercentage < 0 || discountPercentage > 100) {\n    throw new ValidationError(\"Discount must be between 0 and 100\");\n  }\n\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  return subtotal * (1 - discountPercentage / 100);\n}\n```\n\n**Best Practices:**\n\n- Always provide explicit return types for exported functions\n- Use default parameters instead of optional parameters when possible\n- Put required parameters first, optional/default parameters last\n- Use rest parameters (`...args`) instead of `arguments`\n- Document complex functions with JSDoc\n\n### 5. Generics\n\n```typescript\n// ‚úÖ GOOD - Flexible and type-safe\nfunction identity<T>(value: T): T {\n  return value;\n}\n\n// ‚úÖ GOOD - Constrained generics\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\n// ‚úÖ GOOD - Multiple type parameters with constraints\nfunction mergeObjects<T extends object, U extends object>(\n  obj1: T,\n  obj2: U\n): T & U {\n  return { ...obj1, ...obj2 };\n}\n\n// ‚úÖ GOOD - Generic utility types\ntype ApiResponse<T> = {\n  data: T;\n  status: number;\n  message: string;\n};\n\nasync function fetchData<T>(): Promise<ApiResponse<T>> {\n  // Implementation\n}\n```\n\n### 6. Type Guards and Narrowing\n\n```typescript\n// ‚úÖ GOOD - Type guard functions\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nfunction isUser(obj: unknown): obj is User {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"id\" in obj &&\n    \"name\" in obj &&\n    typeof (obj as User).id === \"string\"\n  );\n}\n\n// ‚úÖ GOOD - Usage with narrowing\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript knows value is string here\n    return value.toUpperCase();\n  }\n\n  if (isUser(value)) {\n    // TypeScript knows value is User here\n    return value.name;\n  }\n\n  throw new Error(\"Invalid value type\");\n}\n```\n\n### 7. Optional Chaining and Nullish Coalescing\n\n```typescript\n// ‚ùå BAD - Verbose null checking\nconst userName =\n  user && user.profile && user.profile.name ? user.profile.name : \"Anonymous\";\n\n// ‚úÖ GOOD - Optional chaining and nullish coalescing\nconst userName = user?.profile?.name ?? \"Anonymous\";\n\n// ‚úÖ GOOD - With function calls\nconst result = data?.map((item) => processItem(item)) ?? [];\n\n// ‚úÖ GOOD - With array access\nconst firstItem = items?.[0];\n```\n\n### 8. Array and Object Patterns\n\n```typescript\n// ‚úÖ GOOD - Array methods with proper typing\nconst activeUsers: User[] = users.filter(\n  (user): user is User => user.status === \"active\"\n);\n\nconst userIds: string[] = users.map((user) => user.id);\n\nconst totalPrice: number = items.reduce((sum, item) => sum + item.price, 0);\n\n// ‚úÖ GOOD - Object destructuring with types\nfunction processUser({ id, name, email }: User): ProcessedUser {\n  return { id, name, email: email.toLowerCase() };\n}\n\n// ‚úÖ GOOD - Array destructuring\nconst [first, second, ...rest] = items;\n\n// ‚úÖ GOOD - Rest parameters\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((sum, num) => sum + num, 0);\n}\n```\n\n### 9. Error Handling\n\n```typescript\n// ‚úÖ GOOD - Custom error classes\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n    public code: string = \"VALIDATION_ERROR\"\n  ) {\n    super(message);\n    this.name = \"ValidationError\";\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\n// ‚úÖ GOOD - Type-safe error handling\nfunction parseJson<T>(json: string): T {\n  try {\n    return JSON.parse(json) as T;\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new ValidationError(\"Invalid JSON format\", \"json\", \"INVALID_JSON\");\n    }\n    throw error;\n  }\n}\n\n// ‚úÖ GOOD - Result type pattern\ntype Result<T, E = Error> =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\nfunction safeParse<T>(json: string): Result<T> {\n  try {\n    return { success: true, data: JSON.parse(json) as T };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error(\"Unknown error\"),\n    };\n  }\n}\n```\n\n### 10. Async/Await Patterns\n\n```typescript\n// ‚úÖ GOOD - Proper async typing\nasync function fetchUser(userId: string): Promise<User> {\n  const response = await fetch(`/api/users/${userId}`);\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch user: ${response.statusText}`);\n  }\n\n  return response.json() as Promise<User>;\n}\n\n// ‚úÖ GOOD - Parallel execution\nasync function fetchUserData(userId: string): Promise<UserData> {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(userId),\n    fetchUserPosts(userId),\n    fetchUserComments(userId),\n  ]);\n\n  return { user, posts, comments };\n}\n\n// ‚úÖ GOOD - Error handling in async\nasync function safeFetchUser(userId: string): Promise<User | null> {\n  try {\n    return await fetchUser(userId);\n  } catch (error) {\n    console.error(\"Failed to fetch user:\", error);\n    return null;\n  }\n}\n```\n\n### 11. Prefer Functions Over Classes\n\n**‚ö†Ô∏è IMPORTANT: Avoid classes unless absolutely necessary.**\n\nClasses introduce unnecessary overhead, hidden state, and complexity. Modern TypeScript with functional patterns is cleaner, more testable, and easier to reason about. Use pure functions, closures, and composition instead.\n\n**When classes ARE acceptable:**\n\n- Custom Error classes (extending `Error`)\n- When required by a framework/library API\n- Complex stateful objects where encapsulation truly helps\n\n```typescript\n// ‚ùå BAD - Class with hidden state and methods\nclass UserService {\n  private readonly apiUrl: string;\n\n  constructor(apiUrl: string = \"/api\") {\n    this.apiUrl = apiUrl;\n  }\n\n  async getUser(userId: string): Promise<User> {\n    const response = await fetch(`${this.apiUrl}/users/${userId}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user: ${response.statusText}`);\n    }\n    return response.json() as Promise<User>;\n  }\n\n  async createUser(userData: CreateUserData): Promise<User> {\n    const response = await fetch(`${this.apiUrl}/users`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(userData),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to create user: ${response.statusText}`);\n    }\n\n    return response.json() as Promise<User>;\n  }\n}\n\n// ‚úÖ GOOD - Functional approach with explicit dependencies\ninterface UserServiceConfig {\n  apiUrl: string;\n}\n\nfunction createUserService(config: UserServiceConfig = { apiUrl: \"/api\" }) {\n  const { apiUrl } = config;\n\n  async function getUser(userId: string): Promise<User> {\n    const response = await fetch(`${apiUrl}/users/${userId}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user: ${response.statusText}`);\n    }\n    return response.json() as Promise<User>;\n  }\n\n  async function createUser(userData: CreateUserData): Promise<User> {\n    const response = await fetch(`${apiUrl}/users`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(userData),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to create user: ${response.statusText}`);\n    }\n\n    return response.json() as Promise<User>;\n  }\n\n  return { getUser, createUser };\n}\n\n// ‚úÖ EVEN BETTER - Pure functions with dependency injection\nasync function getUser(apiUrl: string, userId: string): Promise<User> {\n  const response = await fetch(`${apiUrl}/users/${userId}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch user: ${response.statusText}`);\n  }\n  return response.json() as Promise<User>;\n}\n\nasync function createUser(\n  apiUrl: string,\n  userData: CreateUserData\n): Promise<User> {\n  const response = await fetch(`${apiUrl}/users`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(userData),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to create user: ${response.statusText}`);\n  }\n\n  return response.json() as Promise<User>;\n}\n\n// ‚úÖ GOOD - Composition over inheritance\nfunction createFetcher(resourceName: string) {\n  return async function fetch<T>(endpoint: string): Promise<T> {\n    const response = await globalThis.fetch(`/api/${resourceName}${endpoint}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${resourceName}`);\n    }\n    return response.json() as Promise<T>;\n  };\n}\n\n// Usage - compose functions instead of extending classes\nconst fetchPost = createFetcher(\"posts\");\nconst getPost = (id: string): Promise<Post> => fetchPost<Post>(`/${id}`);\n\nconst fetchUser = createFetcher(\"users\");\nconst getUserById = (id: string): Promise<User> => fetchUser<User>(`/${id}`);\n```\n\n### 12. Utility Types\n\n```typescript\n// ‚úÖ GOOD - Leverage built-in utility types\ntype PartialUser = Partial<User>;\ntype RequiredUser = Required<User>;\ntype UserEmail = Pick<User, \"email\">;\ntype UserWithoutId = Omit<User, \"id\">;\ntype ReadonlyUser = Readonly<User>;\n\n// ‚úÖ GOOD - Custom utility types\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\n// ‚úÖ GOOD - Conditional types\ntype NonEmptyArray<T> = [T, ...T[]];\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n```\n\n### 13. Module Organization\n\n```typescript\n// ‚úÖ GOOD - Clear exports\n// utils/validation.ts\nexport function isValidEmail(email: string): boolean {\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}\n\nexport function isValidPhone(phone: string): boolean {\n  return /^\\d{10}$/.test(phone);\n}\n\n// ‚úÖ GOOD - Re-exports for convenience\n// utils/index.ts\nexport * from \"./validation\";\nexport * from \"./formatting\";\nexport { default as ApiClient } from \"./api\";\n\n// ‚úÖ GOOD - Default exports for single-purpose modules\n// services/UserService.ts\nclass UserService {\n  // Implementation\n}\n\nexport default UserService;\n```\n\n### 14. Type Assertions (Use Sparingly)\n\n```typescript\n// ‚ùå BAD - Unsafe type assertion\nconst user = data as User; // What if data isn't actually a User?\n\n// ‚úÖ GOOD - Type guard first\nfunction isUser(data: unknown): data is User {\n  return (\n    typeof data === \"object\" && data !== null && \"id\" in data && \"name\" in data\n  );\n}\n\nif (isUser(data)) {\n  const user = data; // TypeScript knows it's User\n}\n\n// ‚úÖ ACCEPTABLE - When you're certain (with comment explaining why)\n// This is safe because we validate the API response structure\nconst user = apiResponse as User;\n```\n\n### 15. Enums and Const Assertions\n\n```typescript\n// ‚úÖ GOOD - String enums (preferred)\nenum UserRole {\n  Admin = \"admin\",\n  User = \"user\",\n  Guest = \"guest\",\n}\n\n// ‚úÖ GOOD - Const assertions for literal types\nconst STATUSES = [\"pending\", \"active\", \"inactive\"] as const;\ntype Status = (typeof STATUSES)[number]; // 'pending' | 'active' | 'inactive'\n\n// ‚úÖ GOOD - Object with const assertion\nconst CONFIG = {\n  apiUrl: \"https://api.example.com\",\n  timeout: 5000,\n  retries: 3,\n} as const;\n\ntype Config = typeof CONFIG; // Readonly type\n```\n\n### 16. Comments and Documentation\n\n````typescript\n// ‚úÖ GOOD - JSDoc for public APIs\n/**\n * Validates user input and creates a new user account.\n *\n * @param userData - User registration data\n * @param userData.email - Valid email address\n * @param userData.password - Password (min 8 characters)\n * @returns Promise resolving to the created user\n * @throws {ValidationError} If input validation fails\n * @throws {ConflictError} If email already exists\n *\n * @example\n * ```typescript\n * const user = await createUser({\n *   email: 'user@example.com',\n *   password: 'securePassword123'\n * });\n * ```\n */\nasync function createUser(userData: CreateUserData): Promise<User> {\n  // Implementation\n}\n\n// ‚úÖ GOOD - Inline comments explain \"why\", not \"what\"\n// Using debounce to prevent excessive API calls during rapid typing\nconst debouncedSearch = debounce(handleSearch, 300);\n\n// ‚ùå BAD - Comments that just repeat the code\n// Set isLoading to true\nsetIsLoading(true);\n````\n\n### 17. Formatting and Style\n\n**Indentation:**\n\n- Use 2 spaces (never tabs)\n- Consistent indentation throughout\n\n**Semicolons:**\n\n- Always use semicolons to terminate statements\n\n**Quotes:**\n\n- Use single quotes for strings: `'hello'`\n- Use template literals for interpolation: `` `Hello, ${name}!` ``\n\n**Line Length:**\n\n- Maximum 100 characters per line (excluding long strings)\n- Break long lines appropriately\n\n**Spacing:**\n\n- One space before opening brace: `if (condition) {`\n- Spaces around operators: `const sum = a + b;`\n- No spaces inside parentheses: `if (condition)`\n- Trailing commas in multiline structures\n\n**Example:**\n\n```typescript\n// ‚úÖ GOOD - Proper formatting\nfunction calculateTotal(items: Item[], discount: number = 0): number {\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n\n  return subtotal * (1 - discount / 100);\n}\n```\n\n### 18. Common Patterns to Avoid\n\n```typescript\n// ‚ùå BAD - Using 'any' to bypass type checking\nfunction process(data: any): any {\n  return data.value;\n}\n\n// ‚ùå BAD - Suppressing TypeScript errors\n// @ts-ignore\nconst result = unsafeOperation();\n\n// ‚ùå BAD - Non-null assertions without checks\nconst value = data!.property;\n\n// ‚ùå BAD - Type assertions without validation\nconst user = apiResponse as User;\n\n// ‚ùå BAD - Abbreviated variable names\nconst wf = workflows.filter((w) => w.active);\n\n// ‚ùå BAD - Missing return types\nfunction calculateTotal(items) {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// ‚ùå BAD - Mutating parameters\nfunction updateUser(user: User) {\n  user.name = \"New Name\"; // Mutation!\n  return user;\n}\n\n// ‚ùå BAD - Unnecessary class when a function would suffice\nclass Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\n// ‚úÖ GOOD - Just use a function\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// ‚ùå BAD - Class with only static methods\nclass StringUtils {\n  static capitalize(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  static truncate(str: string, length: number): string {\n    return str.length > length ? str.slice(0, length) + \"...\" : str;\n  }\n}\n\n// ‚úÖ GOOD - Export functions directly\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function truncate(str: string, length: number): string {\n  return str.length > length ? str.slice(0, length) + \"...\" : str;\n}\n```\n\n### 19. Testing Considerations\n\n```typescript\n// ‚úÖ GOOD - Type-safe test utilities\nfunction createMockUser(overrides?: Partial<User>): User {\n  return {\n    id: \"1\",\n    name: \"Test User\",\n    email: \"test@example.com\",\n    ...overrides,\n  };\n}\n\n// ‚úÖ GOOD - Typed test helpers\nfunction expectUser(user: unknown): asserts user is User {\n  if (!isUser(user)) {\n    throw new Error(\"Expected User type\");\n  }\n}\n\n// ‚úÖ GOOD - Type-safe mocks\ntype MockApiClient = {\n  getUser: jest.MockedFunction<(id: string) => Promise<User>>;\n};\n\nconst mockApiClient: MockApiClient = {\n  getUser: jest.fn(),\n};\n```\n\n### 20. Performance Considerations\n\n```typescript\n// ‚úÖ GOOD - Memoization with proper types\nfunction memoize<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return\n): (...args: Args) => Return {\n  const cache = new Map<string, Return>();\n\n  return (...args: Args): Return => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// ‚úÖ GOOD - Lazy initialization with closures (no class needed)\nfunction createLazyClient() {\n  let client: ApiClient | null = null;\n\n  return function getClient(): ApiClient {\n    if (!client) {\n      client = createApiClient();\n    }\n    return client;\n  };\n}\n\nconst getApiClient = createLazyClient();\n```\n\n## Code Quality Checklist\n\nBefore submitting code, ensure:\n\n- [ ] No `any` types (use `unknown` and narrow)\n- [ ] No unnecessary classes (prefer functions and closures)\n- [ ] All exported functions have explicit return types\n- [ ] No suppressed lint errors (`@ts-ignore`, `eslint-disable`)\n- [ ] All variables use descriptive, non-abbreviated names\n- [ ] Complex logic is documented with JSDoc\n- [ ] Error handling is implemented properly\n- [ ] Type guards are used for runtime type checking\n- [ ] Code follows formatting guidelines\n- [ ] No mutations of function parameters\n- [ ] Proper use of `const`/`let` (prefer `const`)\n\n## Remember\n\n- **TypeScript is a tool for safety** - use it fully, don't bypass it\n- **Functions over classes** - prefer functional paradigms, they're cleaner and more testable\n- **Readability matters** - code is read more than written\n- **Consistency is key** - follow these patterns uniformly\n- **Fix, don't suppress** - every error is an opportunity to improve\n- **Document intent** - comments explain \"why\", types explain \"what\"\n",
          "alwaysApply": true,
          "globs": [
            "**/*.ts",
            "**/*.tsx"
          ]
        }
      ]
    }
  ],
  "generatedAt": "2025-12-08T17:38:59.009Z"
}